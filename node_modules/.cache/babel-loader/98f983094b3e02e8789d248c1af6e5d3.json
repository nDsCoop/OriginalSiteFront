{"ast":null,"code":"/* ========================================================================== \n *                           dexie-observable.js\n * ==========================================================================\n *\n * Dexie addon for observing database changes not just on local db instance\n * but also on other instances, tabs and windows.\n *\n * Comprises a base framework for dexie-syncable.js\n *\n * By David Fahlander, david.fahlander@gmail.com,\n *    Nikolas Poniros, https://github.com/nponiros\n *\n * ==========================================================================\n *\n * Version {version}, {date}\n *\n * http://dexie.org\n *\n * Apache License Version 2.0, January 2004, http://www.apache.org/licenses/\n * \n */\nimport Dexie from 'dexie';\n\nfunction nop() {}\n\nfunction promisableChain(f1, f2) {\n  if (f1 === nop) return f2;\n  return function () {\n    var res = f1.apply(this, arguments);\n\n    if (res && typeof res.then === 'function') {\n      var thiz = this,\n          args = arguments;\n      return res.then(function () {\n        return f2.apply(thiz, args);\n      });\n    }\n\n    return f2.apply(this, arguments);\n  };\n}\n\nfunction createUUID() {\n  // Decent solution from http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript\n  var d = Date.now();\n  var uuid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n    var r = (d + Math.random() * 16) % 16 | 0;\n    d = Math.floor(d / 16);\n    return (c === 'x' ? r : r & 0x7 | 0x8).toString(16);\n  });\n  return uuid;\n}\n\nfunction initOverrideCreateTransaction(db, wakeupObservers) {\n  return function overrideCreateTransaction(origFunc) {\n    return function (mode, storenames, dbschema, parent) {\n      if (db.dynamicallyOpened()) return origFunc.apply(this, arguments); // Don't observe dynamically opened databases.\n\n      var addChanges = false;\n\n      if (mode === 'readwrite' && storenames.some(function (storeName) {\n        return dbschema[storeName] && dbschema[storeName].observable;\n      })) {\n        // At least one included store is a observable store. Make sure to also include the _changes store.\n        addChanges = true;\n        storenames = storenames.slice(0); // Clone\n\n        if (storenames.indexOf(\"_changes\") === -1) storenames.push(\"_changes\"); // Otherwise, firefox will hang... (I've reported the bug to Mozilla@Bugzilla)\n      } // Call original db._createTransaction()\n\n\n      var trans = origFunc.call(this, mode, storenames, dbschema, parent); // If this transaction is bound to any observable table, make sure to add changes when transaction completes.\n\n      if (addChanges) {\n        trans._lastWrittenRevision = 0;\n        trans.on('complete', function () {\n          if (trans._lastWrittenRevision) {\n            // Changes were written in this transaction.\n            if (!parent) {\n              // This is root-level transaction, i.e. a physical commit has happened.\n              // Delay-trigger a wakeup call:\n              if (wakeupObservers.timeoutHandle) clearTimeout(wakeupObservers.timeoutHandle);\n              wakeupObservers.timeoutHandle = setTimeout(function () {\n                delete wakeupObservers.timeoutHandle;\n                wakeupObservers(trans._lastWrittenRevision);\n              }, 25);\n            } else {\n              // This is just a virtual commit of a sub transaction.\n              // Wait with waking up observers until root transaction has committed.\n              // Make sure to mark root transaction so that it will wakeup observers upon commit.\n              var rootTransaction = function findRootTransaction(trans) {\n                return trans.parent ? findRootTransaction(trans.parent) : trans;\n              }(parent);\n\n              rootTransaction._lastWrittenRevision = Math.max(trans._lastWrittenRevision, rootTransaction.lastWrittenRevision || 0);\n            }\n          }\n        }); // Derive \"source\" property from parent transaction by default\n\n        if (trans.parent && trans.parent.source) trans.source = trans.parent.source;\n      }\n\n      return trans;\n    };\n  };\n}\n\nfunction initWakeupObservers(db, Observable, localStorage) {\n  return function wakeupObservers(lastWrittenRevision) {\n    // Make sure Observable.latestRevision[db.name] is still below our value, now when some time has elapsed and other db instances in same window possibly could have made changes too.\n    if (Observable.latestRevision[db.name] < lastWrittenRevision) {\n      // Set the static property lastRevision[db.name] to the revision of the last written change.\n      Observable.latestRevision[db.name] = lastWrittenRevision; // Wakeup ourselves, and any other db instances on this window:\n\n      Dexie.ignoreTransaction(function () {\n        Observable.on('latestRevisionIncremented').fire(db.name, lastWrittenRevision);\n      }); // Observable.on.latestRevisionIncremented will only wakeup db's in current window.\n      // We need a storage event to wakeup other windwos.\n      // Since indexedDB lacks storage events, let's use the storage event from WebStorage just for\n      // the purpose to wakeup db instances in other windows.\n\n      if (localStorage) localStorage.setItem('Dexie.Observable/latestRevision/' + db.name, lastWrittenRevision); // In IE, this will also wakeup our own window. However, onLatestRevisionIncremented will work around this by only running once per revision id.\n    }\n  };\n} // Change Types\n\n\nvar CREATE = 1;\nvar UPDATE = 2;\nvar DELETE = 3;\n\nfunction initCreatingHook(db, table) {\n  return function creatingHook(primKey, obj, trans) {\n    /// <param name=\"trans\" type=\"db.Transaction\"></param>\n    var rv = undefined;\n\n    if (primKey === undefined && table.schema.primKey.uuid) {\n      primKey = rv = createUUID();\n\n      if (table.schema.primKey.keyPath) {\n        Dexie.setByKeyPath(obj, table.schema.primKey.keyPath, primKey);\n      }\n    }\n\n    var change = {\n      source: trans.source || null,\n      table: table.name,\n      key: primKey === undefined ? null : primKey,\n      type: CREATE,\n      obj: obj\n    };\n\n    var promise = db._changes.add(change).then(function (rev) {\n      trans._lastWrittenRevision = Math.max(trans._lastWrittenRevision, rev);\n      return rev;\n    }); // Wait for onsuccess so that we have the primKey if it is auto-incremented and update the change item if so.\n\n\n    this.onsuccess = function (resultKey) {\n      if (primKey != resultKey) promise._then(function () {\n        change.key = resultKey;\n\n        db._changes.put(change);\n      });\n    };\n\n    this.onerror = function () {\n      // If the main operation fails, make sure to regret the change\n      promise._then(function (rev) {\n        // Will only happen if app code catches the main operation error to prohibit transaction from aborting.\n        db._changes.delete(rev);\n      });\n    };\n\n    return rv;\n  };\n}\n\nfunction initUpdatingHook(db, tableName) {\n  return function updatingHook(mods, primKey, oldObj, trans) {\n    /// <param name=\"trans\" type=\"db.Transaction\"></param>\n    // mods may contain property paths with undefined as value if the property\n    // is being deleted. Since we cannot persist undefined we need to act\n    // like those changes is setting the value to null instead.\n    var modsWithoutUndefined = {}; // As of current Dexie version (1.0.3) hook may be called even if it wouldn't really change.\n    // Therefore we may do that kind of optimization here - to not add change entries if\n    // there's nothing to change.\n\n    var anythingChanged = false;\n    var newObj = Dexie.deepClone(oldObj);\n\n    for (var propPath in mods) {\n      var mod = mods[propPath];\n\n      if (typeof mod === 'undefined') {\n        Dexie.delByKeyPath(newObj, propPath);\n        modsWithoutUndefined[propPath] = null; // Null is as close we could come to deleting a property when not allowing undefined.\n\n        anythingChanged = true;\n      } else {\n        var currentValue = Dexie.getByKeyPath(oldObj, propPath);\n\n        if (mod !== currentValue && JSON.stringify(mod) !== JSON.stringify(currentValue)) {\n          Dexie.setByKeyPath(newObj, propPath, mod);\n          modsWithoutUndefined[propPath] = mod;\n          anythingChanged = true;\n        }\n      }\n    }\n\n    if (anythingChanged) {\n      var change = {\n        source: trans.source || null,\n        table: tableName,\n        key: primKey,\n        type: UPDATE,\n        mods: modsWithoutUndefined,\n        oldObj: oldObj,\n        obj: newObj\n      };\n\n      var promise = db._changes.add(change); // Just so we get the correct revision order of the update...\n\n\n      this.onsuccess = function () {\n        promise._then(function (rev) {\n          trans._lastWrittenRevision = Math.max(trans._lastWrittenRevision, rev);\n        });\n      };\n\n      this.onerror = function () {\n        // If the main operation fails, make sure to regret the change.\n        promise._then(function (rev) {\n          // Will only happen if app code catches the main operation error to prohibit transaction from aborting.\n          db._changes.delete(rev);\n        });\n      };\n    }\n  };\n}\n\nfunction initDeletingHook(db, tableName) {\n  return function deletingHook(primKey, obj, trans) {\n    /// <param name=\"trans\" type=\"db.Transaction\"></param>\n    var promise = db._changes.add({\n      source: trans.source || null,\n      table: tableName,\n      key: primKey,\n      type: DELETE,\n      oldObj: obj\n    }).then(function (rev) {\n      trans._lastWrittenRevision = Math.max(trans._lastWrittenRevision, rev);\n      return rev;\n    }).catch(function (e) {\n      console.log(obj);\n      console.log(e.stack);\n    });\n\n    this.onerror = function () {\n      // If the main operation fails, make sure to regret the change.\n      // Using _then because if promise is already fullfilled, the standard then() would\n      // do setTimeout() and we would loose the transaction.\n      promise._then(function (rev) {\n        // Will only happen if app code catches the main operation error to prohibit transaction from aborting.\n        db._changes.delete(rev);\n      });\n    };\n  };\n}\n\nfunction initCrudMonitor(db) {\n  //\n  // The Creating/Updating/Deleting hook will make sure any change is stored to the changes table\n  //\n  return function crudMonitor(table) {\n    /// <param name=\"table\" type=\"db.Table\"></param>\n    if (table.hook._observing) return;\n    table.hook._observing = true;\n    var tableName = table.name;\n    table.hook('creating').subscribe(initCreatingHook(db, table));\n    table.hook('updating').subscribe(initUpdatingHook(db, tableName));\n    table.hook('deleting').subscribe(initDeletingHook(db, tableName));\n  };\n}\n\nfunction initOnStorage(Observable) {\n  return function onStorage(event) {\n    // We use the onstorage event to trigger onLatestRevisionIncremented since we will wake up when other windows modify the DB as well!\n    if (event.key && event.key.indexOf(\"Dexie.Observable/\") === 0) {\n      // For example \"Dexie.Observable/latestRevision/FriendsDB\"\n      var parts = event.key.split('/');\n      var prop = parts[1];\n      var dbname = parts[2];\n\n      if (prop === 'latestRevision') {\n        var rev = parseInt(event.newValue, 10);\n\n        if (!isNaN(rev) && rev > Observable.latestRevision[dbname]) {\n          Observable.latestRevision[dbname] = rev;\n          Dexie.ignoreTransaction(function () {\n            Observable.on('latestRevisionIncremented').fire(dbname, rev);\n          });\n        }\n      } else if (prop.indexOf(\"deadnode:\") === 0) {\n        var nodeID = parseInt(prop.split(':')[1], 10);\n\n        if (event.newValue) {\n          Observable.on.suicideNurseCall.fire(dbname, nodeID);\n        }\n      } else if (prop === 'intercomm') {\n        if (event.newValue) {\n          Observable.on.intercomm.fire(dbname);\n        }\n      }\n    }\n  };\n}\n\nfunction initOverrideOpen(db, SyncNode, crudMonitor) {\n  return function overrideOpen(origOpen) {\n    return function () {\n      //\n      // Make sure to subscribe to \"creating\", \"updating\" and \"deleting\" hooks for all observable tables that were created in the stores() method.\n      //\n      Object.keys(db._allTables).forEach(function (tableName) {\n        var table = db._allTables[tableName];\n\n        if (table.schema.observable) {\n          crudMonitor(table);\n        }\n\n        if (table.name === \"_syncNodes\") {\n          table.mapToClass(SyncNode);\n        }\n      });\n      return origOpen.apply(this, arguments);\n    };\n  };\n}\n\nvar Promise = Dexie.Promise;\n\nfunction initIntercomm(db, Observable, SyncNode, mySyncNode, localStorage) {\n  //\n  // Intercommunication between nodes\n  //\n  // Enable inter-process communication between browser windows using localStorage storage event (is registered in Dexie.Observable)\n  var requestsWaitingForReply = {};\n  /**\n   * @param {string} type Type of message\n   * @param message Message to send\n   * @param {number} destinationNode ID of destination node\n   * @param {{wantReply: boolean, isFailure: boolean, requestId: number}} options If {wantReply: true}, the returned promise will complete with the reply from remote. Otherwise it will complete when message has been successfully sent.</param>\n   */\n\n  db.observable.sendMessage = function (type, message, destinationNode, options) {\n    /// <param name=\"type\" type=\"String\">Type of message</param>\n    /// <param name=\"message\">Message to send</param>\n    /// <param name=\"destinationNode\" type=\"Number\">ID of destination node</param>\n    /// <param name=\"options\" type=\"Object\" optional=\"true\">{wantReply: Boolean, isFailure: Boolean, requestId: Number}. If wantReply, the returned promise will complete with the reply from remote. Otherwise it will complete when message has been successfully sent.</param>\n    options = options || {};\n    if (!mySyncNode.node) return options.wantReply ? Promise.reject(new Dexie.DatabaseClosedError()) : Promise.resolve(); // If caller doesn't want a reply, it won't catch errors either.\n\n    var msg = {\n      message: message,\n      destinationNode: destinationNode,\n      sender: mySyncNode.node.id,\n      type: type\n    };\n    Dexie.extend(msg, options); // wantReply: wantReply, success: !isFailure, requestId: ...\n\n    return Dexie.ignoreTransaction(function () {\n      var tables = [\"_intercomm\"];\n      if (options.wantReply) tables.push(\"_syncNodes\"); // If caller wants a reply, include \"_syncNodes\" in transaction to check that there's a receiver there. Otherwise, new master will get it.\n\n      var promise = db.transaction('rw', tables, function () {\n        if (options.wantReply) {\n          // Check that there is a receiver there to take the request.\n          return db._syncNodes.where('id').equals(destinationNode).count(function (receiverAlive) {\n            if (receiverAlive) return db._intercomm.add(msg);else // If we couldn't find a node -> send to master\n              return db._syncNodes.where('isMaster').above(0).first(function (masterNode) {\n                msg.destinationNode = masterNode.id;\n                return db._intercomm.add(msg);\n              });\n          });\n        } else {\n          // If caller doesn't need a response, we don't have to make sure that it gets one.\n          return db._intercomm.add(msg);\n        }\n      }).then(function (messageId) {\n        var rv = null;\n\n        if (options.wantReply) {\n          rv = new Promise(function (resolve, reject) {\n            requestsWaitingForReply[messageId.toString()] = {\n              resolve: resolve,\n              reject: reject\n            };\n          });\n        }\n\n        if (localStorage) {\n          localStorage.setItem(\"Dexie.Observable/intercomm/\" + db.name, messageId.toString());\n        }\n\n        Observable.on.intercomm.fire(db.name);\n        return rv;\n      });\n\n      if (!options.wantReply) {\n        promise.catch(function () {});\n        return;\n      } else {\n        // Forward rejection to caller if it waits for reply.\n        return promise;\n      }\n    });\n  }; // Send a message to all local _syncNodes\n\n\n  db.observable.broadcastMessage = function (type, message, bIncludeSelf) {\n    if (!mySyncNode.node) return;\n    var mySyncNodeId = mySyncNode.node.id;\n    Dexie.ignoreTransaction(function () {\n      db._syncNodes.toArray(function (nodes) {\n        return Promise.all(nodes.filter(function (node) {\n          return node.type === 'local' && (bIncludeSelf || node.id !== mySyncNodeId);\n        }).map(function (node) {\n          return db.observable.sendMessage(type, message, node.id);\n        }));\n      }).catch(function () {});\n    });\n  };\n\n  function consumeIntercommMessages() {\n    // Check if we got messages:\n    if (!mySyncNode.node) return Promise.reject(new Dexie.DatabaseClosedError());\n    return Dexie.ignoreTransaction(function () {\n      return db.transaction('rw', '_intercomm', function () {\n        return db._intercomm.where({\n          destinationNode: mySyncNode.node.id\n        }).toArray(function (messages) {\n          messages.forEach(function (msg) {\n            return consumeMessage(msg);\n          });\n          return db._intercomm.where('id').anyOf(messages.map(function (msg) {\n            return msg.id;\n          })).delete();\n        });\n      });\n    });\n  }\n\n  function consumeMessage(msg) {\n    if (msg.type === 'response') {\n      // This is a response. Lookup pending request and fulfill its promise.\n      var request = requestsWaitingForReply[msg.requestId.toString()];\n\n      if (request) {\n        if (msg.isFailure) {\n          request.reject(msg.message.error);\n        } else {\n          request.resolve(msg.message.result);\n        }\n\n        delete requestsWaitingForReply[msg.requestId.toString()];\n      }\n    } else {\n      // This is a message or request. Fire the event and add an API for the subscriber to use if reply is requested\n      msg.resolve = function (result) {\n        db.observable.sendMessage('response', {\n          result: result\n        }, msg.sender, {\n          requestId: msg.id\n        });\n      };\n\n      msg.reject = function (error) {\n        db.observable.sendMessage('response', {\n          error: error.toString()\n        }, msg.sender, {\n          isFailure: true,\n          requestId: msg.id\n        });\n      };\n\n      db.on.message.fire(msg);\n    }\n  } // Listener for 'intercomm' events\n  // Gets fired when we get a 'storage' event from local storage or when sendMessage is called\n  // 'storage' is used to communicate between tabs (sendMessage changes the localStorage to trigger the event)\n  // sendMessage is used to communicate in the same tab and to trigger a storage event\n\n\n  function onIntercomm(dbname) {\n    // When storage event trigger us to check\n    if (dbname === db.name) {\n      consumeIntercommMessages().catch('DatabaseClosedError', function () {});\n    }\n  }\n\n  return {\n    onIntercomm: onIntercomm,\n    consumeIntercommMessages: consumeIntercommMessages\n  };\n}\n\nfunction overrideParseStoresSpec(origFunc) {\n  return function (stores, dbSchema) {\n    // Create the _changes and _syncNodes tables\n    stores[\"_changes\"] = \"++rev\";\n    stores[\"_syncNodes\"] = \"++id,myRevision,lastHeartBeat,&url,isMaster,type,status\";\n    stores[\"_intercomm\"] = \"++id,destinationNode\";\n    stores[\"_uncommittedChanges\"] = \"++id,node\"; // For remote syncing when server returns a partial result.\n    // Call default implementation. Will populate the dbSchema structures.\n\n    origFunc.call(this, stores, dbSchema); // Allow UUID primary keys using $$ prefix on primary key or indexes\n\n    Object.keys(dbSchema).forEach(function (tableName) {\n      var schema = dbSchema[tableName];\n\n      if (schema.primKey.name.indexOf('$$') === 0) {\n        schema.primKey.uuid = true;\n        schema.primKey.name = schema.primKey.name.substr(2);\n        schema.primKey.keyPath = schema.primKey.keyPath.substr(2);\n      }\n    }); // Now mark all observable tables\n\n    Object.keys(dbSchema).forEach(function (tableName) {\n      // Marked observable tables with \"observable\" in their TableSchema.\n      if (tableName.indexOf('_') !== 0 && tableName.indexOf('$') !== 0) {\n        dbSchema[tableName].observable = true;\n      }\n    });\n  };\n}\n\nfunction deleteOldChanges(db) {\n  // This is a background job and should never be done within\n  // a caller's transaction. Use Dexie.ignoreTransaction() to ensure that.\n  // We should not return the Promise but catch it ourselves instead.\n  // To prohibit starving the database we want to lock transactions as short as possible\n  // and since we're not in a hurry, we could do this job in chunks and reschedule a\n  // continuation every 500 ms.\n  var CHUNK_SIZE = 100;\n  Dexie.ignoreTransaction(function () {\n    return db._syncNodes.orderBy(\"myRevision\").first(function (oldestNode) {\n      return db._changes.where(\"rev\").below(oldestNode.myRevision).limit(CHUNK_SIZE).primaryKeys();\n    }).then(function (keysToDelete) {\n      if (keysToDelete.length === 0) return; // Done.\n\n      return db._changes.bulkDelete(keysToDelete).then(function () {\n        // If not done garbage collecting, reschedule a continuation of it until done.\n        if (keysToDelete.length === CHUNK_SIZE) {\n          // Limit reached. Changes are there are more job to do. Schedule again:\n          setTimeout(function () {\n            return db.isOpen() && deleteOldChanges(db);\n          }, 500);\n        }\n      });\n    });\n  }).catch(function () {// The operation is not crucial. A failure could almost only be due to that database has been closed.\n    // No need to log this.\n  });\n}\n/* ==========================================================================\n *                           dexie-observable.js\n * ==========================================================================\n *\n * Dexie addon for observing database changes not just on local db instance\n * but also on other instances, tabs and windows.\n *\n * Comprises a base framework for dexie-syncable.js\n *\n * By David Fahlander, david.fahlander@gmail.com,\n *    Nikolas Poniros, https://github.com/nponiros\n *\n * ==========================================================================\n *\n * Version {version}, {date}\n *\n * http://dexie.org\n *\n * Apache License Version 2.0, January 2004, http://www.apache.org/licenses/\n *\n */\n\n\nvar global = self;\n/** class DatabaseChange\n    *\n    *  Object contained by the _changes table.\n    */\n\nvar DatabaseChange = Dexie.defineClass({\n  rev: Number,\n  source: String,\n  table: String,\n  key: Object,\n  type: Number,\n  obj: Object,\n  mods: Object,\n  oldObj: Object // DELETE: oldObj contains the object deleted. UPDATE: oldObj contains the old object before updates applied.\n\n}); // Import some usable helper functions\n\nvar override = Dexie.override;\nvar Promise$1 = Dexie.Promise;\nvar browserIsShuttingDown = false;\n\nfunction Observable(db) {\n  /// <summary>\n  ///   Extension to Dexie providing Syncronization capabilities to Dexie.\n  /// </summary>\n  /// <param name=\"db\" type=\"Dexie\"></param>\n  var NODE_TIMEOUT = 20000,\n      // 20 seconds before local db instances are timed out. This is so that old changes can be deleted when not needed and to garbage collect old _syncNodes objects.\n  HIBERNATE_GRACE_PERIOD = 20000,\n      // 20 seconds\n  // LOCAL_POLL: The time to wait before polling local db for changes and cleaning up old nodes. \n  // Polling for changes is a fallback only needed in certain circomstances (when the onstorage event doesnt reach all listeners - when different browser windows doesnt share the same process)\n  LOCAL_POLL = 500,\n      // 500 ms. In real-world there will be this value + the time it takes to poll(). A small value is needed in Workers where we cannot rely on storage event.\n  HEARTBEAT_INTERVAL = NODE_TIMEOUT - 5000;\n  var localStorage = Observable.localStorageImpl;\n  /** class SyncNode\n      *\n      * Object contained in the _syncNodes table.\n      */\n\n  var SyncNode = Dexie.defineClass({\n    //id: Number,\n    myRevision: Number,\n    type: String,\n    lastHeartBeat: Number,\n    deleteTimeStamp: Number,\n    url: String,\n    isMaster: Number,\n    // Below properties should be extended in Dexie.Syncable. Not here. They apply to remote nodes only (type == \"remote\"):\n    syncProtocol: String,\n    syncContext: null,\n    syncOptions: Object,\n    connected: false,\n    status: Number,\n    appliedRemoteRevision: null,\n    remoteBaseRevisions: [{\n      local: Number,\n      remote: null\n    }],\n    dbUploadState: {\n      tablesToUpload: [String],\n      currentTable: String,\n      currentKey: null,\n      localBaseRevision: Number\n    }\n  });\n  db.observable = {};\n  db.observable.SyncNode = SyncNode;\n  var wakeupObservers = initWakeupObservers(db, Observable, localStorage);\n  var overrideCreateTransaction = initOverrideCreateTransaction(db, wakeupObservers);\n  var crudMonitor = initCrudMonitor(db);\n  var overrideOpen = initOverrideOpen(db, SyncNode, crudMonitor);\n  var mySyncNode = {\n    node: null\n  };\n  var intercomm = initIntercomm(db, Observable, SyncNode, mySyncNode, localStorage);\n  var onIntercomm = intercomm.onIntercomm;\n  var consumeIntercommMessages = intercomm.consumeIntercommMessages; // Allow other addons to access the local sync node. May be needed by Dexie.Syncable.\n\n  Object.defineProperty(db, \"_localSyncNode\", {\n    get: function () {\n      return mySyncNode.node;\n    }\n  });\n  var pollHandle = null,\n      heartbeatHandle = null;\n\n  if (Dexie.fake) {\n    // This code will never run.\n    // It's here just to enable auto-complete in visual studio - helps a lot when writing code.\n    db.version(1).stores({\n      _syncNodes: \"++id,myRevision,lastHeartBeat\",\n      _changes: \"++rev\",\n      _intercomm: \"++id,destinationNode\",\n      _uncommittedChanges: \"++id,node\"\n    });\n\n    db._syncNodes.mapToClass(SyncNode);\n\n    db._changes.mapToClass(DatabaseChange);\n\n    mySyncNode.node = new SyncNode({\n      myRevision: 0,\n      type: \"local\",\n      lastHeartBeat: Date.now(),\n      deleteTimeStamp: null\n    });\n  } //\n  // Override parsing the stores to add \"_changes\" and \"_syncNodes\" tables.\n  // It also adds UUID support for the primary key and sets tables as observable tables.\n  //\n\n\n  db.Version.prototype._parseStoresSpec = override(db.Version.prototype._parseStoresSpec, overrideParseStoresSpec); // changes event on db:\n\n  db.on.addEventType({\n    changes: 'asap',\n    cleanup: [promisableChain, nop],\n    message: 'asap'\n  }); //\n  // Override transaction creation to always include the \"_changes\" store when any observable store is involved.\n  //\n\n  db._createTransaction = override(db._createTransaction, overrideCreateTransaction); // If Observable.latestRevsion[db.name] is undefined, set it to 0 so that comparing against it always works.\n  // You might think that it will always be undefined before this call, but in case another Dexie instance in the same\n  // window with the same database name has been created already, this static property will already be set correctly.\n\n  Observable.latestRevision[db.name] = Observable.latestRevision[db.name] || 0; //\n  // Override open to setup hooks for db changes and map the _syncNodes table to class\n  //\n\n  db.open = override(db.open, overrideOpen);\n  db.close = override(db.close, function (origClose) {\n    return function () {\n      if (db.dynamicallyOpened()) return origClose.apply(this, arguments); // Don't observe dynamically opened databases.\n      // Teardown our framework.\n\n      if (wakeupObservers.timeoutHandle) {\n        clearTimeout(wakeupObservers.timeoutHandle);\n        delete wakeupObservers.timeoutHandle;\n      }\n\n      Observable.on('latestRevisionIncremented').unsubscribe(onLatestRevisionIncremented);\n      Observable.on('suicideNurseCall').unsubscribe(onSuicide);\n      Observable.on('intercomm').unsubscribe(onIntercomm);\n      Observable.on('beforeunload').unsubscribe(onBeforeUnload); // Inform other db instances in same window that we are dying:\n\n      if (mySyncNode.node && mySyncNode.node.id) {\n        Observable.on.suicideNurseCall.fire(db.name, mySyncNode.node.id); // Inform other windows as well:\n\n        if (localStorage) {\n          localStorage.setItem('Dexie.Observable/deadnode:' + mySyncNode.node.id.toString() + '/' + db.name, \"dead\"); // In IE, this will also wakeup our own window. cleanup() may trigger twice per other db instance. But that doesnt to anything.\n        }\n\n        mySyncNode.node.deleteTimeStamp = 1; // One millisecond after 1970. Makes it occur in the past but still keeps it truthy.\n\n        mySyncNode.node.lastHeartBeat = 0;\n\n        db._syncNodes.put(mySyncNode.node); // This async operation may be cancelled since the browser is closing down now.\n\n\n        mySyncNode.node = null;\n      }\n\n      if (pollHandle) clearTimeout(pollHandle);\n      pollHandle = null;\n      if (heartbeatHandle) clearTimeout(heartbeatHandle);\n      heartbeatHandle = null;\n      return origClose.apply(this, arguments);\n    };\n  }); // Override Dexie.delete() in order to delete Observable.latestRevision[db.name].\n\n  db.delete = override(db.delete, function (origDelete) {\n    return function () {\n      return origDelete.apply(this, arguments).then(function (result) {\n        // Reset Observable.latestRevision[db.name]\n        Observable.latestRevision[db.name] = 0;\n        return result;\n      });\n    };\n  }); // When db opens, make sure to start monitor any changes before other db operations will start.\n\n  db.on(\"ready\", function startObserving() {\n    if (db.dynamicallyOpened()) return db; // Don't observe dynamically opened databases.\n\n    return db.table(\"_changes\").orderBy(\"rev\").last(function (lastChange) {\n      // Since startObserving() is called before database open() method, this will be the first database operation enqueued to db.\n      // Therefore we know that the retrieved value will be This query will\n      var latestRevision = lastChange ? lastChange.rev : 0;\n      mySyncNode.node = new SyncNode({\n        myRevision: latestRevision,\n        type: \"local\",\n        lastHeartBeat: Date.now(),\n        deleteTimeStamp: null,\n        isMaster: 0\n      });\n\n      if (Observable.latestRevision[db.name] < latestRevision) {\n        // Side track . For correctness whenever setting Observable.latestRevision[db.name] we must make sure the event is fired if increased:\n        // There are other db instances in same window that hasnt yet been informed about a new revision\n        Observable.latestRevision[db.name] = latestRevision;\n        Dexie.ignoreTransaction(function () {\n          Observable.on.latestRevisionIncremented.fire(latestRevision);\n        });\n      } // Add new sync node or if this is a reopening of the database after a close() call, update it.\n\n\n      return db.transaction('rw', '_syncNodes', function () {\n        return db._syncNodes.where('isMaster').equals(1).first(function (currentMaster) {\n          if (!currentMaster) {\n            // There's no master. We must be the master\n            mySyncNode.node.isMaster = 1;\n          } else if (currentMaster.lastHeartBeat < Date.now() - NODE_TIMEOUT) {\n            // Master have been inactive for too long\n            // Take over mastership\n            mySyncNode.node.isMaster = 1;\n            currentMaster.isMaster = 0;\n            return db._syncNodes.put(currentMaster);\n          }\n        }).then(function () {\n          // Add our node to DB and start subscribing to events\n          return db._syncNodes.add(mySyncNode.node).then(function () {\n            Observable.on('latestRevisionIncremented', onLatestRevisionIncremented); // Wakeup when a new revision is available.\n\n            Observable.on('beforeunload', onBeforeUnload);\n            Observable.on('suicideNurseCall', onSuicide);\n            Observable.on('intercomm', onIntercomm); // Start polling for changes and do cleanups:\n\n            pollHandle = setTimeout(poll, LOCAL_POLL); // Start heartbeat\n\n            heartbeatHandle = setTimeout(heartbeat, HEARTBEAT_INTERVAL);\n          });\n        });\n      }).then(function () {\n        cleanup();\n      });\n    });\n  }, true); // True means the on(ready) event will survive a db reopening (db.close() / db.open()).\n\n  var handledRevision = 0;\n\n  function onLatestRevisionIncremented(dbname, latestRevision) {\n    if (dbname === db.name) {\n      if (handledRevision >= latestRevision) return; // Make sure to only run once per revision. (Workaround for IE triggering storage event on same window)\n\n      handledRevision = latestRevision;\n      Dexie.vip(function () {\n        readChanges(latestRevision).catch('DatabaseClosedError', function () {// Handle database closed error gracefully while reading changes.\n          // Don't trigger 'unhandledrejection'.\n          // Even though we intercept the close() method, it might be called when in the middle of\n          // reading changes and then that flow will cancel with DatabaseClosedError.\n        });\n      });\n    }\n  }\n\n  function readChanges(latestRevision, recursion, wasPartial) {\n    // Whenever changes are read, fire db.on(\"changes\") with the array of changes. Eventually, limit the array to 1000 entries or so (an entire database is\n    // downloaded from server AFTER we are initiated. For example, if first sync call fails, then after a while we get reconnected. However, that scenario\n    // should be handled in case database is totally empty we should fail if sync is not available)\n    if (!recursion && readChanges.ongoingOperation) {\n      // We are already reading changes. Prohibit a parallell execution of this which would lead to duplicate trigging of 'changes' event.\n      // Instead, the callback in toArray() will always check Observable.latestRevision[db.name] to see if it has changed and if so, re-launch readChanges().\n      // The caller should get the Promise instance from the ongoing operation so that the then() method will resolve when operation is finished.\n      return readChanges.ongoingOperation;\n    }\n\n    var partial = false;\n    var ourSyncNode = mySyncNode.node; // Because mySyncNode can suddenly be set to null on database close, and worse, can be set to a new value if database is reopened.\n\n    if (!ourSyncNode) {\n      return Promise$1.reject(new Dexie.DatabaseClosedError());\n    }\n\n    var LIMIT = 1000;\n\n    var promise = db._changes.where(\"rev\").above(ourSyncNode.myRevision).limit(LIMIT).toArray(function (changes) {\n      if (changes.length > 0) {\n        var lastChange = changes[changes.length - 1];\n        partial = changes.length === LIMIT;\n        db.on('changes').fire(changes, partial);\n        ourSyncNode.myRevision = lastChange.rev;\n      } else if (wasPartial) {\n        // No more changes, BUT since we have triggered on('changes') with partial = true,\n        // we HAVE TO trigger changes again with empty list and partial = false\n        db.on('changes').fire([], false);\n      }\n\n      var ourNodeStillExists = false;\n      return db._syncNodes.where(':id').equals(ourSyncNode.id).modify(function (syncNode) {\n        ourNodeStillExists = true;\n        syncNode.lastHeartBeat = Date.now(); // Update heart beat (not nescessary, but why not!)\n\n        syncNode.deleteTimeStamp = null; // Reset \"deleteTimeStamp\" flag if it was there.\n\n        syncNode.myRevision = Math.max(syncNode.myRevision, ourSyncNode.myRevision);\n      }).then(function () {\n        return ourNodeStillExists;\n      });\n    }).then(function (ourNodeStillExists) {\n      if (!ourNodeStillExists) {\n        // My node has been deleted. We must have been lazy and got removed by another node.\n        if (browserIsShuttingDown) {\n          throw new Error(\"Browser is shutting down\");\n        } else {\n          db.close();\n          console.error(\"Out of sync\"); // TODO: What to do? Reload the page?\n\n          if (global.location) global.location.reload(true);\n          throw new Error(\"Out of sync\"); // Will make current promise reject\n        }\n      } // Check if more changes have come since we started reading changes in the first place. If so, relaunch readChanges and let the ongoing promise not\n      // resolve until all changes have been read.\n\n\n      if (partial || Observable.latestRevision[db.name] > ourSyncNode.myRevision) {\n        // Either there were more than 1000 changes or additional changes where added while we were reading these changes,\n        // In either case, call readChanges() again until we're done.\n        return readChanges(Observable.latestRevision[db.name], (recursion || 0) + 1, partial);\n      }\n    }).finally(function () {\n      delete readChanges.ongoingOperation;\n    });\n\n    if (!recursion) {\n      readChanges.ongoingOperation = promise;\n    }\n\n    return promise;\n  }\n  /**\n   * The reason we need heartbeat in parallell with poll() is due to the risk of long-running\n   * transactions while syncing changes from server to client in Dexie.Syncable. That transaction will\n   * include _changes (which will block readChanges()) but not _syncNodes. So this heartbeat will go on\n   * during that changes are being applied and update our lastHeartBeat property while poll() is waiting.\n   * When cleanup() (who also is blocked by the sync) wakes up, it won't kill the master node because this\n   * heartbeat job will have updated the master node's heartbeat during the long-running sync transaction.\n   *\n   * If we did not have this heartbeat, and a server send lots of changes that took more than NODE_TIMEOUT\n   * (20 seconds), another node waking up after the sync would kill the master node and take over because\n   * it would believe it was dead.\n   */\n\n\n  function heartbeat() {\n    heartbeatHandle = null;\n    var currentInstance = mySyncNode.node && mySyncNode.node.id;\n    if (!currentInstance) return;\n    db.transaction('rw!', db._syncNodes, function () {\n      db._syncNodes.where({\n        id: currentInstance\n      }).first(function (ourSyncNode) {\n        if (!ourSyncNode) {\n          // We do not exist anymore. Call db.close() to teardown polls etc.\n          if (db.isOpen()) db.close();\n          return;\n        }\n\n        ourSyncNode.lastHeartBeat = Date.now();\n        ourSyncNode.deleteTimeStamp = null; // Reset \"deleteTimeStamp\" flag if it was there.\n\n        return db._syncNodes.put(ourSyncNode);\n      });\n    }).catch('DatabaseClosedError', function () {// Ignore silently\n    }).finally(function () {\n      if (mySyncNode.node && mySyncNode.node.id === currentInstance && db.isOpen()) {\n        heartbeatHandle = setTimeout(heartbeat, HEARTBEAT_INTERVAL);\n      }\n    });\n  }\n\n  function poll() {\n    pollHandle = null;\n    var currentInstance = mySyncNode.node && mySyncNode.node.id;\n    if (!currentInstance) return;\n    Dexie.vip(function () {\n      readChanges(Observable.latestRevision[db.name]).then(cleanup).then(consumeIntercommMessages).catch('DatabaseClosedError', function () {// Handle database closed error gracefully while reading changes.\n        // Don't trigger 'unhandledrejection'.\n        // Even though we intercept the close() method, it might be called when in the middle of\n        // reading changes and then that flow will cancel with DatabaseClosedError.\n      }).finally(function () {\n        // Poll again in given interval:\n        if (mySyncNode.node && mySyncNode.node.id === currentInstance && db.isOpen()) {\n          pollHandle = setTimeout(poll, LOCAL_POLL);\n        }\n      });\n    });\n  }\n\n  function cleanup() {\n    var ourSyncNode = mySyncNode.node;\n    if (!ourSyncNode) return Promise$1.reject(new Dexie.DatabaseClosedError());\n    return db.transaction('rw', '_syncNodes', '_changes', '_intercomm', function () {\n      // Cleanup dead local nodes that has no heartbeat for over a minute\n      // Dont do the following:\n      //nodes.where(\"lastHeartBeat\").below(Date.now() - NODE_TIMEOUT).and(function (node) { return node.type == \"local\"; }).delete();\n      // Because client may have been in hybernate mode and recently woken up. That would lead to deletion of all nodes.\n      // Instead, we should mark any old nodes for deletion in a minute or so. If they still dont wakeup after that minute we could consider them dead.\n      var weBecameMaster = false;\n\n      db._syncNodes.where(\"lastHeartBeat\").below(Date.now() - NODE_TIMEOUT).filter(function (node) {\n        return node.type === 'local';\n      }).modify(function (node) {\n        if (node.deleteTimeStamp && node.deleteTimeStamp < Date.now()) {\n          // Delete the node.\n          delete this.value; // Cleanup localStorage \"deadnode:\" entry for this node (localStorage API was used to wakeup other windows (onstorage event) - an event type missing in indexedDB.)\n\n          if (localStorage) {\n            localStorage.removeItem('Dexie.Observable/deadnode:' + node.id + '/' + db.name);\n          } // Check if we are deleting a master node\n\n\n          if (node.isMaster) {\n            // The node we are deleting is master. We must take over that role.\n            // OK to call nodes.update(). No need to call Dexie.vip() because nodes is opened in existing transaction!\n            db._syncNodes.update(ourSyncNode, {\n              isMaster: 1\n            });\n\n            weBecameMaster = true;\n          } // Cleanup intercomm messages destinated to the node being deleted.\n          // Those that waits for reply should be redirected to us.\n\n\n          db._intercomm.where({\n            destinationNode: node.id\n          }).modify(function (msg) {\n            if (msg.wantReply) msg.destinationNode = ourSyncNode.id;else // Delete the message from DB and if someone is waiting for reply, let ourselved answer the request.\n              delete this.value;\n          });\n        } else if (!node.deleteTimeStamp) {\n          // Mark the node for deletion\n          node.deleteTimeStamp = Date.now() + HIBERNATE_GRACE_PERIOD;\n        }\n      }).then(function () {\n        // Cleanup old revisions that no node is interested of.\n        Observable.deleteOldChanges(db);\n        return db.on(\"cleanup\").fire(weBecameMaster);\n      });\n    });\n  }\n\n  function onBeforeUnload() {\n    // Mark our own sync node for deletion.\n    if (!mySyncNode.node) return;\n    browserIsShuttingDown = true;\n    mySyncNode.node.deleteTimeStamp = 1; // One millisecond after 1970. Makes it occur in the past but still keeps it truthy.\n\n    mySyncNode.node.lastHeartBeat = 0;\n\n    db._syncNodes.put(mySyncNode.node); // This async operation may be cancelled since the browser is closing down now.\n\n\n    Observable.wereTheOneDying = true; // If other nodes in same window wakes up by this call, make sure they dont start taking over mastership and stuff...\n    // Inform other windows that we're gone, so that they may take over our role if needed. Setting localStorage item below will trigger Observable.onStorage, which will trigger onSuicie() below:\n\n    if (localStorage) {\n      localStorage.setItem('Dexie.Observable/deadnode:' + mySyncNode.node.id.toString() + '/' + db.name, \"dead\"); // In IE, this will also wakeup our own window. However, that is doublechecked in nursecall subscriber below.\n    }\n  }\n\n  function onSuicide(dbname, nodeID) {\n    if (dbname === db.name && !Observable.wereTheOneDying) {\n      // Make sure it's dead indeed. Second bullet. Why? Because it has marked itself for deletion in the onbeforeunload event, which is fired just before window dies.\n      // It's own call to put() may have been cancelled.\n      // Note also that in IE, this event may be called twice, but that doesnt harm!\n      Dexie.vip(function () {\n        db._syncNodes.update(nodeID, {\n          deleteTimeStamp: 1,\n          lastHeartBeat: 0\n        }).then(cleanup);\n      });\n    }\n  }\n} //\n// Static properties and methods\n// \n\n\nObservable.latestRevision = {}; // Latest revision PER DATABASE. Example: Observable.latestRevision.FriendsDB = 37;\n\nObservable.on = Dexie.Events(null, \"latestRevisionIncremented\", \"suicideNurseCall\", \"intercomm\", \"beforeunload\"); // fire(dbname, value);\n\nObservable.createUUID = createUUID;\nObservable.deleteOldChanges = deleteOldChanges;\nObservable._onStorage = initOnStorage(Observable);\n\nObservable._onBeforeUnload = function () {\n  Observable.on.beforeunload.fire();\n};\n\ntry {\n  Observable.localStorageImpl = global.localStorage;\n} catch (ex) {} //\n// Map window events to static events in Dexie.Observable:\n//\n\n\nif (global.addEventListener) {\n  global.addEventListener(\"storage\", Observable._onStorage);\n  global.addEventListener(\"beforeunload\", Observable._onBeforeUnload);\n} // Register addon:\n\n\nDexie.Observable = Observable;\nDexie.addons.push(Observable);\nexport default Observable;","map":{"version":3,"sources":["../src/utils.js","../src/override-create-transaction.js","../src/wakeup-observers.js","../src/change_types.js","../src/hooks/creating.js","../src/hooks/updating.js","../src/hooks/deleting.js","../src/hooks/crud-monitor.js","../src/on-storage.js","../src/override-open.js","../src/intercomm.js","../src/override-parse-stores-spec.js","../src/delete-old-changes.js","../src/Dexie.Observable.js"],"names":["Promise"],"mappings":"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","sourcesContent":["export function nop() {}\n\nexport function promisableChain(f1, f2) {\n  if (f1 === nop) return f2;\n  return function() {\n    var res = f1.apply(this, arguments);\n    if (res && typeof res.then === 'function') {\n      var thiz = this, args = arguments;\n      return res.then(function() {\n        return f2.apply(thiz, args);\n      });\n    }\n    return f2.apply(this, arguments);\n  };\n}\n\nexport function createUUID() {\n  // Decent solution from http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript\n  var d = Date.now();\n  var uuid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {\n    var r = (d + Math.random() * 16) % 16 | 0;\n    d = Math.floor(d / 16);\n    return (c === 'x' ? r : (r & 0x7 | 0x8)).toString(16);\n  });\n  return uuid;\n}\n","export default function initOverrideCreateTransaction(db, wakeupObservers) {\n  return function overrideCreateTransaction(origFunc) {\n    return function (mode, storenames, dbschema, parent) {\n      if (db.dynamicallyOpened()) return origFunc.apply(this, arguments); // Don't observe dynamically opened databases.\n      var addChanges = false;\n      if (mode === 'readwrite' && storenames.some(function (storeName) {\n            return dbschema[storeName] && dbschema[storeName].observable;\n          })) {\n        // At least one included store is a observable store. Make sure to also include the _changes store.\n        addChanges = true;\n        storenames = storenames.slice(0); // Clone\n        if (storenames.indexOf(\"_changes\") === -1)\n          storenames.push(\"_changes\"); // Otherwise, firefox will hang... (I've reported the bug to Mozilla@Bugzilla)\n      }\n      // Call original db._createTransaction()\n      var trans = origFunc.call(this, mode, storenames, dbschema, parent);\n      // If this transaction is bound to any observable table, make sure to add changes when transaction completes.\n      if (addChanges) {\n        trans._lastWrittenRevision = 0;\n        trans.on('complete', function () {\n          if (trans._lastWrittenRevision) {\n            // Changes were written in this transaction.\n            if (!parent) {\n              // This is root-level transaction, i.e. a physical commit has happened.\n              // Delay-trigger a wakeup call:\n              if (wakeupObservers.timeoutHandle) clearTimeout(wakeupObservers.timeoutHandle);\n              wakeupObservers.timeoutHandle = setTimeout(function () {\n                delete wakeupObservers.timeoutHandle;\n                wakeupObservers(trans._lastWrittenRevision);\n              }, 25);\n            } else {\n              // This is just a virtual commit of a sub transaction.\n              // Wait with waking up observers until root transaction has committed.\n              // Make sure to mark root transaction so that it will wakeup observers upon commit.\n              var rootTransaction = (function findRootTransaction(trans) {\n                return trans.parent ? findRootTransaction(trans.parent) : trans;\n              })(parent);\n              rootTransaction._lastWrittenRevision = Math.max(\n                  trans._lastWrittenRevision,\n                  rootTransaction.lastWrittenRevision || 0);\n            }\n          }\n        });\n        // Derive \"source\" property from parent transaction by default\n        if (trans.parent && trans.parent.source) trans.source = trans.parent.source;\n      }\n      return trans;\n    };\n  };\n}\n","import Dexie from 'dexie';\n\nexport default function initWakeupObservers(db, Observable, localStorage) {\n  return function wakeupObservers(lastWrittenRevision) {\n    // Make sure Observable.latestRevision[db.name] is still below our value, now when some time has elapsed and other db instances in same window possibly could have made changes too.\n    if (Observable.latestRevision[db.name] < lastWrittenRevision) {\n      // Set the static property lastRevision[db.name] to the revision of the last written change.\n      Observable.latestRevision[db.name] = lastWrittenRevision;\n      // Wakeup ourselves, and any other db instances on this window:\n      Dexie.ignoreTransaction(function () {\n        Observable.on('latestRevisionIncremented').fire(db.name, lastWrittenRevision);\n      });\n      // Observable.on.latestRevisionIncremented will only wakeup db's in current window.\n      // We need a storage event to wakeup other windwos.\n      // Since indexedDB lacks storage events, let's use the storage event from WebStorage just for\n      // the purpose to wakeup db instances in other windows.\n      if (localStorage) localStorage.setItem('Dexie.Observable/latestRevision/' + db.name, lastWrittenRevision); // In IE, this will also wakeup our own window. However, onLatestRevisionIncremented will work around this by only running once per revision id.\n    }\n  };\n}\n","// Change Types\nexport const CREATE = 1;\nexport const UPDATE = 2;\nexport const DELETE = 3;\n","import Dexie from 'dexie';\n\nimport {CREATE} from '../change_types';\nimport {createUUID} from '../utils';\n\nexport default function initCreatingHook(db, table) {\n  return function creatingHook(primKey, obj, trans) {\n    /// <param name=\"trans\" type=\"db.Transaction\"></param>\n    var rv = undefined;\n    if (primKey === undefined && table.schema.primKey.uuid) {\n      primKey = rv = createUUID();\n      if (table.schema.primKey.keyPath) {\n        Dexie.setByKeyPath(obj, table.schema.primKey.keyPath, primKey);\n      }\n    }\n\n    var change = {\n      source: trans.source || null, // If a \"source\" is marked on the transaction, store it. Useful for observers that want to ignore their own changes.\n      table: table.name,\n      key: primKey === undefined ? null : primKey,\n      type: CREATE,\n      obj: obj\n    };\n\n    var promise = db._changes.add(change).then(function (rev) {\n      trans._lastWrittenRevision = Math.max(trans._lastWrittenRevision, rev);\n      return rev;\n    });\n\n    // Wait for onsuccess so that we have the primKey if it is auto-incremented and update the change item if so.\n    this.onsuccess = function (resultKey) {\n      if (primKey != resultKey)\n        promise._then(function () {\n          change.key = resultKey;\n          db._changes.put(change);\n        });\n    };\n\n    this.onerror = function () {\n      // If the main operation fails, make sure to regret the change\n      promise._then(function (rev) {\n        // Will only happen if app code catches the main operation error to prohibit transaction from aborting.\n        db._changes.delete(rev);\n      });\n    };\n\n    return rv;\n  };\n}\n","import Dexie from 'dexie';\n\nimport {UPDATE} from '../change_types';\n\nexport default function initUpdatingHook(db, tableName) {\n  return function updatingHook(mods, primKey, oldObj, trans) {\n    /// <param name=\"trans\" type=\"db.Transaction\"></param>\n    // mods may contain property paths with undefined as value if the property\n    // is being deleted. Since we cannot persist undefined we need to act\n    // like those changes is setting the value to null instead.\n    var modsWithoutUndefined = {};\n    // As of current Dexie version (1.0.3) hook may be called even if it wouldn't really change.\n    // Therefore we may do that kind of optimization here - to not add change entries if\n    // there's nothing to change.\n    var anythingChanged = false;\n    var newObj = Dexie.deepClone(oldObj);\n    for (var propPath in mods) {\n      var mod = mods[propPath];\n      if (typeof mod === 'undefined') {\n        Dexie.delByKeyPath(newObj, propPath);\n        modsWithoutUndefined[propPath] = null; // Null is as close we could come to deleting a property when not allowing undefined.\n        anythingChanged = true;\n      } else {\n        var currentValue = Dexie.getByKeyPath(oldObj, propPath);\n        if (mod !== currentValue && JSON.stringify(mod) !== JSON.stringify(currentValue)) {\n          Dexie.setByKeyPath(newObj, propPath, mod);\n          modsWithoutUndefined[propPath] = mod;\n          anythingChanged = true;\n        }\n      }\n    }\n    if (anythingChanged) {\n      var change = {\n        source: trans.source || null, // If a \"source\" is marked on the transaction, store it. Useful for observers that want to ignore their own changes.\n        table: tableName,\n        key: primKey,\n        type: UPDATE,\n        mods: modsWithoutUndefined,\n        oldObj: oldObj,\n        obj: newObj\n      };\n      var promise = db._changes.add(change); // Just so we get the correct revision order of the update...\n      this.onsuccess = function () {\n        promise._then(function (rev) {\n          trans._lastWrittenRevision = Math.max(trans._lastWrittenRevision, rev);\n        });\n      };\n      this.onerror = function () {\n        // If the main operation fails, make sure to regret the change.\n        promise._then(function (rev) {\n          // Will only happen if app code catches the main operation error to prohibit transaction from aborting.\n          db._changes.delete(rev);\n        });\n      };\n    }\n  };\n}\n","import {DELETE} from '../change_types';\n\nexport default function initDeletingHook(db, tableName) {\n  return function deletingHook(primKey, obj, trans) {\n    /// <param name=\"trans\" type=\"db.Transaction\"></param>\n    var promise = db._changes.add({\n      source: trans.source || null, // If a \"source\" is marked on the transaction, store it. Useful for observers that want to ignore their own changes.\n      table: tableName,\n      key: primKey,\n      type: DELETE,\n      oldObj: obj\n    }).then(function (rev) {\n      trans._lastWrittenRevision = Math.max(trans._lastWrittenRevision, rev);\n      return rev;\n    })\n        .catch((e) => {\n          console.log(obj)\n          console.log(e.stack)\n        })\n    this.onerror = function () {\n      // If the main operation fails, make sure to regret the change.\n      // Using _then because if promise is already fullfilled, the standard then() would\n      // do setTimeout() and we would loose the transaction.\n      promise._then(function (rev) {\n        // Will only happen if app code catches the main operation error to prohibit transaction from aborting.\n        db._changes.delete(rev);\n      });\n    };\n  };\n}\n","import initCreatingHook from './creating';\nimport initUpdatingHook from './updating';\nimport initDeletingHook from './deleting';\n\nexport default function initCrudMonitor(db) {\n//\n// The Creating/Updating/Deleting hook will make sure any change is stored to the changes table\n//\n  return function crudMonitor(table) {\n    /// <param name=\"table\" type=\"db.Table\"></param>\n    if (table.hook._observing) return;\n    table.hook._observing = true;\n\n    const tableName = table.name;\n    table.hook('creating').subscribe(initCreatingHook(db, table));\n\n    table.hook('updating').subscribe(initUpdatingHook(db, tableName));\n\n    table.hook('deleting').subscribe(initDeletingHook(db, tableName));\n  };\n}\n","import Dexie from 'dexie';\n\nexport default function initOnStorage(Observable) {\n  return function onStorage(event) {\n    // We use the onstorage event to trigger onLatestRevisionIncremented since we will wake up when other windows modify the DB as well!\n    if (event.key && event.key.indexOf(\"Dexie.Observable/\") === 0) { // For example \"Dexie.Observable/latestRevision/FriendsDB\"\n      var parts = event.key.split('/');\n      var prop = parts[1];\n      var dbname = parts[2];\n      if (prop === 'latestRevision') {\n        var rev = parseInt(event.newValue, 10);\n        if (!isNaN(rev) && rev > Observable.latestRevision[dbname]) {\n          Observable.latestRevision[dbname] = rev;\n          Dexie.ignoreTransaction(function () {\n            Observable.on('latestRevisionIncremented').fire(dbname, rev);\n          });\n        }\n      } else if (prop.indexOf(\"deadnode:\") === 0) {\n        var nodeID = parseInt(prop.split(':')[1], 10);\n        if (event.newValue) {\n          Observable.on.suicideNurseCall.fire(dbname, nodeID);\n        }\n      } else if (prop === 'intercomm') {\n        if (event.newValue) {\n          Observable.on.intercomm.fire(dbname);\n        }\n      }\n    }\n  };\n}\n","export default function initOverrideOpen(db, SyncNode, crudMonitor) {\n  return function overrideOpen(origOpen) {\n    return function () {\n      //\n      // Make sure to subscribe to \"creating\", \"updating\" and \"deleting\" hooks for all observable tables that were created in the stores() method.\n      //\n      Object.keys(db._allTables).forEach(tableName => {\n        let table = db._allTables[tableName];\n        if (table.schema.observable) {\n          crudMonitor(table);\n        }\n        if (table.name === \"_syncNodes\") {\n          table.mapToClass(SyncNode);\n        }\n      });\n      return origOpen.apply(this, arguments);\n    }\n  };\n}\n","import Dexie from 'dexie';\n\nconst Promise = Dexie.Promise;\n\nexport default function initIntercomm(db, Observable, SyncNode, mySyncNode, localStorage) {\n//\n// Intercommunication between nodes\n//\n// Enable inter-process communication between browser windows using localStorage storage event (is registered in Dexie.Observable)\n\n  var requestsWaitingForReply = {};\n\n  /**\n   * @param {string} type Type of message\n   * @param message Message to send\n   * @param {number} destinationNode ID of destination node\n   * @param {{wantReply: boolean, isFailure: boolean, requestId: number}} options If {wantReply: true}, the returned promise will complete with the reply from remote. Otherwise it will complete when message has been successfully sent.</param>\n   */\n  db.observable.sendMessage = function (type, message, destinationNode, options) {\n    /// <param name=\"type\" type=\"String\">Type of message</param>\n    /// <param name=\"message\">Message to send</param>\n    /// <param name=\"destinationNode\" type=\"Number\">ID of destination node</param>\n    /// <param name=\"options\" type=\"Object\" optional=\"true\">{wantReply: Boolean, isFailure: Boolean, requestId: Number}. If wantReply, the returned promise will complete with the reply from remote. Otherwise it will complete when message has been successfully sent.</param>\n    options = options || {};\n    if (!mySyncNode.node)\n      return options.wantReply ?\n          Promise.reject(new Dexie.DatabaseClosedError()) :\n          Promise.resolve(); // If caller doesn't want a reply, it won't catch errors either.\n\n    var msg = {message: message, destinationNode: destinationNode, sender: mySyncNode.node.id, type: type};\n    Dexie.extend(msg, options); // wantReply: wantReply, success: !isFailure, requestId: ...\n    return Dexie.ignoreTransaction(()=> {\n      var tables = [\"_intercomm\"];\n      if (options.wantReply) tables.push(\"_syncNodes\"); // If caller wants a reply, include \"_syncNodes\" in transaction to check that there's a receiver there. Otherwise, new master will get it.\n      var promise = db.transaction('rw', tables, () => {\n        if (options.wantReply) {\n          // Check that there is a receiver there to take the request.\n          return db._syncNodes.where('id').equals(destinationNode).count(receiverAlive => {\n            if (receiverAlive)\n              return db._intercomm.add(msg);\n            else // If we couldn't find a node -> send to master\n              return db._syncNodes.where('isMaster').above(0).first(function (masterNode) {\n                msg.destinationNode = masterNode.id;\n                return db._intercomm.add(msg)\n              });\n          });\n        } else {\n          // If caller doesn't need a response, we don't have to make sure that it gets one.\n          return db._intercomm.add(msg);\n        }\n      }).then(messageId => {\n        var rv = null;\n        if (options.wantReply) {\n          rv = new Promise(function (resolve, reject) {\n            requestsWaitingForReply[messageId.toString()] = {resolve: resolve, reject: reject};\n          });\n        }\n        if (localStorage) {\n          localStorage.setItem(\"Dexie.Observable/intercomm/\" + db.name, messageId.toString());\n        }\n        Observable.on.intercomm.fire(db.name);\n        return rv;\n      });\n\n      if (!options.wantReply) {\n        promise.catch(()=> {\n        });\n        return;\n      } else {\n        // Forward rejection to caller if it waits for reply.\n        return promise;\n      }\n    });\n  };\n\n  // Send a message to all local _syncNodes\n  db.observable.broadcastMessage = function (type, message, bIncludeSelf) {\n    if (!mySyncNode.node) return;\n    var mySyncNodeId = mySyncNode.node.id;\n    Dexie.ignoreTransaction(()=> {\n      db._syncNodes.toArray(nodes => {\n        return Promise.all(nodes\n            .filter(node => node.type === 'local' && (bIncludeSelf || node.id !== mySyncNodeId))\n            .map(node => db.observable.sendMessage(type, message, node.id)));\n      }).catch(()=> {\n      });\n    });\n  };\n\n  function consumeIntercommMessages() {\n    // Check if we got messages:\n    if (!mySyncNode.node) return Promise.reject(new Dexie.DatabaseClosedError());\n\n    return Dexie.ignoreTransaction(()=> {\n      return db.transaction('rw', '_intercomm', function() {\n        return db._intercomm.where({destinationNode: mySyncNode.node.id}).toArray(messages => {\n          messages.forEach(msg => consumeMessage(msg));\n          return db._intercomm.where('id').anyOf(messages.map(msg => msg.id)).delete();\n        });\n      });\n    });\n  }\n\n  function consumeMessage(msg) {\n    if (msg.type === 'response') {\n      // This is a response. Lookup pending request and fulfill its promise.\n      var request = requestsWaitingForReply[msg.requestId.toString()];\n      if (request) {\n        if (msg.isFailure) {\n          request.reject(msg.message.error);\n        } else {\n          request.resolve(msg.message.result);\n        }\n        delete requestsWaitingForReply[msg.requestId.toString()];\n      }\n    } else {\n      // This is a message or request. Fire the event and add an API for the subscriber to use if reply is requested\n      msg.resolve = function (result) {\n        db.observable.sendMessage('response', {result: result}, msg.sender, {requestId: msg.id});\n      };\n      msg.reject = function (error) {\n        db.observable.sendMessage('response', {error: error.toString()}, msg.sender, {isFailure: true, requestId: msg.id});\n      };\n      db.on.message.fire(msg);\n    }\n  }\n\n  // Listener for 'intercomm' events\n  // Gets fired when we get a 'storage' event from local storage or when sendMessage is called\n  // 'storage' is used to communicate between tabs (sendMessage changes the localStorage to trigger the event)\n  // sendMessage is used to communicate in the same tab and to trigger a storage event\n  function onIntercomm(dbname) {\n    // When storage event trigger us to check\n    if (dbname === db.name) {\n      consumeIntercommMessages().catch('DatabaseClosedError', ()=> {});\n    }\n  }\n\n  return {\n    onIntercomm,\n    consumeIntercommMessages\n  };\n}\n","export default function overrideParseStoresSpec(origFunc) {\n  return function(stores, dbSchema) {\n    // Create the _changes and _syncNodes tables\n    stores[\"_changes\"] = \"++rev\";\n    stores[\"_syncNodes\"] = \"++id,myRevision,lastHeartBeat,&url,isMaster,type,status\";\n    stores[\"_intercomm\"] = \"++id,destinationNode\";\n    stores[\"_uncommittedChanges\"] = \"++id,node\"; // For remote syncing when server returns a partial result.\n    // Call default implementation. Will populate the dbSchema structures.\n    origFunc.call(this, stores, dbSchema);\n    // Allow UUID primary keys using $$ prefix on primary key or indexes\n    Object.keys(dbSchema).forEach(function(tableName) {\n      var schema = dbSchema[tableName];\n      if (schema.primKey.name.indexOf('$$') === 0) {\n        schema.primKey.uuid = true;\n        schema.primKey.name = schema.primKey.name.substr(2);\n        schema.primKey.keyPath = schema.primKey.keyPath.substr(2);\n      }\n    });\n    // Now mark all observable tables\n    Object.keys(dbSchema).forEach(function(tableName) {\n      // Marked observable tables with \"observable\" in their TableSchema.\n      if (tableName.indexOf('_') !== 0 && tableName.indexOf('$') !== 0) {\n        dbSchema[tableName].observable = true;\n      }\n    });\n  };\n}\n","import Dexie from 'dexie';\n\nexport default function deleteOldChanges(db) {\n  // This is a background job and should never be done within\n  // a caller's transaction. Use Dexie.ignoreTransaction() to ensure that.\n  // We should not return the Promise but catch it ourselves instead.\n\n  // To prohibit starving the database we want to lock transactions as short as possible\n  // and since we're not in a hurry, we could do this job in chunks and reschedule a\n  // continuation every 500 ms.\n  const CHUNK_SIZE = 100;\n\n  Dexie.ignoreTransaction(()=>{\n    return db._syncNodes.orderBy(\"myRevision\").first(oldestNode => {\n      return db._changes\n          .where(\"rev\").below(oldestNode.myRevision)\n          .limit(CHUNK_SIZE)\n          .primaryKeys();\n    }).then(keysToDelete => {\n      if (keysToDelete.length === 0) return; // Done.\n      return db._changes.bulkDelete(keysToDelete).then(()=> {\n        // If not done garbage collecting, reschedule a continuation of it until done.\n        if (keysToDelete.length === CHUNK_SIZE) {\n          // Limit reached. Changes are there are more job to do. Schedule again:\n          setTimeout(() => db.isOpen() && deleteOldChanges(db), 500);\n        }\n      });\n    });\n  }).catch(()=>{\n    // The operation is not crucial. A failure could almost only be due to that database has been closed.\n    // No need to log this.\n  });\n}\n","/* ========================================================================== \n *                           dexie-observable.js\n * ==========================================================================\n *\n * Dexie addon for observing database changes not just on local db instance\n * but also on other instances, tabs and windows.\n *\n * Comprises a base framework for dexie-syncable.js\n *\n * By David Fahlander, david.fahlander@gmail.com,\n *    Nikolas Poniros, https://github.com/nponiros\n *\n * ==========================================================================\n *\n * Version {version}, {date}\n *\n * http://dexie.org\n *\n * Apache License Version 2.0, January 2004, http://www.apache.org/licenses/\n * \n */\nimport Dexie from 'dexie';\nimport { nop, promisableChain, createUUID } from './utils';\n\nimport initOverrideCreateTransaction from './override-create-transaction';\nimport initWakeupObservers from './wakeup-observers';\nimport initCrudMonitor from './hooks/crud-monitor';\nimport initOnStorage from './on-storage';\nimport initOverrideOpen from './override-open';\nimport initIntercomm from './intercomm';\n\nimport overrideParseStoresSpec from './override-parse-stores-spec';\n\nimport deleteOldChanges from './delete-old-changes';\n\nvar global = self;\n\n/** class DatabaseChange\n    *\n    *  Object contained by the _changes table.\n    */\nvar DatabaseChange = Dexie.defineClass({\n    rev: Number, // Auto-incremented primary key\n    source: String, // Optional source creating the change. Set if transaction.source was set when doing the operation.\n    table: String, // Table name\n    key: Object, // Primary key. Any type.\n    type: Number, // 1 = CREATE, 2 = UPDATE, 3 = DELETE\n    obj: Object, // CREATE: obj contains the object created.\n    mods: Object, // UPDATE: mods contains the modifications made to the object.\n    oldObj: Object // DELETE: oldObj contains the object deleted. UPDATE: oldObj contains the old object before updates applied.\n});\n\n// Import some usable helper functions\nvar override = Dexie.override;\nvar Promise = Dexie.Promise;\nvar browserIsShuttingDown = false;\n\nexport default function Observable(db) {\n    /// <summary>\n    ///   Extension to Dexie providing Syncronization capabilities to Dexie.\n    /// </summary>\n    /// <param name=\"db\" type=\"Dexie\"></param>\n\n    var NODE_TIMEOUT = 20000, // 20 seconds before local db instances are timed out. This is so that old changes can be deleted when not needed and to garbage collect old _syncNodes objects.\n        HIBERNATE_GRACE_PERIOD = 20000, // 20 seconds\n        // LOCAL_POLL: The time to wait before polling local db for changes and cleaning up old nodes. \n        // Polling for changes is a fallback only needed in certain circomstances (when the onstorage event doesnt reach all listeners - when different browser windows doesnt share the same process)\n        LOCAL_POLL = 500, // 500 ms. In real-world there will be this value + the time it takes to poll(). A small value is needed in Workers where we cannot rely on storage event.\n        HEARTBEAT_INTERVAL = NODE_TIMEOUT - 5000;\n\n    var localStorage = Observable.localStorageImpl;\n\n    /** class SyncNode\n        *\n        * Object contained in the _syncNodes table.\n        */\n    var SyncNode = Dexie.defineClass({\n        //id: Number,\n        myRevision: Number,\n        type: String, // \"local\" or \"remote\"\n        lastHeartBeat: Number,\n        deleteTimeStamp: Number, // In case lastHeartBeat is too old, a value of now + HIBERNATE_GRACE_PERIOD will be set here. If reached before node wakes up, node will be deleted.\n        url: String, // Only applicable for \"remote\" nodes. Only used in Dexie.Syncable.\n        isMaster: Number, // 1 if true. Not using Boolean because it's not possible to index Booleans in IE implementation of IDB.\n\n        // Below properties should be extended in Dexie.Syncable. Not here. They apply to remote nodes only (type == \"remote\"):\n        syncProtocol: String, // Tells which implementation of ISyncProtocol to use for remote syncing. \n        syncContext: null,\n        syncOptions: Object,\n        connected: false, // FIXTHIS: Remove! Replace with status.\n        status: Number,\n        appliedRemoteRevision: null,\n        remoteBaseRevisions: [{ local: Number, remote: null }],\n        dbUploadState: {\n            tablesToUpload: [String],\n            currentTable: String,\n            currentKey: null,\n            localBaseRevision: Number\n        }\n    });\n\n    db.observable = {};\n    db.observable.SyncNode = SyncNode;\n\n    const wakeupObservers = initWakeupObservers(db, Observable, localStorage);\n    const overrideCreateTransaction = initOverrideCreateTransaction(db, wakeupObservers);\n    const crudMonitor = initCrudMonitor(db);\n    const overrideOpen = initOverrideOpen(db, SyncNode, crudMonitor);\n\n    var mySyncNode = {node: null};\n\n    const intercomm = initIntercomm(db, Observable, SyncNode, mySyncNode, localStorage);\n    const onIntercomm = intercomm.onIntercomm;\n    const consumeIntercommMessages = intercomm.consumeIntercommMessages;\n\n    // Allow other addons to access the local sync node. May be needed by Dexie.Syncable.\n    Object.defineProperty(db, \"_localSyncNode\", {\n        get: function() { return mySyncNode.node; }\n    });\n\n    var pollHandle = null,\n        heartbeatHandle = null;\n\n    if (Dexie.fake) {\n        // This code will never run.\n        // It's here just to enable auto-complete in visual studio - helps a lot when writing code.\n        db.version(1).stores({\n            _syncNodes: \"++id,myRevision,lastHeartBeat\",\n            _changes: \"++rev\",\n            _intercomm: \"++id,destinationNode\",\n            _uncommittedChanges: \"++id,node\"\n        });\n        db._syncNodes.mapToClass(SyncNode);\n        db._changes.mapToClass(DatabaseChange);\n        mySyncNode.node = new SyncNode({\n            myRevision: 0,\n            type: \"local\",\n            lastHeartBeat: Date.now(),\n            deleteTimeStamp: null\n        });\n    }\n\n    //\n    // Override parsing the stores to add \"_changes\" and \"_syncNodes\" tables.\n    // It also adds UUID support for the primary key and sets tables as observable tables.\n    //\n    db.Version.prototype._parseStoresSpec = override(db.Version.prototype._parseStoresSpec, overrideParseStoresSpec);\n\n    // changes event on db:\n    db.on.addEventType({\n        changes: 'asap',\n        cleanup: [promisableChain, nop], // fire (nodesTable, changesTable, trans). Hook called when cleaning up nodes. Subscribers may return a Promise to to more stuff. May do additional stuff if local sync node is master.\n        message: 'asap'\n    });\n\n    //\n    // Override transaction creation to always include the \"_changes\" store when any observable store is involved.\n    //\n    db._createTransaction = override(db._createTransaction, overrideCreateTransaction);\n\n    // If Observable.latestRevsion[db.name] is undefined, set it to 0 so that comparing against it always works.\n    // You might think that it will always be undefined before this call, but in case another Dexie instance in the same\n    // window with the same database name has been created already, this static property will already be set correctly.\n    Observable.latestRevision[db.name] = Observable.latestRevision[db.name] || 0;\n\n    //\n    // Override open to setup hooks for db changes and map the _syncNodes table to class\n    //\n    db.open = override(db.open, overrideOpen);\n\n    db.close = override(db.close, function(origClose) {\n        return function () {\n            if (db.dynamicallyOpened()) return origClose.apply(this, arguments); // Don't observe dynamically opened databases.\n            // Teardown our framework.\n            if (wakeupObservers.timeoutHandle) {\n                clearTimeout(wakeupObservers.timeoutHandle);\n                delete wakeupObservers.timeoutHandle;\n            }\n            Observable.on('latestRevisionIncremented').unsubscribe(onLatestRevisionIncremented);\n            Observable.on('suicideNurseCall').unsubscribe(onSuicide);\n            Observable.on('intercomm').unsubscribe(onIntercomm);\n            Observable.on('beforeunload').unsubscribe(onBeforeUnload);\n            // Inform other db instances in same window that we are dying:\n            if (mySyncNode.node && mySyncNode.node.id) {\n                Observable.on.suicideNurseCall.fire(db.name, mySyncNode.node.id);\n                // Inform other windows as well:\n                if (localStorage) {\n                    localStorage.setItem('Dexie.Observable/deadnode:' + mySyncNode.node.id.toString() + '/' + db.name, \"dead\"); // In IE, this will also wakeup our own window. cleanup() may trigger twice per other db instance. But that doesnt to anything.\n                }\n                mySyncNode.node.deleteTimeStamp = 1; // One millisecond after 1970. Makes it occur in the past but still keeps it truthy.\n                mySyncNode.node.lastHeartBeat = 0;\n                db._syncNodes.put(mySyncNode.node); // This async operation may be cancelled since the browser is closing down now.\n                mySyncNode.node = null;\n            }\n\n            if (pollHandle) clearTimeout(pollHandle);\n            pollHandle = null;\n            if (heartbeatHandle) clearTimeout(heartbeatHandle);\n            heartbeatHandle = null;\n            return origClose.apply(this, arguments);\n        };\n    });\n\n    // Override Dexie.delete() in order to delete Observable.latestRevision[db.name].\n    db.delete = override(db.delete, function(origDelete) {\n        return function() {\n            return origDelete.apply(this, arguments).then(function(result) {\n                // Reset Observable.latestRevision[db.name]\n                Observable.latestRevision[db.name] = 0;\n                return result;\n            });\n        };\n    });\n\n    // When db opens, make sure to start monitor any changes before other db operations will start.\n    db.on(\"ready\", function startObserving() {\n        if (db.dynamicallyOpened()) return db; // Don't observe dynamically opened databases.\n        \n        return db.table(\"_changes\").orderBy(\"rev\").last(function(lastChange) {\n            // Since startObserving() is called before database open() method, this will be the first database operation enqueued to db.\n            // Therefore we know that the retrieved value will be This query will\n            var latestRevision = (lastChange ? lastChange.rev : 0);\n            mySyncNode.node = new SyncNode({\n                myRevision: latestRevision,\n                type: \"local\",\n                lastHeartBeat: Date.now(),\n                deleteTimeStamp: null,\n                isMaster: 0\n            });\n            if (Observable.latestRevision[db.name] < latestRevision) {\n                // Side track . For correctness whenever setting Observable.latestRevision[db.name] we must make sure the event is fired if increased:\n                // There are other db instances in same window that hasnt yet been informed about a new revision\n                Observable.latestRevision[db.name] = latestRevision;\n                Dexie.ignoreTransaction(function() {\n                    Observable.on.latestRevisionIncremented.fire(latestRevision);\n                });\n            }\n            // Add new sync node or if this is a reopening of the database after a close() call, update it.\n            return db.transaction('rw', '_syncNodes', () => {\n                return db._syncNodes\n                    .where('isMaster').equals(1)\n                    .first(currentMaster => {\n                        if (!currentMaster) {\n                            // There's no master. We must be the master\n                            mySyncNode.node.isMaster = 1;\n                        } else if (currentMaster.lastHeartBeat < Date.now() - NODE_TIMEOUT) {\n                            // Master have been inactive for too long\n                            // Take over mastership\n                            mySyncNode.node.isMaster = 1;\n                            currentMaster.isMaster = 0;\n                            return db._syncNodes.put(currentMaster);\n                        }\n                    }).then(()=>{\n                        // Add our node to DB and start subscribing to events\n                        return db._syncNodes.add(mySyncNode.node).then(function() {\n                            Observable.on('latestRevisionIncremented', onLatestRevisionIncremented); // Wakeup when a new revision is available.\n                            Observable.on('beforeunload', onBeforeUnload);\n                            Observable.on('suicideNurseCall', onSuicide);\n                            Observable.on('intercomm', onIntercomm);\n                            // Start polling for changes and do cleanups:\n                            pollHandle = setTimeout(poll, LOCAL_POLL);\n                            // Start heartbeat\n                            heartbeatHandle = setTimeout(heartbeat, HEARTBEAT_INTERVAL);\n                        });\n                });\n            }).then(function () {\n                cleanup();\n            });\n        });\n    }, true); // True means the on(ready) event will survive a db reopening (db.close() / db.open()).\n\n    var handledRevision = 0;\n\n    function onLatestRevisionIncremented(dbname, latestRevision) {\n        if (dbname === db.name) {\n            if (handledRevision >= latestRevision) return; // Make sure to only run once per revision. (Workaround for IE triggering storage event on same window)\n            handledRevision = latestRevision;\n            Dexie.vip(function() {\n                readChanges(latestRevision).catch('DatabaseClosedError', ()=>{\n                    // Handle database closed error gracefully while reading changes.\n                    // Don't trigger 'unhandledrejection'.\n                    // Even though we intercept the close() method, it might be called when in the middle of\n                    // reading changes and then that flow will cancel with DatabaseClosedError.\n                });\n            });\n        }\n    }\n\n    function readChanges(latestRevision, recursion, wasPartial) {\n        // Whenever changes are read, fire db.on(\"changes\") with the array of changes. Eventually, limit the array to 1000 entries or so (an entire database is\n        // downloaded from server AFTER we are initiated. For example, if first sync call fails, then after a while we get reconnected. However, that scenario\n        // should be handled in case database is totally empty we should fail if sync is not available)\n        if (!recursion && readChanges.ongoingOperation) {\n            // We are already reading changes. Prohibit a parallell execution of this which would lead to duplicate trigging of 'changes' event.\n            // Instead, the callback in toArray() will always check Observable.latestRevision[db.name] to see if it has changed and if so, re-launch readChanges().\n            // The caller should get the Promise instance from the ongoing operation so that the then() method will resolve when operation is finished.\n            return readChanges.ongoingOperation;\n        }\n\n        var partial = false;\n        var ourSyncNode = mySyncNode.node; // Because mySyncNode can suddenly be set to null on database close, and worse, can be set to a new value if database is reopened.\n        if (!ourSyncNode) {\n            return Promise.reject(new Dexie.DatabaseClosedError());\n        }\n        var LIMIT = 1000;\n        var promise = db._changes.where(\"rev\").above(ourSyncNode.myRevision).limit(LIMIT).toArray(function (changes) {\n            if (changes.length > 0) {\n                var lastChange = changes[changes.length - 1];\n                partial = (changes.length === LIMIT);\n                db.on('changes').fire(changes, partial);\n                ourSyncNode.myRevision = lastChange.rev;\n            } else if (wasPartial) {\n                // No more changes, BUT since we have triggered on('changes') with partial = true,\n                // we HAVE TO trigger changes again with empty list and partial = false\n                db.on('changes').fire([], false);\n            }\n\n            let ourNodeStillExists = false;\n            return db._syncNodes.where(':id').equals(ourSyncNode.id).modify(syncNode => {\n                ourNodeStillExists = true;\n                syncNode.lastHeartBeat = Date.now(); // Update heart beat (not nescessary, but why not!)\n                syncNode.deleteTimeStamp = null; // Reset \"deleteTimeStamp\" flag if it was there.\n                syncNode.myRevision = Math.max(syncNode.myRevision, ourSyncNode.myRevision);\n            }).then(()=>ourNodeStillExists);\n        }).then(ourNodeStillExists =>{\n            if (!ourNodeStillExists) {\n                // My node has been deleted. We must have been lazy and got removed by another node.\n                if (browserIsShuttingDown) {\n                    throw new Error(\"Browser is shutting down\");\n                } else {\n                    db.close();\n                    console.error(\"Out of sync\"); // TODO: What to do? Reload the page?\n                    if (global.location) global.location.reload(true);\n                    throw new Error(\"Out of sync\"); // Will make current promise reject\n                }\n            }\n\n            // Check if more changes have come since we started reading changes in the first place. If so, relaunch readChanges and let the ongoing promise not\n            // resolve until all changes have been read.\n            if (partial || Observable.latestRevision[db.name] > ourSyncNode.myRevision) {\n                // Either there were more than 1000 changes or additional changes where added while we were reading these changes,\n                // In either case, call readChanges() again until we're done.\n                return readChanges(Observable.latestRevision[db.name], (recursion || 0) + 1, partial);\n            }\n\n        }).finally(function() {\n            delete readChanges.ongoingOperation;\n        });\n\n        if (!recursion) {\n            readChanges.ongoingOperation = promise;\n        }\n        return promise;\n    }\n\n    /**\n     * The reason we need heartbeat in parallell with poll() is due to the risk of long-running\n     * transactions while syncing changes from server to client in Dexie.Syncable. That transaction will\n     * include _changes (which will block readChanges()) but not _syncNodes. So this heartbeat will go on\n     * during that changes are being applied and update our lastHeartBeat property while poll() is waiting.\n     * When cleanup() (who also is blocked by the sync) wakes up, it won't kill the master node because this\n     * heartbeat job will have updated the master node's heartbeat during the long-running sync transaction.\n     * \n     * If we did not have this heartbeat, and a server send lots of changes that took more than NODE_TIMEOUT\n     * (20 seconds), another node waking up after the sync would kill the master node and take over because\n     * it would believe it was dead.\n     */\n    function heartbeat() {\n        heartbeatHandle = null;\n        var currentInstance = mySyncNode.node && mySyncNode.node.id;\n        if (!currentInstance) return;\n        db.transaction('rw!', db._syncNodes, ()=>{\n            db._syncNodes.where({id: currentInstance}).first(ourSyncNode => {\n                if (!ourSyncNode) {\n                    // We do not exist anymore. Call db.close() to teardown polls etc.\n                    if (db.isOpen()) db.close();\n                    return;\n                }\n                ourSyncNode.lastHeartBeat = Date.now();\n                ourSyncNode.deleteTimeStamp = null; // Reset \"deleteTimeStamp\" flag if it was there.\n                return db._syncNodes.put(ourSyncNode);\n            });\n        }).catch('DatabaseClosedError', () => {\n            // Ignore silently\n        }).finally(() => {\n            if (mySyncNode.node && mySyncNode.node.id === currentInstance && db.isOpen()) {\n                heartbeatHandle = setTimeout(heartbeat, HEARTBEAT_INTERVAL);\n            }\n        });\n    }\n\n    function poll() {\n        pollHandle = null;\n        var currentInstance = mySyncNode.node && mySyncNode.node.id;\n        if (!currentInstance) return;\n        Dexie.vip(function() { // VIP ourselves. Otherwise we might not be able to consume intercomm messages from master node before database has finished opening. This would make DB stall forever. Cannot rely on storage-event since it may not always work in some browsers of different processes.\n            readChanges(Observable.latestRevision[db.name]).then(cleanup).then(consumeIntercommMessages)\n            .catch('DatabaseClosedError', ()=>{\n                // Handle database closed error gracefully while reading changes.\n                // Don't trigger 'unhandledrejection'.\n                // Even though we intercept the close() method, it might be called when in the middle of\n                // reading changes and then that flow will cancel with DatabaseClosedError.\n            })\n            .finally(function() {\n                // Poll again in given interval:\n                if (mySyncNode.node && mySyncNode.node.id === currentInstance && db.isOpen()) {\n                    pollHandle = setTimeout(poll, LOCAL_POLL);\n                }\n            });\n        });\n    }\n\n    \n    function cleanup() {\n        var ourSyncNode = mySyncNode.node;\n        if (!ourSyncNode) return Promise.reject(new Dexie.DatabaseClosedError());\n        return db.transaction('rw', '_syncNodes', '_changes', '_intercomm', function() {\n            // Cleanup dead local nodes that has no heartbeat for over a minute\n            // Dont do the following:\n            //nodes.where(\"lastHeartBeat\").below(Date.now() - NODE_TIMEOUT).and(function (node) { return node.type == \"local\"; }).delete();\n            // Because client may have been in hybernate mode and recently woken up. That would lead to deletion of all nodes.\n            // Instead, we should mark any old nodes for deletion in a minute or so. If they still dont wakeup after that minute we could consider them dead.\n            var weBecameMaster = false;\n            db._syncNodes.where(\"lastHeartBeat\").below(Date.now() - NODE_TIMEOUT).filter(node => node.type === 'local').modify(function(node) {\n                if (node.deleteTimeStamp && node.deleteTimeStamp < Date.now()) {\n                    // Delete the node.\n                    delete this.value;\n                    // Cleanup localStorage \"deadnode:\" entry for this node (localStorage API was used to wakeup other windows (onstorage event) - an event type missing in indexedDB.)\n                    if (localStorage) {\n                        localStorage.removeItem('Dexie.Observable/deadnode:' + node.id + '/' + db.name);\n                    }\n                    // Check if we are deleting a master node\n                    if (node.isMaster) {\n                        // The node we are deleting is master. We must take over that role.\n                        // OK to call nodes.update(). No need to call Dexie.vip() because nodes is opened in existing transaction!\n                        db._syncNodes.update(ourSyncNode, { isMaster: 1 });\n                        weBecameMaster = true;\n                    }\n                    // Cleanup intercomm messages destinated to the node being deleted.\n                    // Those that waits for reply should be redirected to us.\n                    db._intercomm.where({destinationNode: node.id}).modify(function(msg) {\n                        if (msg.wantReply)\n                            msg.destinationNode = ourSyncNode.id;\n                        else\n                            // Delete the message from DB and if someone is waiting for reply, let ourselved answer the request.\n                            delete this.value;\n                    });\n                } else if (!node.deleteTimeStamp) {\n                    // Mark the node for deletion\n                    node.deleteTimeStamp = Date.now() + HIBERNATE_GRACE_PERIOD;\n                }\n            }).then(function() {\n                // Cleanup old revisions that no node is interested of.\n                Observable.deleteOldChanges(db);\n                return db.on(\"cleanup\").fire(weBecameMaster);\n            });\n        });\n    }\n\n    function onBeforeUnload() {\n        // Mark our own sync node for deletion.\n        if (!mySyncNode.node) return;\n        browserIsShuttingDown = true;\n        mySyncNode.node.deleteTimeStamp = 1; // One millisecond after 1970. Makes it occur in the past but still keeps it truthy.\n        mySyncNode.node.lastHeartBeat = 0;\n        db._syncNodes.put(mySyncNode.node); // This async operation may be cancelled since the browser is closing down now.\n        Observable.wereTheOneDying = true; // If other nodes in same window wakes up by this call, make sure they dont start taking over mastership and stuff...\n        // Inform other windows that we're gone, so that they may take over our role if needed. Setting localStorage item below will trigger Observable.onStorage, which will trigger onSuicie() below:\n        if (localStorage) {\n            localStorage.setItem('Dexie.Observable/deadnode:' + mySyncNode.node.id.toString() + '/' + db.name, \"dead\"); // In IE, this will also wakeup our own window. However, that is doublechecked in nursecall subscriber below.\n        }\n    }\n\n    function onSuicide(dbname, nodeID) {\n        if (dbname === db.name && !Observable.wereTheOneDying) {\n            // Make sure it's dead indeed. Second bullet. Why? Because it has marked itself for deletion in the onbeforeunload event, which is fired just before window dies.\n            // It's own call to put() may have been cancelled.\n            // Note also that in IE, this event may be called twice, but that doesnt harm!\n            Dexie.vip(function() {\n                db._syncNodes.update(nodeID, { deleteTimeStamp: 1, lastHeartBeat: 0 }).then(cleanup);\n            });\n        }\n    }\n\n}\n\n//\n// Static properties and methods\n// \n\nObservable.latestRevision = {}; // Latest revision PER DATABASE. Example: Observable.latestRevision.FriendsDB = 37;\nObservable.on = Dexie.Events(null, \"latestRevisionIncremented\", \"suicideNurseCall\", \"intercomm\", \"beforeunload\"); // fire(dbname, value);\nObservable.createUUID = createUUID;\n\nObservable.deleteOldChanges = deleteOldChanges;\n\nObservable._onStorage = initOnStorage(Observable);\n\nObservable._onBeforeUnload = function() {\n    Observable.on.beforeunload.fire();\n};\n\ntry {\n    Observable.localStorageImpl = global.localStorage;\n} catch (ex){}\n\n//\n// Map window events to static events in Dexie.Observable:\n//\nif (global.addEventListener) {\n    global.addEventListener(\"storage\", Observable._onStorage);\n    global.addEventListener(\"beforeunload\", Observable._onBeforeUnload);\n}\n// Register addon:\nDexie.Observable = Observable;\nDexie.addons.push(Observable);\n"]},"metadata":{},"sourceType":"module"}