{"ast":null,"code":"import { OrderedMap } from 'immutable';\nimport _ from 'lodash';\nimport Service from './service';\nimport Realtime from './realtime';\nimport moment from \"moment\";\nimport { ObjectID } from './helpers/objectid';\nimport bcrypt from 'bcryptjs';\nimport axios from \"../src/apis/axios\";\nexport default class Store {\n  constructor(appComponent) {\n    this.app = appComponent;\n    this.service = new Service();\n    this.messages = new OrderedMap();\n    this.channels = new OrderedMap();\n    this.activeChannelId = null;\n    this.user = this.getUserFromLocalStorage();\n    this.token = this.getTokenFromLocalStorage();\n    this.users = new OrderedMap();\n    this.realtime = new Realtime(this);\n    this.fetchUserChannels();\n    this.search = {\n      users: new OrderedMap()\n    };\n  }\n\n  editPassword(oldPassword, newPassword, ipClient) {\n    const userToken = this.getUserTokenId();\n    const contents = {\n      oldPassword: oldPassword,\n      newPassword: newPassword\n    };\n\n    if (userToken) {\n      const options = {\n        headers: {\n          authorization: userToken\n        }\n      };\n      return new Promise((resolve, reject) => {\n        // console.log(contents);\n        this.service.post('api/user/editpassword', contents, options).then(res => {\n          //soon add code process\n          if (!res.data.success) {\n            console.log(res.data.error);\n          }\n\n          const currentUser = this.getCurrentUser();\n\n          const email = _.get(currentUser, 'email', '');\n\n          const name = _.get(currentUser, 'name', '');\n\n          const post = {\n            email: email,\n            name: name,\n            ipClient: ipClient\n          };\n          console.log(post); // await axios\n          // .post('/ndsapi/announce/changeinfouser', post)\n          // .then(function(response) {\n          //     console.log(\"Successful\");\n          // }).catch(err => console.log(err))\n\n          return resolve(currentUser);\n        }).catch(err => {\n          const message = _.get(err, 'response.data.error.message', 'Changeing Password Error!');\n\n          return reject(message);\n        });\n      });\n    }\n  }\n\n  uploadUserAvatar(formData) {\n    const userToken = this.getUserTokenId();\n\n    if (userToken) {\n      const options = {\n        headers: {\n          authorization: userToken\n        }\n      };\n      this.service.post('api/user/uploadavatar', formData, options).then(res => {\n        // console.log(res.data.success);\n        if (!res.data.success) {\n          console.log(res.data.error);\n        }\n\n        if (res.data.success) {\n          this.editInfoUser('avatar', res.data.url);\n        }\n      }).catch(err => {\n        console.log(\"Send Error: \", err);\n      });\n    }\n  }\n\n  editUser(field, value) {\n    if (value) {\n      console.log(field, value, typeof value);\n      this.editInfoUser(field, value);\n    }\n  }\n\n  setThemeToLocalStorage(isDark = false) {\n    console.log(\"Select theme Dark: \", isDark);\n    localStorage.setItem('themeOfChat', isDark);\n  }\n\n  getThemeFromLocalStorage() {\n    let theme = null;\n    const data = localStorage.getItem('themeOfChat');\n\n    if (data) {\n      try {\n        theme = data;\n      } catch (err) {\n        console.log(err);\n      }\n    }\n\n    console.log(\"Get theme Dark from localStorage: \", theme);\n    return theme;\n  }\n\n  upLoadfile(formData) {\n    const userToken = this.getUserTokenId();\n    console.log('File wav get in store: ', formData);\n\n    if (userToken) {\n      this.service.post('api/messages/uploadfiles', formData).then(res => {\n        console.log(res.data.success);\n\n        if (!res.data.success) {\n          console.log(res.data.error);\n        }\n\n        if (res.data.success) {\n          const messageId = new ObjectID().toString();\n          const channel = this.getActiveChannel();\n\n          const channelId = _.get(channel, '_id', null);\n\n          const currentUser = this.getCurrentUser();\n          const message = {\n            _id: messageId,\n            channelId: channelId,\n            body: res.data.url,\n            userId: _.get(currentUser, '_id'),\n            type: \"VideoOrImage\",\n            me: true\n          };\n          this.addMessage(messageId, message);\n        }\n      }).catch(err => {\n        console.log(\"Send files Error: \", err);\n      });\n    }\n  }\n\n  fetchUserChannels() {\n    const userToken = this.getUserTokenId();\n\n    if (userToken) {\n      const options = {\n        headers: {\n          authorization: userToken\n        }\n      };\n      this.service.get(`api/me/channels`, options).then(res => {\n        const channels = res.data;\n\n        _.each(channels, c => {\n          this.realtime.onAddChannel(c);\n        });\n\n        const firstChannelId = _.get(channels, '[0]._id', null);\n\n        this.fetchChannelMessages(firstChannelId);\n      }).catch(err => {\n        console.log(\"An error fetch user channlels\", err);\n      });\n    }\n  }\n\n  addUserToCache(user) {\n    if (!user.avatar) {\n      user.avatar = this.loadUserAvatar(user);\n    }\n\n    const id = _.toString(user._id);\n\n    this.users = this.users.set(id, user);\n    return user;\n  }\n\n  getUserTokenId() {\n    return _.get(this.token, '_id', null);\n  }\n\n  loadUserAvatar(user) {\n    return `useravatars\\\\default_imgSvg_usernDs.svg`;\n  }\n\n  startSearchUsers(q = \"\") {\n    this.search.users = this.search.users.clear(); //query to backend server and get list of users\n\n    const data = {\n      search: q\n    }; //get current user it own\n\n    const currentUser = this.getCurrentUser();\n\n    const currentUserId = _.get(currentUser, '_id'); // if(_.trim(search).length){\n    //    searchItems = users.filter((user) =>_.get(user, '_id') !== currentUserId && _.includes(_.toLower(_.get(user, 'name')), keyword));\n    // }\n\n\n    this.service.post('api/users/search', data).then(res => {\n      //list off users match\n      const users = _.get(res, 'data', []); // console.log(\"Get from server: \", users);\n\n\n      _.each(users, user => {\n        //cache to this.users\n        //add user to this.search.users\n        if (!user.avatar) {\n          user.avatar = this.loadUserAvatar(user);\n        }\n\n        const userId = `${user._id}`;\n\n        if (userId !== currentUserId) {\n          this.users = this.users.set(userId, user);\n          this.search.users = this.search.users.set(userId, user);\n        }\n\n        if (!_.trim(q).length) {\n          this.search.users = new OrderedMap();\n        }\n      });\n\n      this.update();\n    }).catch(err => {\n      console.log(\"Searching Error\", err);\n    });\n  }\n\n  setUserToken(accessToken) {\n    if (!accessToken) {\n      this.localStorage.removeItem('token');\n      this.token = null;\n      return;\n    }\n\n    this.token = accessToken;\n    localStorage.setItem('token', JSON.stringify(accessToken));\n  }\n\n  clearCacheData() {\n    this.channels = this.channels.clear();\n    this.users = this.users.clear();\n    this.messages = this.messages.clear();\n  }\n\n  signOut() {\n    const userId = _.toString(_.get(this.user, '_id', null)); //logout in cache\n\n\n    this.users = this.users.update(userId, user => {\n      if (user) {\n        user.online = false;\n      }\n\n      return user;\n    }); //request server and logout this user\n\n    const tokenId = _.get(this.token, '_id', null);\n\n    this.isConnected();\n    this.user = null;\n    localStorage.removeItem('me');\n    localStorage.removeItem('token');\n\n    if (userId) {\n      this.users = this.users.remove(userId);\n    }\n\n    this.clearCacheData();\n    const options = {\n      headers: {\n        authorization: tokenId\n      }\n    };\n    this.service.get('api/user/logout', options);\n    this.update();\n  }\n\n  getTokenFromLocalStorage() {\n    if (this.token) {\n      return this.token;\n    }\n\n    let token = null;\n    const data = localStorage.getItem('token');\n\n    if (data) {\n      try {\n        token = JSON.parse(data);\n      } catch (err) {\n        console.log(err);\n      }\n    }\n\n    return token;\n  }\n\n  getUserFromLocalStorage() {\n    let user = null;\n    const data = localStorage.getItem('me');\n\n    try {\n      user = JSON.parse(data);\n    } catch (err) {\n      console.log(err);\n    }\n\n    if (user) {\n      //connect to backend server verify this user\n      const token = this.getTokenFromLocalStorage();\n\n      const tokenId = _.get(token, '_id');\n\n      const options = {\n        headers: {\n          authorization: tokenId\n        }\n      };\n      this.service.get('api/users/me', options).then(res => {\n        //user login with token id\n        const accessToken = res.data;\n\n        const user = _.get(accessToken, 'user');\n\n        this.setCurrentUser(user);\n        this.setUserToken(accessToken);\n      }).catch(err => {\n        this.signOut();\n      });\n    }\n\n    return user;\n  }\n\n  setCurrentUser(user) {\n    if (!user.avatar) {\n      user.avatar = this.loadUserAvatar(user);\n    }\n\n    this.user = user;\n\n    if (user) {\n      localStorage.setItem('me', JSON.stringify(user)); //save to local store\n\n      const userId = `${user._id}`;\n      this.users = this.users.set(userId, user);\n    }\n\n    this.update();\n  }\n\n  register(user) {\n    const saltRounds = 10;\n    const password = bcrypt.hashSync(user.password, saltRounds);\n    console.log(\"Email Register is: \", user.email);\n    console.log(\"Password Register is: \", password);\n    return new Promise((resolve, reject) => {\n      this.service.post('api/users', user).then(res => {\n        console.log(\"Account Created \", res.data); // const post = {\n        //     email: email,\n        //     message: message,\n        //     token: captchaToken,\n        //     name: name,\n        // }\n\n        return resolve(res.data);\n      }).catch(err => {\n        const message = _.get(err, 'response.data.error.message', 'Register Error!');\n\n        return reject(message);\n      });\n    });\n  }\n\n  login(email = null, password = null, ipClient = null) {\n    const userEmail = _.toLower(email);\n\n    const user = {\n      email: userEmail,\n      password: password,\n      ipClient: ipClient\n    }; // console.log(\"Logining with: \", user);\n\n    return new Promise((resolve, reject) => {\n      this.service.post('api/users/login', user).then(res => {\n        //     // that mean successful login\n        const accessToken = _.get(res, 'data');\n\n        const user = _.get(accessToken, 'user');\n\n        this.setCurrentUser(user);\n        this.setUserToken(accessToken);\n        this.realtime.connect(); // begin fetch user's channel\n\n        this.fetchUserChannels(); // Call to realtime and connect again to socket server with this user\n      }).catch(err => {\n        // login error\n        const message = _.get(err, 'response.data.error.message', 'Login Error');\n\n        return reject(message);\n      });\n    }); // const _this = this;\n    // return new Promise((resolve, reject) => {\n    //     const user = users.find((user) => user.email === userEmail);\n    //     if( user ) {\n    //         _this.setCurrentUser(user);\n    //     }\n    //     return user ? resolve(user) : reject(\"User not found!\")\n    // });\n  }\n\n  addUserToChannel(channelId, userId) {\n    const channel = this.channels.get(channelId);\n\n    if (channel) {\n      channel.members = channel.members.set(userId, true);\n      this.channels = this.channels.set(channelId, channel);\n      this.update();\n    }\n  }\n\n  getSearchUsers() {\n    // const keyword = _.toLower(search);\n    // let searchItems = new OrderedMap();\n    // const currentUser =this.getCurrentUser();\n    // const currentUserId = _.get(currentUser, '_id');\n    // if(_.trim(search).length){\n    //    searchItems = users.filter((user) =>_.get(user, '_id') !== currentUserId && _.includes(_.toLower(_.get(user, 'name')), keyword));\n    // }\n    return this.search.users.valueSeq();\n  }\n\n  onCreateNewChannel(channel = {}) {\n    const channelId = _.get(channel, \"_id\");\n\n    this.addChannel(channelId, channel);\n    this.setActiveChannelId(channelId);\n  }\n\n  getCurrentUser() {\n    return this.user;\n  }\n\n  fetchChannelMessages(channelId) {\n    let channel = this.channels.get(channelId);\n\n    if (channel && !_.get(channel, 'isFetchMessages')) {\n      const token = _.get(this.token, '_id');\n\n      const options = {\n        headers: {\n          authorization: token\n        }\n      };\n      this.service.get(`api/channels/${channelId}/messages`, options).then(res => {\n        channel.isFetchMessages = true;\n        const messages = res.data;\n\n        _.each(messages, message => {\n          this.realtime.onAddMessage(message);\n        });\n\n        this.channels = this.channels.set(channelId, channel);\n      }).catch(err => {\n        console.log(\"An error fetching channel 's messages\", err);\n      });\n    }\n  }\n\n  isConnected() {\n    return this.realtime.isConnected;\n  }\n\n  setActiveChannelId(id) {\n    this.activeChannelId = id;\n    this.fetchChannelMessages(id);\n    this.update();\n  }\n\n  getActiveChannel() {\n    const channel = this.activeChannelId ? this.channels.get(this.activeChannelId) : this.channels.first();\n    return channel;\n  }\n\n  setMessage(message, notify = false) {\n    const id = _.toString(_.get(message, '_id'));\n\n    this.messages = this.messages.set(id, message);\n\n    const channelId = _.toString(message.channelId);\n\n    const channel = this.channels.get(channelId);\n\n    if (channel) {\n      channel.messages = channel.messages.set(id, true);\n      channel.lastMessage = _.get(message, 'body', '');\n      channel.notify = notify;\n      this.channels = this.channels.set(channelId, channel);\n    } else {\n      // fetch to the server with channel info\n      this.service.get(`api/channels/${channelId}`).then(response => {\n        const channel = _.get(response, 'data');\n        /*const users = _.get(channel, 'users');\r\n        _.each(users, (user) => {\r\n              this.addUserToCache(user);\r\n        });*/\n\n\n        this.realtime.onAddChannel(channel);\n      });\n    }\n\n    this.update();\n  }\n\n  editInfoUser(field, value) {\n    if (value) {\n      const obj = {\n        payload: value,\n        field: field\n      };\n      this.realtime.send({\n        action: 'edit_user',\n        payload: {\n          obj\n        }\n      });\n    }\n\n    this.update();\n  }\n\n  addTyping(channel, typing = false) {\n    if (channel) {\n      const userId = `${_.get(this.user, '_id', null)}`;\n\n      const channelId = _.get(channel, '_id');\n\n      const obj = {\n        channelId: channelId,\n        payload: typing,\n        typier: userId\n      };\n      console.log(\"channel typing: \", channelId);\n      this.realtime.send({\n        action: 'typing_status',\n        payload: {\n          obj\n        }\n      });\n    }\n\n    this.update();\n  }\n\n  addMessage(id, message = {}) {\n    const user = this.getCurrentUser();\n    message.user = user;\n    this.messages = this.messages.set(id, message); //add new message to \n\n    const channelId = _.get(message, 'channelId');\n\n    if (channelId) {\n      let channel = this.channels.get(channelId);\n      channel.lastMessage = _.get(message, 'body', ''); //now i send this channel to the server\n\n      this.realtime.send({\n        action: 'create_channel',\n        payload: channel\n      }); // send to the via websocket to create new message and notify other\n\n      this.realtime.send({\n        action: 'create_message',\n        payload: message\n      });\n      channel.messages = channel.messages.set(id, true);\n      channel.isNew = false;\n      this.channels = this.channels.set(channelId, channel);\n    }\n\n    this.update();\n  }\n\n  removeMemberFromChannel(channel = null, user = null) {\n    if (!channel || !user) {\n      return;\n    }\n\n    const channelId = _.get(channel, '_id');\n\n    const userId = _.get(user, '_id');\n\n    channel.members = channel.members.remove(userId);\n    this.channels = this.channels.set(channelId, channel);\n    this.update();\n  }\n\n  getMessages() {\n    return this.messages.valueSeq();\n  }\n\n  getMessagesFromChannel(channel) {\n    let messages = new OrderedMap();\n\n    if (channel) {\n      channel.messages.forEach((value, key) => {\n        const message = this.messages.get(key);\n        messages = messages.set(key, message);\n      });\n    }\n\n    return messages.valueSeq();\n  }\n\n  getMembersFromChannel(channel) {\n    let members = new OrderedMap();\n\n    if (channel) {\n      channel.members.forEach((value, key) => {\n        const userId = `${key}`;\n        const user = this.users.get(userId); // console.log(\"User from Channel: \", user);\n\n        const loggedUser = this.getCurrentUser();\n\n        if (_.get(loggedUser, '_id') !== _.get(user, '_id')) {\n          members = members.set(key, user);\n        }\n      });\n    }\n\n    return members.valueSeq();\n  }\n\n  addChannel(index, channel = {}) {\n    this.channels = this.channels.set(`${index}`, channel); // console.log(channel);\n    // console.log(\"Mess get from server to client: \", channel);\n\n    this.update();\n  }\n\n  getChannels() {\n    this.channels = this.channels.sort((a, b) => a.updated - b.updated);\n    return this.channels.valueSeq();\n  }\n\n  update() {\n    this.app.forceUpdate();\n  }\n\n}","map":{"version":3,"sources":["C:/myProJects/Server/weatherapp/src/store.js"],"names":["OrderedMap","_","Service","Realtime","moment","ObjectID","bcrypt","axios","Store","constructor","appComponent","app","service","messages","channels","activeChannelId","user","getUserFromLocalStorage","token","getTokenFromLocalStorage","users","realtime","fetchUserChannels","search","editPassword","oldPassword","newPassword","ipClient","userToken","getUserTokenId","contents","options","headers","authorization","Promise","resolve","reject","post","then","res","data","success","console","log","error","currentUser","getCurrentUser","email","get","name","catch","err","message","uploadUserAvatar","formData","editInfoUser","url","editUser","field","value","setThemeToLocalStorage","isDark","localStorage","setItem","getThemeFromLocalStorage","theme","getItem","upLoadfile","messageId","toString","channel","getActiveChannel","channelId","_id","body","userId","type","me","addMessage","each","c","onAddChannel","firstChannelId","fetchChannelMessages","addUserToCache","avatar","loadUserAvatar","id","set","startSearchUsers","q","clear","currentUserId","trim","length","update","setUserToken","accessToken","removeItem","JSON","stringify","clearCacheData","signOut","online","tokenId","isConnected","remove","parse","setCurrentUser","register","saltRounds","password","hashSync","login","userEmail","toLower","connect","addUserToChannel","members","getSearchUsers","valueSeq","onCreateNewChannel","addChannel","setActiveChannelId","isFetchMessages","onAddMessage","first","setMessage","notify","lastMessage","response","obj","payload","send","action","addTyping","typing","typier","isNew","removeMemberFromChannel","getMessages","getMessagesFromChannel","forEach","key","getMembersFromChannel","loggedUser","index","getChannels","sort","a","b","updated","forceUpdate"],"mappings":"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","sourcesContent":["import { OrderedMap } from 'immutable';\r\nimport _ from 'lodash';\r\nimport Service from './service';\r\nimport Realtime from './realtime';\r\nimport moment from \"moment\";\r\nimport {ObjectID} from './helpers/objectid';\r\nimport bcrypt from 'bcryptjs';\r\nimport axios from \"../src/apis/axios\";\r\n\r\nexport default class Store {\r\n    constructor(appComponent){\r\n        this.app = appComponent;\r\n        this.service = new Service();\r\n        this.messages = new OrderedMap();\r\n        this.channels = new OrderedMap();\r\n        this.activeChannelId = null;\r\n\r\n        this.user = this.getUserFromLocalStorage();\r\n        this.token = this.getTokenFromLocalStorage();\r\n        this.users = new OrderedMap();\r\n        this.realtime = new Realtime(this);\r\n        this.fetchUserChannels();\r\n        this.search = {\r\n            users: new OrderedMap(),\r\n        }\r\n    }\r\n\r\n    editPassword(oldPassword, newPassword, ipClient){\r\n\r\n        const userToken = this.getUserTokenId();\r\n        const contents = {\r\n            oldPassword: oldPassword,\r\n            newPassword: newPassword\r\n        }\r\n        if(userToken){\r\n            const options = {\r\n                headers: {\r\n                    authorization: userToken,\r\n                }\r\n            }\r\n\r\n            return new Promise((resolve, reject) => {\r\n                // console.log(contents);\r\n                this.service.post('api/user/editpassword', contents, options).then((res) => {\r\n                    //soon add code process\r\n                    if(!res.data.success){\r\n                        console.log(res.data.error)\r\n                    }\r\n                    const currentUser =this.getCurrentUser();\r\n                    const email = _.get(currentUser, 'email', '');\r\n                    const name = _.get(currentUser, 'name', '')\r\n                    const post = {\r\n                        email: email,\r\n                        name: name,\r\n                        ipClient: ipClient\r\n                    }\r\n                    console.log(post);\r\n                    // await axios\r\n                    // .post('/ndsapi/announce/changeinfouser', post)\r\n                    // .then(function(response) {\r\n                    //     console.log(\"Successful\");\r\n                    // }).catch(err => console.log(err))\r\n\r\n                    return resolve(currentUser)\r\n\r\n\r\n                }).catch((err) => {\r\n                    const message = _.get(err, 'response.data.error.message', 'Changeing Password Error!');\r\n                    return reject(message);\r\n                });\r\n            })\r\n\r\n        }\r\n    }\r\n\r\n    uploadUserAvatar(formData){\r\n        const userToken = this.getUserTokenId();\r\n\r\n        if(userToken){\r\n            const options = {\r\n                headers: {\r\n                    authorization: userToken,\r\n                }\r\n            }\r\n\r\n            this.service.post('api/user/uploadavatar', formData, options).then((res) => {\r\n\r\n                // console.log(res.data.success);\r\n                if(!res.data.success){\r\n                    console.log(res.data.error)\r\n                }\r\n                if (res.data.success) {\r\n                    this.editInfoUser('avatar', res.data.url )\r\n                }\r\n\r\n            }).catch((err) => {\r\n                console.log(\"Send Error: \", err);\r\n            });\r\n        }\r\n    }\r\n    editUser(field, value){\r\n        if(value){\r\n            console.log(field, value , typeof(value));\r\n            this.editInfoUser(field, value);\r\n        }\r\n        \r\n    }\r\n    setThemeToLocalStorage(isDark = false ){\r\n\r\n        console.log(\"Select theme Dark: \", isDark);\r\n        localStorage.setItem('themeOfChat', isDark);\r\n       \r\n    }\r\n    getThemeFromLocalStorage(){\r\n        let theme = null;\r\n        const data = localStorage.getItem('themeOfChat');\r\n        if(data){\r\n            try{\r\n                theme = data;\r\n            }\r\n            catch (err){\r\n                console.log(err);\r\n            }\r\n        }\r\n        console.log(\"Get theme Dark from localStorage: \", theme);\r\n        return theme;\r\n    }\r\n\r\n    upLoadfile(formData){\r\n        const userToken = this.getUserTokenId();\r\n        console.log('File wav get in store: ',formData);\r\n        if(userToken){\r\n\r\n            this.service.post('api/messages/uploadfiles', formData).then((res) => {\r\n\r\n                console.log(res.data.success);\r\n                if(!res.data.success){\r\n                    console.log(res.data.error)\r\n                }\r\n                if (res.data.success) {\r\n                    const messageId = new ObjectID().toString();\r\n                    const channel = this.getActiveChannel();\r\n                    const channelId = _.get(channel , '_id', null);\r\n                    const currentUser = this.getCurrentUser();\r\n                    const message = {\r\n                        _id: messageId,\r\n                        channelId: channelId,\r\n                        body : res.data.url,\r\n                        userId: _.get(currentUser, '_id'),\r\n                        type:\"VideoOrImage\",\r\n                        me: true,\r\n                };\r\n                this.addMessage(messageId, message);\r\n\r\n            }\r\n            }).catch((err) => {\r\n                console.log(\"Send files Error: \", err);\r\n            });\r\n        }\r\n    }\r\n    fetchUserChannels(){\r\n        const userToken =this.getUserTokenId();\r\n        if(userToken){\r\n            const options = {\r\n                headers: {\r\n                    authorization: userToken,\r\n                }\r\n            }\r\n            this.service.get(`api/me/channels`, options).then((res) => {\r\n                const channels = res.data;\r\n                _.each(channels, (c) => {\r\n                    this.realtime.onAddChannel(c);\r\n                });\r\n\r\n                const firstChannelId = _.get(channels, '[0]._id', null);\r\n                this.fetchChannelMessages(firstChannelId);\r\n            }).catch((err) => {\r\n\r\n                console.log(\"An error fetch user channlels\", err);\r\n            })\r\n        }\r\n    }\r\n    addUserToCache(user){\r\n        if(!user.avatar){\r\n            user.avatar = this.loadUserAvatar(user);\r\n        }\r\n        const id = _.toString(user._id);\r\n        this.users = this.users.set(id, user);\r\n        return user;\r\n    }\r\n\r\n    getUserTokenId(){\r\n        return _.get(this.token, '_id', null);\r\n    }\r\n    loadUserAvatar(user){\r\n\r\n            return `useravatars\\\\default_imgSvg_usernDs.svg`\r\n       \r\n    }\r\n    startSearchUsers(q = \"\"){\r\n        this.search.users = this.search.users.clear();\r\n        //query to backend server and get list of users\r\n        const data = {search : q};\r\n        //get current user it own\r\n        const currentUser =this.getCurrentUser();\r\n        const currentUserId = _.get(currentUser, '_id');\r\n       \r\n        // if(_.trim(search).length){\r\n        //    searchItems = users.filter((user) =>_.get(user, '_id') !== currentUserId && _.includes(_.toLower(_.get(user, 'name')), keyword));\r\n        // }\r\n        this.service.post('api/users/search', data).then((res) => {\r\n            //list off users match\r\n            const users = _.get(res, 'data', []);\r\n            // console.log(\"Get from server: \", users);\r\n            _.each(users, (user) => {\r\n               //cache to this.users\r\n               //add user to this.search.users\r\n                if(!user.avatar){\r\n                    user.avatar = this.loadUserAvatar(user);\r\n                }\r\n                const userId = `${user._id}`;\r\n                if(userId !== currentUserId){\r\n                    this.users = this.users.set(userId, user);\r\n                    this.search.users = this.search.users.set(userId, user);\r\n                }\r\n                 if(!_.trim(q).length){\r\n                    this.search.users = new OrderedMap();\r\n                }\r\n           });\r\n           this.update();\r\n\r\n        }).catch((err) => {\r\n            console.log(\"Searching Error\", err);\r\n        }); \r\n    }\r\n\r\n\r\n    setUserToken(accessToken){\r\n        if(!accessToken){\r\n            this.localStorage.removeItem('token');\r\n            this.token = null;\r\n            return;\r\n        }\r\n        this.token = accessToken;\r\n        localStorage.setItem('token', JSON.stringify(accessToken));\r\n    }\r\n    clearCacheData(){\r\n        this.channels = this.channels.clear();\r\n        this.users = this.users.clear();\r\n        this.messages = this.messages.clear();\r\n    }\r\n    signOut(){\r\n\r\n        const userId = _.toString(_.get(this.user, '_id', null));\r\n        //logout in cache\r\n        this.users = this.users.update(userId, (user) => {\r\n            if(user) {\r\n                user.online = false;\r\n            }\r\n            return user;\r\n        })\r\n        //request server and logout this user\r\n        const tokenId = _.get(this.token, '_id', null);\r\n        this.isConnected();\r\n        this.user = null;\r\n        localStorage.removeItem('me');\r\n        localStorage.removeItem('token');\r\n        if(userId){\r\n            this.users = this.users.remove(userId);\r\n        }\r\n        this.clearCacheData();\r\n        const options = {\r\n            headers : {\r\n                authorization: tokenId\r\n            }\r\n        }\r\n        this.service.get('api/user/logout', options);\r\n   \r\n        this.update();\r\n    }\r\n\r\n    getTokenFromLocalStorage(){\r\n\r\n        if(this.token){\r\n            return this.token;\r\n        }\r\n\r\n        let token = null;\r\n        const data = localStorage.getItem('token');\r\n        if(data){\r\n            try{\r\n                token = JSON.parse(data);\r\n            }\r\n            catch (err){\r\n                console.log(err);\r\n            }\r\n            \r\n        }\r\n        return token;\r\n    }\r\n\r\n    getUserFromLocalStorage(){\r\n\r\n        let user = null;\r\n        const data = localStorage.getItem('me');\r\n         try {\r\n                user = JSON.parse(data);\r\n         }\r\n         catch(err) {\r\n             console.log(err);\r\n         }\r\n         if(user){\r\n            //connect to backend server verify this user\r\n            const token = this.getTokenFromLocalStorage();\r\n            const tokenId = _.get(token, '_id');\r\n            const options = {\r\n                headers: {\r\n                    authorization: tokenId,\r\n                }\r\n            }\r\n            \r\n            this.service.get('api/users/me', options).then((res) => {\r\n                //user login with token id\r\n                const accessToken = res.data;\r\n                const user = _.get(accessToken, 'user');\r\n\r\n                this.setCurrentUser(user);\r\n                this.setUserToken(accessToken);\r\n\r\n            }).catch(err => {\r\n                this.signOut();\r\n            });\r\n        }\r\n\r\n         return user;\r\n    }    \r\n        \r\n    \r\n    setCurrentUser(user){\r\n        if(!user.avatar){\r\n            user.avatar = this.loadUserAvatar(user);\r\n        }\r\n        this.user = user;\r\n        if(user){\r\n            \r\n            localStorage.setItem('me', JSON.stringify(user));\r\n            //save to local store\r\n            const userId =`${user._id}`;\r\n            this.users = this.users.set(userId, user);\r\n\r\n        }\r\n        this.update();\r\n    }\r\n\r\n    register(user){\r\n        const saltRounds = 10;\r\n        const password = bcrypt.hashSync(user.password, saltRounds);\r\n        console.log(\"Email Register is: \", user.email);\r\n        console.log(\"Password Register is: \", password);\r\n        return new Promise((resolve, reject) => {\r\n            this.service.post('api/users', user).then((res) =>{\r\n\r\n                console.log(\"Account Created \", res.data);\r\n\r\n                // const post = {\r\n                //     email: email,\r\n                //     message: message,\r\n                //     token: captchaToken,\r\n                //     name: name,\r\n                // }\r\n\r\n                return resolve(res.data);\r\n                \r\n            }).catch((err) => {\r\n                const message = _.get(err, 'response.data.error.message', 'Register Error!');\r\n                return reject(message);\r\n            });\r\n        })\r\n\r\n    }\r\n \r\n\r\n   \r\n\r\n    login(email = null, password = null, ipClient = null){\r\n        const userEmail = _.toLower(email);\r\n\r\n        const user = {\r\n            email: userEmail,\r\n            password: password,\r\n            ipClient: ipClient,\r\n        }\r\n\r\n        // console.log(\"Logining with: \", user);\r\n        return new Promise((resolve, reject) => {\r\n\r\n            this.service.post('api/users/login', user).then((res) => {\r\n            //     // that mean successful login\r\n                const accessToken = _.get(res, 'data'); \r\n                const user = _.get(accessToken, 'user');\r\n\r\n                this.setCurrentUser(user);\r\n                this.setUserToken(accessToken);\r\n                this.realtime.connect();\r\n\r\n                // begin fetch user's channel\r\n                this.fetchUserChannels();\r\n                // Call to realtime and connect again to socket server with this user\r\n\r\n            }).catch((err) => {\r\n                // login error\r\n                const message = _.get(err, 'response.data.error.message', 'Login Error');\r\n                return reject(message);\r\n            })\r\n\r\n        });\r\n        // const _this = this;\r\n        // return new Promise((resolve, reject) => {\r\n        //     const user = users.find((user) => user.email === userEmail);\r\n        //     if( user ) {\r\n        //         _this.setCurrentUser(user);\r\n        //     }\r\n        //     return user ? resolve(user) : reject(\"User not found!\")\r\n        // });\r\n    }\r\n\r\n    addUserToChannel(channelId, userId) {\r\n        const channel = this.channels.get(channelId);\r\n        if(channel) {\r\n            channel.members = channel.members.set(userId, true);\r\n            this.channels = this.channels.set(channelId, channel);\r\n            this.update();\r\n        }\r\n      \r\n    }\r\n    getSearchUsers(){\r\n        // const keyword = _.toLower(search);\r\n\r\n        // let searchItems = new OrderedMap();\r\n        // const currentUser =this.getCurrentUser();\r\n        // const currentUserId = _.get(currentUser, '_id');\r\n       \r\n        // if(_.trim(search).length){\r\n        //    searchItems = users.filter((user) =>_.get(user, '_id') !== currentUserId && _.includes(_.toLower(_.get(user, 'name')), keyword));\r\n        // }\r\n\r\n        return this.search.users.valueSeq();\r\n    }\r\n\r\n    onCreateNewChannel(channel = {}){\r\n        const channelId = _.get(channel, \"_id\");\r\n        this.addChannel(channelId, channel );\r\n        this.setActiveChannelId(channelId);\r\n    \r\n    }\r\n\r\n    getCurrentUser(){\r\n        return this.user;\r\n    }\r\n\r\n    fetchChannelMessages(channelId){\r\n\r\n        let channel = this.channels.get(channelId);\r\n            if( channel && !_.get(channel, 'isFetchMessages')){\r\n\r\n                const token = _.get(this.token, '_id');\r\n                const options = {\r\n                    headers: {\r\n                        authorization: token,\r\n                    }\r\n                }\r\n\r\n                this.service.get(`api/channels/${channelId}/messages`, options).then((res) => {\r\n                    channel.isFetchMessages = true;\r\n\r\n                    const messages = res.data;\r\n                \r\n                    _.each(messages, (message) => {\r\n                        this.realtime.onAddMessage(message);\r\n                    });\r\n                    this.channels = this.channels.set(channelId, channel);\r\n\r\n                }).catch((err) => {\r\n                    console.log(\"An error fetching channel 's messages\", err);\r\n\r\n                }\r\n            )}\r\n        }   \r\n    \r\n\r\n    isConnected(){\r\n        return this.realtime.isConnected;\r\n    }\r\n\r\n    setActiveChannelId(id) {\r\n        this.activeChannelId = id;\r\n        this.fetchChannelMessages(id);\r\n        this.update();\r\n    }\r\n    getActiveChannel(){\r\n        const channel = this.activeChannelId ? this.channels.get(this.activeChannelId) : this.channels.first();\r\n        return channel;\r\n    }\r\n\r\n    setMessage(message, notify = false){\r\n        const id = _.toString(_.get(message, '_id'));\r\n        this.messages = this.messages.set(id, message);\r\n        const channelId = _.toString(message.channelId);\r\n        const channel = this.channels.get(channelId);\r\n\r\n        if (channel) {\r\n            channel.messages = channel.messages.set(id, true);\r\n            channel.lastMessage = _.get(message, 'body', '');\r\n            channel.notify = notify;\r\n\r\n            this.channels = this.channels.set(channelId, channel);\r\n        } else {\r\n\r\n            // fetch to the server with channel info\r\n            this.service.get(`api/channels/${channelId}`).then((response) => {\r\n\r\n\r\n                const channel = _.get(response, 'data');\r\n\r\n                /*const users = _.get(channel, 'users');\r\n                _.each(users, (user) => {\r\n\r\n                    this.addUserToCache(user);\r\n                });*/\r\n\r\n                this.realtime.onAddChannel(channel);\r\n\r\n\r\n            })\r\n        }\r\n        this.update();\r\n    }\r\n    editInfoUser(field, value){\r\n        if(value){\r\n\r\n        const obj = {\r\n            payload: value,\r\n            field: field,\r\n        }\r\n            this.realtime.send(\r\n                {\r\n                    action: 'edit_user',\r\n                    payload: {obj},\r\n                }\r\n            );\r\n        }\r\n    this.update();\r\n    }\r\n\r\n    addTyping(channel, typing = false){\r\n        \r\n        if(channel){\r\n            const userId = `${_.get(this.user, '_id', null)}`;\r\n            const channelId = _.get(channel, '_id');\r\n            const obj = {\r\n                channelId: channelId,\r\n                payload: typing,\r\n                typier: userId,\r\n            }\r\n            console.log(\"channel typing: \", channelId);\r\n            this.realtime.send(\r\n                {\r\n                    action: 'typing_status',\r\n                    payload: {obj},\r\n                }\r\n            );\r\n        }\r\n        this.update();\r\n    }\r\n\r\n    addMessage(id, message = {}){\r\n\r\n        const user = this.getCurrentUser();\r\n        message.user = user;\r\n        this.messages = this.messages.set(id, message);\r\n        //add new message to \r\n        const channelId = _.get(message, 'channelId');\r\n        if(channelId){\r\n\r\n            \r\n            let channel = this.channels.get(channelId);\r\n\r\n            channel.lastMessage = _.get(message, 'body', '');\r\n            //now i send this channel to the server\r\n            \r\n           this.realtime.send(\r\n               {\r\n                    action: 'create_channel',\r\n                    payload: channel,\r\n                }\r\n            );\r\n            // send to the via websocket to create new message and notify other\r\n            this.realtime.send(\r\n                {\r\n                    action: 'create_message',\r\n                    payload: message,\r\n                }\r\n            );\r\n\r\n            channel.messages = channel.messages.set(id, true);\r\n\r\n\r\n            channel.isNew = false;\r\n            this.channels = this.channels.set(channelId, channel);\r\n        }\r\n        this.update();\r\n    }\r\n\r\n    removeMemberFromChannel( channel = null, user = null){\r\n        if(!channel || !user ){\r\n            return;\r\n        }\r\n        const channelId = _.get(channel, '_id')\r\n        const userId = _.get(user, '_id');\r\n        channel.members = channel.members.remove(userId);\r\n        this.channels = this.channels.set(channelId, channel);\r\n        this.update();\r\n    }\r\n\r\n    getMessages(){\r\n        return this.messages.valueSeq();\r\n    }\r\n    getMessagesFromChannel(channel){\r\n        let messages = new OrderedMap();\r\n\r\n        if(channel){\r\n            channel.messages.forEach((value, key) => {\r\n\r\n                const message = this.messages.get(key);\r\n                messages = messages.set( key, message);\r\n    \r\n            });\r\n        }\r\n        return messages.valueSeq();\r\n        \r\n    }\r\n\r\n    getMembersFromChannel(channel){\r\n        let members = new OrderedMap();\r\n        if(channel){\r\n            channel.members.forEach((value, key) => {\r\n\r\n                const userId = `${key}`\r\n                const user = this.users.get(userId);\r\n                // console.log(\"User from Channel: \", user);\r\n                const loggedUser = this.getCurrentUser();\r\n                if( _.get(loggedUser, '_id') !== _.get(user, '_id')){\r\n                    members = members.set(key, user);\r\n                   \r\n                }\r\n            });\r\n               \r\n        }\r\n        return members.valueSeq();\r\n    }\r\n\r\n\r\n    addChannel(index, channel = {}){\r\n        this.channels = this.channels.set(`${index}`, channel);\r\n        // console.log(channel);\r\n        // console.log(\"Mess get from server to client: \", channel);\r\n        this.update();\r\n    }\r\n\r\n    getChannels(){\r\n        this.channels = this.channels.sort((a, b) => a.updated - b.updated);\r\n        return this.channels.valueSeq();\r\n    }\r\n    update(){\r\n        this.app.forceUpdate();\r\n    }\r\n}\r\n\r\n"]},"metadata":{},"sourceType":"module"}