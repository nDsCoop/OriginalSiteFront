{"ast":null,"code":"import { OrderedMap } from \"immutable\";\nimport _ from 'lodash';\nexport default class Realtime {\n  constructor(store) {\n    this.store = store;\n    this.ws = null;\n    this.isConnected = false;\n    this.connect();\n  }\n\n  decoMessage(msg) {\n    let message = {};\n\n    try {\n      message = JSON.parse(msg);\n    } catch (err) {\n      console.log(err);\n    }\n\n    return message;\n  }\n\n  readMessage(msg) {\n    const store = this.store;\n    const currentUser = store.getCurrentUser();\n\n    const currentUserId = _.toString(_.get(currentUser, '_id'));\n\n    const message = this.decoMessage(msg);\n\n    const action = _.get(message, 'action');\n\n    const payload = _.get(message, 'payload');\n\n    switch (action) {\n      case 'message_added':\n        const activeChannel = store.getActiveChannel();\n\n        let notify = _.get(activeChannel, '_id' !== _.get(payload, 'channelId')) && currentUserId !== _.get(payload, 'userId');\n\n        this.onAddMessage(payload, notify);\n        break;\n\n      default:\n        break;\n\n      case 'channel_added':\n        //to do check payload and insert new channel\n        this.onAddChannel(payload);\n        break;\n    }\n  }\n\n  onAddMessage(payload, notify = false) {\n    let user = _.get(payload, 'user'); //add user to cache\n\n\n    user = store.addUserToCache(user);\n    const messageObject = {\n      _id: payload._id,\n      body: _.get(payload, 'body', ''),\n      userId: _.get(payload, 'userId'),\n      channelId: _.get(payload, 'channelId'),\n      created: _.get(payload, 'created', new Date()),\n      me: currentUserId === _.toString(_.get(payload, 'userId')),\n      user: user\n    };\n    console.log(\"Mess listen from fetch: \", messageObject);\n    store.setMessage(messageObject, notify);\n  }\n\n  onAddChannel(payload) {\n    const store = this.store;\n    const channelId = `${payload._id}`;\n    const userId = `${payload.userId}`;\n\n    const users = _.get(payload, 'users', []);\n\n    let channel = {\n      _id: channelId,\n      title: _.get(payload, 'title', ''),\n      lastMessage: _.get(payload, 'lastMessage', ''),\n      members: new OrderedMap(),\n      messages: new OrderedMap(),\n      isNew: false,\n      userId: userId,\n      created: new Date()\n    };\n\n    _.each(users, user => {\n      //add this user to store.users collection\n      const memberId = `${user._id}`;\n      this.store.addUserToCache(user);\n      channel.members = channel.members.set(memberId, true);\n    });\n\n    const channelMessages = store.messages.filter(m => _.toString(m.channelId) === channelId);\n    channelMessages.forEach(msg => {\n      const msgId = _.toString(_.get(msg, '_id'));\n\n      channel.messages = channel.messages.set(msgId, true);\n    });\n    store.addChannel(channelId, channel);\n  }\n\n  send(msg = {}) {\n    const isConnected = this.isConnected;\n\n    if (isConnected) {\n      const msgString = JSON.stringify(msg);\n      this.ws.send(msgString);\n    }\n  }\n\n  authentication() {\n    const store = this.store;\n    const tokenId = store.getUserTokenId();\n    const message = {\n      action: 'auth',\n      payload: `${tokenId}`\n    };\n    this.send(message);\n  }\n\n  connect() {\n    const ws = new WebSocket('ws://localhost:8080');\n    this.ws = ws;\n\n    ws.onopen = () => {\n      //tell to server who are you ?\n      this.isConnected = true;\n      this.authentication();\n\n      ws.onmessage = e => {\n        this.readMessage(_.get(e, 'data', ''));\n        console.log(\"Message from server: \", e.data);\n      };\n    };\n\n    ws.onclose = () => {\n      this.isConnected = false; //\n    };\n  }\n\n}","map":{"version":3,"sources":["C:/myProJects/Server/weatherapp/src/realtime.js"],"names":["OrderedMap","_","Realtime","constructor","store","ws","isConnected","connect","decoMessage","msg","message","JSON","parse","err","console","log","readMessage","currentUser","getCurrentUser","currentUserId","toString","get","action","payload","activeChannel","getActiveChannel","notify","onAddMessage","onAddChannel","user","addUserToCache","messageObject","_id","body","userId","channelId","created","Date","me","setMessage","users","channel","title","lastMessage","members","messages","isNew","each","memberId","set","channelMessages","filter","m","forEach","msgId","addChannel","send","msgString","stringify","authentication","tokenId","getUserTokenId","WebSocket","onopen","onmessage","e","data","onclose"],"mappings":"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","sourcesContent":["import { OrderedMap } from \"immutable\";\r\nimport _ from 'lodash';\r\n\r\nexport default class Realtime{\r\n\r\n    constructor(store){\r\n        this.store = store;\r\n        this.ws = null;\r\n        this.isConnected = false;\r\n        this.connect();\r\n\r\n    }\r\n    decoMessage(msg){\r\n        let message = {};\r\n        try{\r\n            message = JSON.parse(msg);\r\n        }\r\n        catch(err){\r\n            console.log(err)\r\n        }\r\n        return message;\r\n    }\r\n    readMessage(msg){\r\n        const store = this.store;\r\n        const currentUser = store.getCurrentUser();\r\n        const currentUserId = _.toString(_.get(currentUser, '_id'));\r\n        const message = this.decoMessage(msg);\r\n        const action = _.get(message, 'action');\r\n        const payload = _.get(message, 'payload');\r\n\r\n        switch(action){\r\n            case 'message_added':\r\n                \r\n                const activeChannel = store.getActiveChannel();\r\n                let notify = _.get(activeChannel, '_id' !== _.get(payload, 'channelId')) && currentUserId !== _.get(payload, 'userId');\r\n                this.onAddMessage(payload, notify);\r\n            break;\r\n            default:\r\n                break;\r\n            case 'channel_added':\r\n                //to do check payload and insert new channel\r\n                this.onAddChannel(payload);\r\n                break;\r\n        }\r\n    }\r\n    onAddMessage(payload, notify = false){\r\n        let user = _.get(payload, 'user');\r\n\r\n\r\n        //add user to cache\r\n        user = store.addUserToCache(user);\r\n\r\n        const messageObject = {\r\n            _id: payload._id,\r\n            body: _.get(payload, 'body', ''),\r\n            userId: _.get(payload, 'userId'),\r\n            channelId: _.get(payload, 'channelId'),\r\n            created: _.get(payload, 'created', new Date()),\r\n            me: currentUserId === _.toString(_.get(payload, 'userId')),\r\n            user: user,\r\n        };\r\n        console.log(\"Mess listen from fetch: \", messageObject);\r\n        store.setMessage(messageObject, notify);\r\n\r\n    }\r\n\r\n    onAddChannel(payload){\r\n        const store = this.store;\r\n        const channelId = `${payload._id}`;\r\n        const userId = `${payload.userId}`;\r\n        const users = _.get(payload, 'users', []);\r\n        let channel = { \r\n            \r\n            _id:channelId,  \r\n            title: _.get(payload, 'title', '' ),\r\n            lastMessage: _.get(payload, 'lastMessage', ''),\r\n            members: new OrderedMap(),\r\n            messages: new OrderedMap(),\r\n            isNew: false,\r\n            userId: userId,\r\n            created: new Date(),\r\n\r\n        };\r\n        _.each(users, (user) => {\r\n            //add this user to store.users collection\r\n            const memberId = `${user._id}`;\r\n            this.store.addUserToCache(user);\r\n            channel.members = channel.members.set(memberId, true);\r\n        });\r\n        const channelMessages = store.messages.filter((m) => _.toString(m.channelId) === channelId);\r\n        channelMessages.forEach((msg) => {\r\n            const msgId = _.toString(_.get(msg, '_id'));\r\n            channel.messages = channel.messages.set(msgId, true);\r\n        })\r\n        store.addChannel(channelId, channel);\r\n    }\r\n    send( msg = {}){\r\n        const isConnected = this.isConnected;\r\n        if(isConnected){\r\n            const msgString = JSON.stringify(msg);\r\n            this.ws.send(msgString);\r\n        }\r\n    }\r\n    authentication(){\r\n        const store = this.store;\r\n        const tokenId = store.getUserTokenId();\r\n        const message = {\r\n            action: 'auth',\r\n            payload: `${tokenId}`\r\n        }\r\n            this.send(message);\r\n    }\r\n\r\n    connect(){\r\n\r\n        const ws = new WebSocket('ws://localhost:8080');\r\n        this.ws = ws;\r\n        ws.onopen = () => {\r\n            //tell to server who are you ?\r\n            this.isConnected = true;\r\n            this.authentication();\r\n            \r\n            ws.onmessage = (e) => {\r\n                this.readMessage(_.get(e, 'data',''));\r\n                console.log(\"Message from server: \", e.data);\r\n            }\r\n        }\r\n        ws.onclose = () => {\r\n            this.isConnected = false;\r\n            //\r\n        }\r\n    }\r\n}"]},"metadata":{},"sourceType":"module"}