{"ast":null,"code":"/**\n * Copyright 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n */\n'use strict';\n\nvar EventPluginHub = require('./EventPluginHub');\n\nvar EventPropagators = require('./EventPropagators');\n\nvar ExecutionEnvironment = require('fbjs/lib/ExecutionEnvironment');\n\nvar ReactDOMComponentTree = require('./ReactDOMComponentTree');\n\nvar ReactUpdates = require('./ReactUpdates');\n\nvar SyntheticEvent = require('./SyntheticEvent');\n\nvar getEventTarget = require('./getEventTarget');\n\nvar isEventSupported = require('./isEventSupported');\n\nvar isTextInputElement = require('./isTextInputElement');\n\nvar eventTypes = {\n  change: {\n    phasedRegistrationNames: {\n      bubbled: 'onChange',\n      captured: 'onChangeCapture'\n    },\n    dependencies: ['topBlur', 'topChange', 'topClick', 'topFocus', 'topInput', 'topKeyDown', 'topKeyUp', 'topSelectionChange']\n  }\n};\n/**\n * For IE shims\n */\n\nvar activeElement = null;\nvar activeElementInst = null;\nvar activeElementValue = null;\nvar activeElementValueProp = null;\n/**\n * SECTION: handle `change` event\n */\n\nfunction shouldUseChangeEvent(elem) {\n  var nodeName = elem.nodeName && elem.nodeName.toLowerCase();\n  return nodeName === 'select' || nodeName === 'input' && elem.type === 'file';\n}\n\nvar doesChangeEventBubble = false;\n\nif (ExecutionEnvironment.canUseDOM) {\n  // See `handleChange` comment below\n  doesChangeEventBubble = isEventSupported('change') && (!document.documentMode || document.documentMode > 8);\n}\n\nfunction manualDispatchChangeEvent(nativeEvent) {\n  var event = SyntheticEvent.getPooled(eventTypes.change, activeElementInst, nativeEvent, getEventTarget(nativeEvent));\n  EventPropagators.accumulateTwoPhaseDispatches(event); // If change and propertychange bubbled, we'd just bind to it like all the\n  // other events and have it go through ReactBrowserEventEmitter. Since it\n  // doesn't, we manually listen for the events and so we have to enqueue and\n  // process the abstract event manually.\n  //\n  // Batching is necessary here in order to ensure that all event handlers run\n  // before the next rerender (including event handlers attached to ancestor\n  // elements instead of directly on the input). Without this, controlled\n  // components don't work properly in conjunction with event bubbling because\n  // the component is rerendered and the value reverted before all the event\n  // handlers can run. See https://github.com/facebook/react/issues/708.\n\n  ReactUpdates.batchedUpdates(runEventInBatch, event);\n}\n\nfunction runEventInBatch(event) {\n  EventPluginHub.enqueueEvents(event);\n  EventPluginHub.processEventQueue(false);\n}\n\nfunction startWatchingForChangeEventIE8(target, targetInst) {\n  activeElement = target;\n  activeElementInst = targetInst;\n  activeElement.attachEvent('onchange', manualDispatchChangeEvent);\n}\n\nfunction stopWatchingForChangeEventIE8() {\n  if (!activeElement) {\n    return;\n  }\n\n  activeElement.detachEvent('onchange', manualDispatchChangeEvent);\n  activeElement = null;\n  activeElementInst = null;\n}\n\nfunction getTargetInstForChangeEvent(topLevelType, targetInst) {\n  if (topLevelType === 'topChange') {\n    return targetInst;\n  }\n}\n\nfunction handleEventsForChangeEventIE8(topLevelType, target, targetInst) {\n  if (topLevelType === 'topFocus') {\n    // stopWatching() should be a noop here but we call it just in case we\n    // missed a blur event somehow.\n    stopWatchingForChangeEventIE8();\n    startWatchingForChangeEventIE8(target, targetInst);\n  } else if (topLevelType === 'topBlur') {\n    stopWatchingForChangeEventIE8();\n  }\n}\n/**\n * SECTION: handle `input` event\n */\n\n\nvar isInputEventSupported = false;\n\nif (ExecutionEnvironment.canUseDOM) {\n  // IE9 claims to support the input event but fails to trigger it when\n  // deleting text, so we ignore its input events.\n  // IE10+ fire input events to often, such when a placeholder\n  // changes or when an input with a placeholder is focused.\n  isInputEventSupported = isEventSupported('input') && (!document.documentMode || document.documentMode > 11);\n}\n/**\n * (For IE <=11) Replacement getter/setter for the `value` property that gets\n * set on the active element.\n */\n\n\nvar newValueProp = {\n  get: function () {\n    return activeElementValueProp.get.call(this);\n  },\n  set: function (val) {\n    // Cast to a string so we can do equality checks.\n    activeElementValue = '' + val;\n    activeElementValueProp.set.call(this, val);\n  }\n};\n/**\n * (For IE <=11) Starts tracking propertychange events on the passed-in element\n * and override the value property so that we can distinguish user events from\n * value changes in JS.\n */\n\nfunction startWatchingForValueChange(target, targetInst) {\n  activeElement = target;\n  activeElementInst = targetInst;\n  activeElementValue = target.value;\n  activeElementValueProp = Object.getOwnPropertyDescriptor(target.constructor.prototype, 'value'); // Not guarded in a canDefineProperty check: IE8 supports defineProperty only\n  // on DOM elements\n\n  Object.defineProperty(activeElement, 'value', newValueProp);\n\n  if (activeElement.attachEvent) {\n    activeElement.attachEvent('onpropertychange', handlePropertyChange);\n  } else {\n    activeElement.addEventListener('propertychange', handlePropertyChange, false);\n  }\n}\n/**\n * (For IE <=11) Removes the event listeners from the currently-tracked element,\n * if any exists.\n */\n\n\nfunction stopWatchingForValueChange() {\n  if (!activeElement) {\n    return;\n  } // delete restores the original property definition\n\n\n  delete activeElement.value;\n\n  if (activeElement.detachEvent) {\n    activeElement.detachEvent('onpropertychange', handlePropertyChange);\n  } else {\n    activeElement.removeEventListener('propertychange', handlePropertyChange, false);\n  }\n\n  activeElement = null;\n  activeElementInst = null;\n  activeElementValue = null;\n  activeElementValueProp = null;\n}\n/**\n * (For IE <=11) Handles a propertychange event, sending a `change` event if\n * the value of the active element has changed.\n */\n\n\nfunction handlePropertyChange(nativeEvent) {\n  if (nativeEvent.propertyName !== 'value') {\n    return;\n  }\n\n  var value = nativeEvent.srcElement.value;\n\n  if (value === activeElementValue) {\n    return;\n  }\n\n  activeElementValue = value;\n  manualDispatchChangeEvent(nativeEvent);\n}\n/**\n * If a `change` event should be fired, returns the target's ID.\n */\n\n\nfunction getTargetInstForInputEvent(topLevelType, targetInst) {\n  if (topLevelType === 'topInput') {\n    // In modern browsers (i.e., not IE8 or IE9), the input event is exactly\n    // what we want so fall through here and trigger an abstract event\n    return targetInst;\n  }\n}\n\nfunction handleEventsForInputEventIE(topLevelType, target, targetInst) {\n  if (topLevelType === 'topFocus') {\n    // In IE8, we can capture almost all .value changes by adding a\n    // propertychange handler and looking for events with propertyName\n    // equal to 'value'\n    // In IE9-11, propertychange fires for most input events but is buggy and\n    // doesn't fire when text is deleted, but conveniently, selectionchange\n    // appears to fire in all of the remaining cases so we catch those and\n    // forward the event if the value has changed\n    // In either case, we don't want to call the event handler if the value\n    // is changed from JS so we redefine a setter for `.value` that updates\n    // our activeElementValue variable, allowing us to ignore those changes\n    //\n    // stopWatching() should be a noop here but we call it just in case we\n    // missed a blur event somehow.\n    stopWatchingForValueChange();\n    startWatchingForValueChange(target, targetInst);\n  } else if (topLevelType === 'topBlur') {\n    stopWatchingForValueChange();\n  }\n} // For IE8 and IE9.\n\n\nfunction getTargetInstForInputEventIE(topLevelType, targetInst) {\n  if (topLevelType === 'topSelectionChange' || topLevelType === 'topKeyUp' || topLevelType === 'topKeyDown') {\n    // On the selectionchange event, the target is just document which isn't\n    // helpful for us so just check activeElement instead.\n    //\n    // 99% of the time, keydown and keyup aren't necessary. IE8 fails to fire\n    // propertychange on the first input event after setting `value` from a\n    // script and fires only keydown, keypress, keyup. Catching keyup usually\n    // gets it and catching keydown lets us fire an event for the first\n    // keystroke if user does a key repeat (it'll be a little delayed: right\n    // before the second keystroke). Other input methods (e.g., paste) seem to\n    // fire selectionchange normally.\n    if (activeElement && activeElement.value !== activeElementValue) {\n      activeElementValue = activeElement.value;\n      return activeElementInst;\n    }\n  }\n}\n/**\n * SECTION: handle `click` event\n */\n\n\nfunction shouldUseClickEvent(elem) {\n  // Use the `click` event to detect changes to checkbox and radio inputs.\n  // This approach works across all browsers, whereas `change` does not fire\n  // until `blur` in IE8.\n  return elem.nodeName && elem.nodeName.toLowerCase() === 'input' && (elem.type === 'checkbox' || elem.type === 'radio');\n}\n\nfunction getTargetInstForClickEvent(topLevelType, targetInst) {\n  if (topLevelType === 'topClick') {\n    return targetInst;\n  }\n}\n\nfunction handleControlledInputBlur(inst, node) {\n  // TODO: In IE, inst is occasionally null. Why?\n  if (inst == null) {\n    return;\n  } // Fiber and ReactDOM keep wrapper state in separate places\n\n\n  var state = inst._wrapperState || node._wrapperState;\n\n  if (!state || !state.controlled || node.type !== 'number') {\n    return;\n  } // If controlled, assign the value attribute to the current value on blur\n\n\n  var value = '' + node.value;\n\n  if (node.getAttribute('value') !== value) {\n    node.setAttribute('value', value);\n  }\n}\n/**\n * This plugin creates an `onChange` event that normalizes change events\n * across form elements. This event fires at a time when it's possible to\n * change the element's value without seeing a flicker.\n *\n * Supported elements are:\n * - input (see `isTextInputElement`)\n * - textarea\n * - select\n */\n\n\nvar ChangeEventPlugin = {\n  eventTypes: eventTypes,\n  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {\n    var targetNode = targetInst ? ReactDOMComponentTree.getNodeFromInstance(targetInst) : window;\n    var getTargetInstFunc, handleEventFunc;\n\n    if (shouldUseChangeEvent(targetNode)) {\n      if (doesChangeEventBubble) {\n        getTargetInstFunc = getTargetInstForChangeEvent;\n      } else {\n        handleEventFunc = handleEventsForChangeEventIE8;\n      }\n    } else if (isTextInputElement(targetNode)) {\n      if (isInputEventSupported) {\n        getTargetInstFunc = getTargetInstForInputEvent;\n      } else {\n        getTargetInstFunc = getTargetInstForInputEventIE;\n        handleEventFunc = handleEventsForInputEventIE;\n      }\n    } else if (shouldUseClickEvent(targetNode)) {\n      getTargetInstFunc = getTargetInstForClickEvent;\n    }\n\n    if (getTargetInstFunc) {\n      var inst = getTargetInstFunc(topLevelType, targetInst);\n\n      if (inst) {\n        var event = SyntheticEvent.getPooled(eventTypes.change, inst, nativeEvent, nativeEventTarget);\n        event.type = 'change';\n        EventPropagators.accumulateTwoPhaseDispatches(event);\n        return event;\n      }\n    }\n\n    if (handleEventFunc) {\n      handleEventFunc(topLevelType, targetNode, targetInst);\n    } // When blurring, set the value attribute for number inputs\n\n\n    if (topLevelType === 'topBlur') {\n      handleControlledInputBlur(targetInst, targetNode);\n    }\n  }\n};\nmodule.exports = ChangeEventPlugin;","map":{"version":3,"sources":["C:/myProJects/Server/weatherapp/node_modules/react-dom/lib/ChangeEventPlugin.js"],"names":["EventPluginHub","require","EventPropagators","ExecutionEnvironment","ReactDOMComponentTree","ReactUpdates","SyntheticEvent","getEventTarget","isEventSupported","isTextInputElement","eventTypes","change","phasedRegistrationNames","bubbled","captured","dependencies","activeElement","activeElementInst","activeElementValue","activeElementValueProp","shouldUseChangeEvent","elem","nodeName","toLowerCase","type","doesChangeEventBubble","canUseDOM","document","documentMode","manualDispatchChangeEvent","nativeEvent","event","getPooled","accumulateTwoPhaseDispatches","batchedUpdates","runEventInBatch","enqueueEvents","processEventQueue","startWatchingForChangeEventIE8","target","targetInst","attachEvent","stopWatchingForChangeEventIE8","detachEvent","getTargetInstForChangeEvent","topLevelType","handleEventsForChangeEventIE8","isInputEventSupported","newValueProp","get","call","set","val","startWatchingForValueChange","value","Object","getOwnPropertyDescriptor","constructor","prototype","defineProperty","handlePropertyChange","addEventListener","stopWatchingForValueChange","removeEventListener","propertyName","srcElement","getTargetInstForInputEvent","handleEventsForInputEventIE","getTargetInstForInputEventIE","shouldUseClickEvent","getTargetInstForClickEvent","handleControlledInputBlur","inst","node","state","_wrapperState","controlled","getAttribute","setAttribute","ChangeEventPlugin","extractEvents","nativeEventTarget","targetNode","getNodeFromInstance","window","getTargetInstFunc","handleEventFunc","module","exports"],"mappings":"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","sourcesContent":["/**\n * Copyright 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n */\n\n'use strict';\n\nvar EventPluginHub = require('./EventPluginHub');\nvar EventPropagators = require('./EventPropagators');\nvar ExecutionEnvironment = require('fbjs/lib/ExecutionEnvironment');\nvar ReactDOMComponentTree = require('./ReactDOMComponentTree');\nvar ReactUpdates = require('./ReactUpdates');\nvar SyntheticEvent = require('./SyntheticEvent');\n\nvar getEventTarget = require('./getEventTarget');\nvar isEventSupported = require('./isEventSupported');\nvar isTextInputElement = require('./isTextInputElement');\n\nvar eventTypes = {\n  change: {\n    phasedRegistrationNames: {\n      bubbled: 'onChange',\n      captured: 'onChangeCapture'\n    },\n    dependencies: ['topBlur', 'topChange', 'topClick', 'topFocus', 'topInput', 'topKeyDown', 'topKeyUp', 'topSelectionChange']\n  }\n};\n\n/**\n * For IE shims\n */\nvar activeElement = null;\nvar activeElementInst = null;\nvar activeElementValue = null;\nvar activeElementValueProp = null;\n\n/**\n * SECTION: handle `change` event\n */\nfunction shouldUseChangeEvent(elem) {\n  var nodeName = elem.nodeName && elem.nodeName.toLowerCase();\n  return nodeName === 'select' || nodeName === 'input' && elem.type === 'file';\n}\n\nvar doesChangeEventBubble = false;\nif (ExecutionEnvironment.canUseDOM) {\n  // See `handleChange` comment below\n  doesChangeEventBubble = isEventSupported('change') && (!document.documentMode || document.documentMode > 8);\n}\n\nfunction manualDispatchChangeEvent(nativeEvent) {\n  var event = SyntheticEvent.getPooled(eventTypes.change, activeElementInst, nativeEvent, getEventTarget(nativeEvent));\n  EventPropagators.accumulateTwoPhaseDispatches(event);\n\n  // If change and propertychange bubbled, we'd just bind to it like all the\n  // other events and have it go through ReactBrowserEventEmitter. Since it\n  // doesn't, we manually listen for the events and so we have to enqueue and\n  // process the abstract event manually.\n  //\n  // Batching is necessary here in order to ensure that all event handlers run\n  // before the next rerender (including event handlers attached to ancestor\n  // elements instead of directly on the input). Without this, controlled\n  // components don't work properly in conjunction with event bubbling because\n  // the component is rerendered and the value reverted before all the event\n  // handlers can run. See https://github.com/facebook/react/issues/708.\n  ReactUpdates.batchedUpdates(runEventInBatch, event);\n}\n\nfunction runEventInBatch(event) {\n  EventPluginHub.enqueueEvents(event);\n  EventPluginHub.processEventQueue(false);\n}\n\nfunction startWatchingForChangeEventIE8(target, targetInst) {\n  activeElement = target;\n  activeElementInst = targetInst;\n  activeElement.attachEvent('onchange', manualDispatchChangeEvent);\n}\n\nfunction stopWatchingForChangeEventIE8() {\n  if (!activeElement) {\n    return;\n  }\n  activeElement.detachEvent('onchange', manualDispatchChangeEvent);\n  activeElement = null;\n  activeElementInst = null;\n}\n\nfunction getTargetInstForChangeEvent(topLevelType, targetInst) {\n  if (topLevelType === 'topChange') {\n    return targetInst;\n  }\n}\nfunction handleEventsForChangeEventIE8(topLevelType, target, targetInst) {\n  if (topLevelType === 'topFocus') {\n    // stopWatching() should be a noop here but we call it just in case we\n    // missed a blur event somehow.\n    stopWatchingForChangeEventIE8();\n    startWatchingForChangeEventIE8(target, targetInst);\n  } else if (topLevelType === 'topBlur') {\n    stopWatchingForChangeEventIE8();\n  }\n}\n\n/**\n * SECTION: handle `input` event\n */\nvar isInputEventSupported = false;\nif (ExecutionEnvironment.canUseDOM) {\n  // IE9 claims to support the input event but fails to trigger it when\n  // deleting text, so we ignore its input events.\n  // IE10+ fire input events to often, such when a placeholder\n  // changes or when an input with a placeholder is focused.\n  isInputEventSupported = isEventSupported('input') && (!document.documentMode || document.documentMode > 11);\n}\n\n/**\n * (For IE <=11) Replacement getter/setter for the `value` property that gets\n * set on the active element.\n */\nvar newValueProp = {\n  get: function () {\n    return activeElementValueProp.get.call(this);\n  },\n  set: function (val) {\n    // Cast to a string so we can do equality checks.\n    activeElementValue = '' + val;\n    activeElementValueProp.set.call(this, val);\n  }\n};\n\n/**\n * (For IE <=11) Starts tracking propertychange events on the passed-in element\n * and override the value property so that we can distinguish user events from\n * value changes in JS.\n */\nfunction startWatchingForValueChange(target, targetInst) {\n  activeElement = target;\n  activeElementInst = targetInst;\n  activeElementValue = target.value;\n  activeElementValueProp = Object.getOwnPropertyDescriptor(target.constructor.prototype, 'value');\n\n  // Not guarded in a canDefineProperty check: IE8 supports defineProperty only\n  // on DOM elements\n  Object.defineProperty(activeElement, 'value', newValueProp);\n  if (activeElement.attachEvent) {\n    activeElement.attachEvent('onpropertychange', handlePropertyChange);\n  } else {\n    activeElement.addEventListener('propertychange', handlePropertyChange, false);\n  }\n}\n\n/**\n * (For IE <=11) Removes the event listeners from the currently-tracked element,\n * if any exists.\n */\nfunction stopWatchingForValueChange() {\n  if (!activeElement) {\n    return;\n  }\n\n  // delete restores the original property definition\n  delete activeElement.value;\n\n  if (activeElement.detachEvent) {\n    activeElement.detachEvent('onpropertychange', handlePropertyChange);\n  } else {\n    activeElement.removeEventListener('propertychange', handlePropertyChange, false);\n  }\n\n  activeElement = null;\n  activeElementInst = null;\n  activeElementValue = null;\n  activeElementValueProp = null;\n}\n\n/**\n * (For IE <=11) Handles a propertychange event, sending a `change` event if\n * the value of the active element has changed.\n */\nfunction handlePropertyChange(nativeEvent) {\n  if (nativeEvent.propertyName !== 'value') {\n    return;\n  }\n  var value = nativeEvent.srcElement.value;\n  if (value === activeElementValue) {\n    return;\n  }\n  activeElementValue = value;\n\n  manualDispatchChangeEvent(nativeEvent);\n}\n\n/**\n * If a `change` event should be fired, returns the target's ID.\n */\nfunction getTargetInstForInputEvent(topLevelType, targetInst) {\n  if (topLevelType === 'topInput') {\n    // In modern browsers (i.e., not IE8 or IE9), the input event is exactly\n    // what we want so fall through here and trigger an abstract event\n    return targetInst;\n  }\n}\n\nfunction handleEventsForInputEventIE(topLevelType, target, targetInst) {\n  if (topLevelType === 'topFocus') {\n    // In IE8, we can capture almost all .value changes by adding a\n    // propertychange handler and looking for events with propertyName\n    // equal to 'value'\n    // In IE9-11, propertychange fires for most input events but is buggy and\n    // doesn't fire when text is deleted, but conveniently, selectionchange\n    // appears to fire in all of the remaining cases so we catch those and\n    // forward the event if the value has changed\n    // In either case, we don't want to call the event handler if the value\n    // is changed from JS so we redefine a setter for `.value` that updates\n    // our activeElementValue variable, allowing us to ignore those changes\n    //\n    // stopWatching() should be a noop here but we call it just in case we\n    // missed a blur event somehow.\n    stopWatchingForValueChange();\n    startWatchingForValueChange(target, targetInst);\n  } else if (topLevelType === 'topBlur') {\n    stopWatchingForValueChange();\n  }\n}\n\n// For IE8 and IE9.\nfunction getTargetInstForInputEventIE(topLevelType, targetInst) {\n  if (topLevelType === 'topSelectionChange' || topLevelType === 'topKeyUp' || topLevelType === 'topKeyDown') {\n    // On the selectionchange event, the target is just document which isn't\n    // helpful for us so just check activeElement instead.\n    //\n    // 99% of the time, keydown and keyup aren't necessary. IE8 fails to fire\n    // propertychange on the first input event after setting `value` from a\n    // script and fires only keydown, keypress, keyup. Catching keyup usually\n    // gets it and catching keydown lets us fire an event for the first\n    // keystroke if user does a key repeat (it'll be a little delayed: right\n    // before the second keystroke). Other input methods (e.g., paste) seem to\n    // fire selectionchange normally.\n    if (activeElement && activeElement.value !== activeElementValue) {\n      activeElementValue = activeElement.value;\n      return activeElementInst;\n    }\n  }\n}\n\n/**\n * SECTION: handle `click` event\n */\nfunction shouldUseClickEvent(elem) {\n  // Use the `click` event to detect changes to checkbox and radio inputs.\n  // This approach works across all browsers, whereas `change` does not fire\n  // until `blur` in IE8.\n  return elem.nodeName && elem.nodeName.toLowerCase() === 'input' && (elem.type === 'checkbox' || elem.type === 'radio');\n}\n\nfunction getTargetInstForClickEvent(topLevelType, targetInst) {\n  if (topLevelType === 'topClick') {\n    return targetInst;\n  }\n}\n\nfunction handleControlledInputBlur(inst, node) {\n  // TODO: In IE, inst is occasionally null. Why?\n  if (inst == null) {\n    return;\n  }\n\n  // Fiber and ReactDOM keep wrapper state in separate places\n  var state = inst._wrapperState || node._wrapperState;\n\n  if (!state || !state.controlled || node.type !== 'number') {\n    return;\n  }\n\n  // If controlled, assign the value attribute to the current value on blur\n  var value = '' + node.value;\n  if (node.getAttribute('value') !== value) {\n    node.setAttribute('value', value);\n  }\n}\n\n/**\n * This plugin creates an `onChange` event that normalizes change events\n * across form elements. This event fires at a time when it's possible to\n * change the element's value without seeing a flicker.\n *\n * Supported elements are:\n * - input (see `isTextInputElement`)\n * - textarea\n * - select\n */\nvar ChangeEventPlugin = {\n\n  eventTypes: eventTypes,\n\n  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {\n    var targetNode = targetInst ? ReactDOMComponentTree.getNodeFromInstance(targetInst) : window;\n\n    var getTargetInstFunc, handleEventFunc;\n    if (shouldUseChangeEvent(targetNode)) {\n      if (doesChangeEventBubble) {\n        getTargetInstFunc = getTargetInstForChangeEvent;\n      } else {\n        handleEventFunc = handleEventsForChangeEventIE8;\n      }\n    } else if (isTextInputElement(targetNode)) {\n      if (isInputEventSupported) {\n        getTargetInstFunc = getTargetInstForInputEvent;\n      } else {\n        getTargetInstFunc = getTargetInstForInputEventIE;\n        handleEventFunc = handleEventsForInputEventIE;\n      }\n    } else if (shouldUseClickEvent(targetNode)) {\n      getTargetInstFunc = getTargetInstForClickEvent;\n    }\n\n    if (getTargetInstFunc) {\n      var inst = getTargetInstFunc(topLevelType, targetInst);\n      if (inst) {\n        var event = SyntheticEvent.getPooled(eventTypes.change, inst, nativeEvent, nativeEventTarget);\n        event.type = 'change';\n        EventPropagators.accumulateTwoPhaseDispatches(event);\n        return event;\n      }\n    }\n\n    if (handleEventFunc) {\n      handleEventFunc(topLevelType, targetNode, targetInst);\n    }\n\n    // When blurring, set the value attribute for number inputs\n    if (topLevelType === 'topBlur') {\n      handleControlledInputBlur(targetInst, targetNode);\n    }\n  }\n\n};\n\nmodule.exports = ChangeEventPlugin;"]},"metadata":{},"sourceType":"script"}