{"ast":null,"code":"import AudioContext from './AudioContext';\nlet drawVisual;\nconst Visualizer = {\n  visualizeSineWave(canvasCtx, canvas, width, height, backgroundColor, strokeColor) {\n    let analyser = AudioContext.getAnalyser();\n    const bufferLength = analyser.fftSize;\n    const dataArray = new Uint8Array(bufferLength);\n    canvasCtx.clearRect(0, 0, width, height);\n\n    function draw() {\n      drawVisual = requestAnimationFrame(draw);\n      analyser = AudioContext.getAnalyser();\n      analyser.getByteTimeDomainData(dataArray);\n      canvasCtx.fillStyle = backgroundColor;\n      canvasCtx.fillRect(0, 0, width, height);\n      canvasCtx.lineWidth = 2;\n      canvasCtx.strokeStyle = strokeColor;\n      canvasCtx.beginPath();\n      const sliceWidth = width * 1.0 / bufferLength;\n      let x = 0;\n\n      for (let i = 0; i < bufferLength; i++) {\n        const v = dataArray[i] / 128.0;\n        const y = v * height / 2;\n\n        if (i === 0) {\n          canvasCtx.moveTo(x, y);\n        } else {\n          canvasCtx.lineTo(x, y);\n        }\n\n        x += sliceWidth;\n      }\n\n      canvasCtx.lineTo(canvas.width, canvas.height / 2);\n      canvasCtx.stroke();\n    }\n\n    ;\n    draw();\n  },\n\n  visualizeFrequencyBars(canvasCtx, canvas, width, height, backgroundColor, strokeColor) {\n    const self = this;\n    let analyser = AudioContext.getAnalyser();\n    analyser.fftSize = 256;\n    const bufferLength = analyser.frequencyBinCount;\n    const dataArray = new Uint8Array(bufferLength);\n    canvasCtx.clearRect(0, 0, width, height);\n\n    function draw() {\n      drawVisual = requestAnimationFrame(draw);\n      analyser = AudioContext.getAnalyser();\n      analyser.getByteFrequencyData(dataArray);\n      canvasCtx.fillStyle = backgroundColor;\n      canvasCtx.fillRect(0, 0, width, height);\n      const barWidth = width / bufferLength * 2.5;\n      let barHeight;\n      let x = 0;\n\n      for (let i = 0; i < bufferLength; i++) {\n        barHeight = dataArray[i];\n        const rgb = self.hexToRgb(strokeColor); // canvasCtx.fillStyle = `rgb(${barHeight+100},${rgb.g},${rgb.b})`;\n\n        canvasCtx.fillStyle = strokeColor;\n        canvasCtx.fillRect(x, height - barHeight / 2, barWidth, barHeight / 2);\n        x += barWidth + 1;\n      }\n    }\n\n    ;\n    draw();\n  },\n\n  visualizeFrequencyCircles(canvasCtx, canvas, width, height, backgroundColor, strokeColor) {\n    const self = this;\n    let analyser = AudioContext.getAnalyser();\n    analyser.fftSize = 32;\n    const bufferLength = analyser.frequencyBinCount;\n    const dataArray = new Uint8Array(bufferLength);\n    canvasCtx.clearRect(0, 0, width, height);\n\n    function draw() {\n      drawVisual = requestAnimationFrame(draw);\n      analyser = AudioContext.getAnalyser();\n      analyser.getByteFrequencyData(dataArray);\n      const reductionAmount = 3;\n      const reducedDataArray = new Uint8Array(bufferLength / reductionAmount);\n\n      for (let i = 0; i < bufferLength; i += reductionAmount) {\n        let sum = 0;\n\n        for (let j = 0; j < reductionAmount; j++) {\n          sum += dataArray[i + j];\n        }\n\n        reducedDataArray[i / reductionAmount] = sum / reductionAmount;\n      }\n\n      canvasCtx.clearRect(0, 0, width, height);\n      canvasCtx.beginPath();\n      canvasCtx.arc(width / 2, height / 2, Math.min(height, width) / 2, 0, 2 * Math.PI);\n      canvasCtx.fillStyle = backgroundColor;\n      canvasCtx.fill();\n      const stepSize = Math.min(height, width) / 2.0 / reducedDataArray.length;\n      canvasCtx.strokeStyle = strokeColor;\n\n      for (let i = 0; i < reducedDataArray.length; i++) {\n        canvasCtx.beginPath();\n        const normalized = reducedDataArray[i] / 128;\n        const r = stepSize * i + stepSize * normalized;\n        canvasCtx.arc(width / 2, height / 2, r, 0, 2 * Math.PI);\n        canvasCtx.stroke();\n      }\n    }\n\n    ;\n    draw();\n  },\n\n  hexToRgb(hex) {\n    const result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\n    return result ? {\n      r: parseInt(result[1], 16),\n      g: parseInt(result[2], 16),\n      b: parseInt(result[3], 16)\n    } : null;\n  }\n\n};\nexport default Visualizer;","map":{"version":3,"sources":["C:/myProJects/Server/weatherapp/src/components/library/Visualizer.js"],"names":["AudioContext","drawVisual","Visualizer","visualizeSineWave","canvasCtx","canvas","width","height","backgroundColor","strokeColor","analyser","getAnalyser","bufferLength","fftSize","dataArray","Uint8Array","clearRect","draw","requestAnimationFrame","getByteTimeDomainData","fillStyle","fillRect","lineWidth","strokeStyle","beginPath","sliceWidth","x","i","v","y","moveTo","lineTo","stroke","visualizeFrequencyBars","self","frequencyBinCount","getByteFrequencyData","barWidth","barHeight","rgb","hexToRgb","visualizeFrequencyCircles","reductionAmount","reducedDataArray","sum","j","arc","Math","min","PI","fill","stepSize","length","normalized","r","hex","result","exec","parseInt","g","b"],"mappings":"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","sourcesContent":["import AudioContext from './AudioContext';\r\n\r\n\r\nlet drawVisual;\r\n\r\nconst Visualizer = {\r\n\r\n  visualizeSineWave(canvasCtx, canvas, width, height, backgroundColor, strokeColor) {\r\n    let analyser = AudioContext.getAnalyser();\r\n\r\n    const bufferLength = analyser.fftSize;\r\n    const dataArray = new Uint8Array(bufferLength);\r\n\r\n    canvasCtx.clearRect(0, 0, width, height);\r\n\r\n    function draw() {\r\n\r\n      drawVisual = requestAnimationFrame(draw);\r\n\r\n      analyser = AudioContext.getAnalyser();\r\n\r\n      analyser.getByteTimeDomainData(dataArray);\r\n\r\n      canvasCtx.fillStyle = backgroundColor;\r\n      canvasCtx.fillRect(0, 0, width, height);\r\n\r\n      canvasCtx.lineWidth = 2;\r\n      canvasCtx.strokeStyle = strokeColor;\r\n\r\n      canvasCtx.beginPath();\r\n\r\n      const sliceWidth = width * 1.0 / bufferLength;\r\n      let x = 0;\r\n\r\n      for(let i = 0; i < bufferLength; i++) {\r\n        const v = dataArray[i] / 128.0;\r\n        const y = v * height/2;\r\n\r\n        if(i === 0) {\r\n          canvasCtx.moveTo(x, y);\r\n        } else {\r\n          canvasCtx.lineTo(x, y);\r\n        }\r\n\r\n        x += sliceWidth;\r\n      }\r\n\r\n      canvasCtx.lineTo(canvas.width, canvas.height/2);\r\n      canvasCtx.stroke();\r\n    };\r\n\r\n    draw();\r\n  },\r\n\r\n  visualizeFrequencyBars(canvasCtx, canvas, width, height, backgroundColor, strokeColor) {\r\n    const self = this;\r\n    let analyser = AudioContext.getAnalyser();\r\n    analyser.fftSize = 256;\r\n    const bufferLength = analyser.frequencyBinCount;\r\n    const dataArray = new Uint8Array(bufferLength);\r\n\r\n    canvasCtx.clearRect(0, 0, width, height);\r\n\r\n    function draw() {\r\n      drawVisual = requestAnimationFrame(draw);\r\n\r\n      analyser = AudioContext.getAnalyser();\r\n      analyser.getByteFrequencyData(dataArray);\r\n\r\n      canvasCtx.fillStyle = backgroundColor;\r\n      canvasCtx.fillRect(0, 0, width, height);\r\n\r\n      const barWidth = (width / bufferLength) * 2.5;\r\n      let barHeight;\r\n      let x = 0;\r\n\r\n      for(let i = 0; i < bufferLength; i++) {\r\n        barHeight = dataArray[i];\r\n\r\n        const rgb = self.hexToRgb(strokeColor);\r\n\r\n        // canvasCtx.fillStyle = `rgb(${barHeight+100},${rgb.g},${rgb.b})`;\r\n        canvasCtx.fillStyle = strokeColor;\r\n        canvasCtx.fillRect(x,height-barHeight/2,barWidth,barHeight/2);\r\n\r\n        x += barWidth + 1;\r\n      }\r\n    };\r\n\r\n    draw();\r\n  },\r\n\r\n  visualizeFrequencyCircles(canvasCtx, canvas, width, height, backgroundColor, strokeColor) {\r\n    const self = this;\r\n    let analyser = AudioContext.getAnalyser();\r\n    analyser.fftSize = 32;\r\n    const bufferLength = analyser.frequencyBinCount;\r\n\r\n    const dataArray = new Uint8Array(bufferLength);\r\n    canvasCtx.clearRect(0, 0, width, height);\r\n\r\n    function draw() {\r\n\r\n      drawVisual = requestAnimationFrame(draw);\r\n      analyser = AudioContext.getAnalyser();\r\n      analyser.getByteFrequencyData(dataArray);\r\n      const reductionAmount = 3;\r\n      const reducedDataArray = new Uint8Array(bufferLength / reductionAmount);\r\n\r\n      for (let i = 0; i < bufferLength; i += reductionAmount) {\r\n        let sum = 0;\r\n        for (let j = 0; j < reductionAmount; j++) {\r\n          sum += dataArray[i + j];\r\n        }\r\n         reducedDataArray[i/reductionAmount] = sum / reductionAmount;\r\n      }\r\n\r\n      canvasCtx.clearRect(0, 0, width, height);\r\n      canvasCtx.beginPath();\r\n      canvasCtx.arc(width / 2, height / 2, Math.min(height, width) / 2, 0, 2 * Math.PI);\r\n      canvasCtx.fillStyle = backgroundColor;\r\n      canvasCtx.fill();\r\n      const stepSize = (Math.min(height, width) / 2.0) / (reducedDataArray.length);\r\n      canvasCtx.strokeStyle = strokeColor;\r\n\r\n      for (let i = 0; i < reducedDataArray.length; i++) {\r\n        canvasCtx.beginPath();\r\n        const normalized = reducedDataArray[i] / 128;\r\n        const r = (stepSize * i) + (stepSize * normalized);\r\n        canvasCtx.arc(width / 2, height / 2, r, 0, 2 * Math.PI);\r\n        canvasCtx.stroke();\r\n      }\r\n    };\r\n    draw();\r\n  },\r\n\r\n\r\n  hexToRgb(hex) {\r\n    const result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\r\n    return result ? {\r\n        r: parseInt(result[1], 16),\r\n        g: parseInt(result[2], 16),\r\n        b: parseInt(result[3], 16)\r\n    } : null;\r\n  }\r\n\r\n}\r\n\r\nexport default Visualizer;"]},"metadata":{},"sourceType":"module"}