{"ast":null,"code":"import { OrderedMap } from \"immutable\";\nimport _ from 'lodash';\nexport default class Realtime {\n  constructor(store) {\n    this.store = store;\n    this.ws = null;\n    this.isConnected = false;\n    this.connect();\n    this.reconnect();\n  }\n\n  reconnect() {\n    const store = this.store;\n    window.setInterval(() => {\n      const user = store.getCurrentUser();\n\n      if (user && !this.isConnected) {\n        this.connect();\n      }\n    }, 3000);\n  }\n\n  decoMessage(msg) {\n    let message = {};\n\n    try {\n      message = JSON.parse(msg);\n    } catch (err) {\n      console.log(err);\n    }\n\n    return message;\n  }\n\n  readMessage(msg) {\n    const store = this.store;\n    const currentUser = store.getCurrentUser();\n\n    const currentUserId = _.toString(_.get(currentUser, '_id'));\n\n    const message = this.decoMessage(msg);\n\n    const action = _.get(message, 'action');\n\n    const payload = _.get(message, 'payload');\n\n    switch (action) {\n      case 'edit_user':\n        const userId = _.get(payload, 'userId');\n\n        const value = _.get(payload, 'obj.payload', '');\n\n        const field = _.get(payload, 'obj.field', '');\n\n        this.updateInfoUser(userId, field, value);\n        break;\n\n      case 'typing_status':\n        console.log(payload);\n\n        const obj = _.get(payload, 'obj');\n\n        const channelId = _.get(obj, 'channelId');\n\n        let typing = _.get(obj, 'payload');\n\n        let typier = _.get(obj, 'typier');\n\n        this.onUpdateTypestatus(channelId, typing, typier);\n        break;\n\n      case 'user_offline':\n        this.onUpdateUserStatus(payload, false);\n        break;\n\n      case 'user_online':\n        const isOnline = true;\n        this.onUpdateUserStatus(payload, isOnline);\n        break;\n\n      case 'message_added':\n        const activeChannel = store.getActiveChannel();\n\n        let notify = _.get(activeChannel, '_id') !== _.get(payload, 'channelId') && currentUserId !== _.get(payload, 'userId');\n\n        this.onAddMessage(payload, notify);\n        break;\n\n      default:\n        break;\n\n      case 'channel_added':\n        //to do check payload and insert new channel\n        this.onAddChannel(payload);\n        break;\n    }\n  }\n\n  updateInfoUser(userId, field, value) {\n    const store = this.store;\n    const currentUser = store.getCurrentUser();\n\n    const currentUserId = _.get(currentUser, '_id'); // Get the existing data\n\n\n    let me = localStorage.getItem('me'); // If no existing data, create an array\n    // Otherwise, convert the localStorage string to an array\n\n    me = me ? JSON.parse(me) : {}; // Add new data to localStorage Array\n\n    me[field] = value; // Save back to localStorage\n\n    localStorage.setItem('me', JSON.stringify(me));\n    store.setCurrentUser(me);\n    console.log('me', me);\n    store.users = store.users.update(userId, user => {\n      if (user) {\n        switch (field) {\n          case 'avatar':\n            user.avatar = value;\n            break;\n\n          case 'name':\n            user.name = value;\n            break;\n\n          case 'birthday':\n            user.birthday = value;\n            break;\n\n          case 'phone':\n            user.phone = value;\n            break;\n\n          case 'country':\n            user.country = value;\n            break;\n\n          default:\n            break;\n        }\n      }\n\n      return user;\n    });\n    store.update();\n  }\n\n  onUpdateTypestatus(channelId, isTyping = false, typier) {\n    const store = this.store;\n    store.channels = store.channels.update(channelId, channel => {\n      if (channel) {\n        channel.typing = isTyping;\n        channel.typier = typier;\n      }\n\n      return channel;\n    });\n    store.update();\n  }\n\n  onUpdateUserStatus(userId, isOnline = false) {\n    const store = this.store;\n    store.users = store.users.update(userId, user => {\n      if (user) {\n        user.online = isOnline;\n        user.lastConnection = new Date();\n      }\n\n      return user;\n    });\n    store.update();\n  }\n\n  onAddMessage(payload, notify = false) {\n    let user = _.get(payload, 'user');\n\n    const store = this.store;\n    const currentUser = store.getCurrentUser();\n\n    const currentUserId = _.toString(_.get(currentUser, '_id')); //add user to cache\n\n\n    user = store.addUserToCache(user);\n    const messageObject = {\n      _id: payload._id,\n      body: _.get(payload, 'body', ''),\n      userId: _.get(payload, 'userId'),\n      channelId: _.get(payload, 'channelId'),\n      created: _.get(payload, 'created', new Date()),\n      type: _.get(payload, 'type', ''),\n      me: currentUserId === _.toString(_.get(payload, 'userId')),\n      user: user\n    }; // console.log(\"Mess listen from fetch: \", messageObject);\n\n    store.setMessage(messageObject, notify);\n  }\n\n  onAddChannel(payload) {\n    const store = this.store;\n    const channelId = `${payload._id}`;\n    const userId = `${payload.userId}`;\n\n    const users = _.get(payload, 'users', []);\n\n    let channel = {\n      _id: channelId,\n      title: _.get(payload, 'title', ''),\n      lastMessage: _.get(payload, 'lastMessage', ''),\n      members: new OrderedMap(),\n      messages: new OrderedMap(),\n      isNew: false,\n      userId: userId,\n      created: new Date(),\n      typing: false\n    };\n\n    _.each(users, user => {\n      //add this user to store.users collection\n      const memberId = `${user._id}`;\n      this.store.addUserToCache(user);\n      channel.members = channel.members.set(memberId, true);\n    });\n\n    const channelMessages = store.messages.filter(m => _.toString(m.channelId) === channelId);\n    channelMessages.forEach(msg => {\n      const msgId = _.toString(_.get(msg, '_id'));\n\n      channel.messages = channel.messages.set(msgId, true);\n    });\n    store.addChannel(channelId, channel);\n  }\n\n  send(msg = {}) {\n    try {\n      const isConnected = this.isConnected;\n\n      if (this.ws && isConnected) {\n        const msgString = JSON.stringify(msg);\n        this.ws.send(msgString);\n      }\n    } catch {\n      console.log(\"An Error when Send info to server is connecting!\");\n    }\n  }\n\n  authentication() {\n    const store = this.store;\n    const tokenId = store.getUserTokenId();\n    const message = {\n      action: 'auth',\n      payload: `${tokenId}`\n    };\n    this.send(message);\n  }\n\n  connect() {\n    const ws = new WebSocket('ws://localhost:8080');\n    this.ws = ws;\n\n    ws.onopen = () => {\n      //tell to server who are you ?\n      this.isConnected = true;\n      this.authentication();\n\n      ws.onmessage = e => {\n        this.readMessage(_.get(e, 'data', ''));\n        console.log(\"Message from server: \", e.data);\n      };\n    };\n\n    ws.onclose = () => {\n      this.isConnected = false;\n      this.store.update();\n    };\n\n    ws.onerror = () => {\n      this.isConnected = false;\n      this.store.update();\n    };\n  }\n\n}","map":{"version":3,"sources":["C:/myProJects/Server/weatherapp/src/realtime.js"],"names":["OrderedMap","_","Realtime","constructor","store","ws","isConnected","connect","reconnect","window","setInterval","user","getCurrentUser","decoMessage","msg","message","JSON","parse","err","console","log","readMessage","currentUser","currentUserId","toString","get","action","payload","userId","value","field","updateInfoUser","obj","channelId","typing","typier","onUpdateTypestatus","onUpdateUserStatus","isOnline","activeChannel","getActiveChannel","notify","onAddMessage","onAddChannel","me","localStorage","getItem","setItem","stringify","setCurrentUser","users","update","avatar","name","birthday","phone","country","isTyping","channels","channel","online","lastConnection","Date","addUserToCache","messageObject","_id","body","created","type","setMessage","title","lastMessage","members","messages","isNew","each","memberId","set","channelMessages","filter","m","forEach","msgId","addChannel","send","msgString","authentication","tokenId","getUserTokenId","WebSocket","onopen","onmessage","e","data","onclose","onerror"],"mappings":"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","sourcesContent":["import { OrderedMap } from \"immutable\";\r\nimport _ from 'lodash';\r\n\r\nexport default class Realtime{\r\n\r\n    constructor(store){\r\n        this.store = store;\r\n        this.ws = null;\r\n        this.isConnected = false;\r\n        this.connect();\r\n        this.reconnect();\r\n\r\n    }\r\n    reconnect(){\r\n        const store = this.store;\r\n        window.setInterval(() => {\r\n            const user = store.getCurrentUser();\r\n            if(user && !this.isConnected) {\r\n                this.connect();\r\n            }\r\n        }, 3000)\r\n    }\r\n    decoMessage(msg){\r\n        let message = {};\r\n        try{\r\n            message = JSON.parse(msg);\r\n        }\r\n        catch(err){\r\n            console.log(err)\r\n        }\r\n        return message;\r\n    }\r\n    readMessage(msg){\r\n        const store = this.store;\r\n        const currentUser = store.getCurrentUser();\r\n        const currentUserId = _.toString(_.get(currentUser, '_id'));\r\n        const message = this.decoMessage(msg);\r\n        const action = _.get(message, 'action');\r\n        const payload = _.get(message, 'payload');\r\n\r\n        switch(action){\r\n            case 'edit_user' :\r\n                const userId = _.get(payload, 'userId');\r\n                const value = _.get(payload, 'obj.payload', '');\r\n                const field = _.get(payload, 'obj.field', '')\r\n                this.updateInfoUser(userId, field, value);\r\n                break;\r\n            case 'typing_status':\r\n                console.log(payload);\r\n                const obj = _.get(payload, 'obj');\r\n                const channelId =  _.get(obj, 'channelId');\r\n                let typing = _.get(obj, 'payload');\r\n                let typier = _.get(obj, 'typier');\r\n                this.onUpdateTypestatus(channelId, typing, typier);\r\n                break;\r\n            case 'user_offline':\r\n                \r\n                this.onUpdateUserStatus(payload, false);\r\n                break;\r\n            case 'user_online':\r\n                const isOnline = true;\r\n                this.onUpdateUserStatus(payload, isOnline);\r\n                break;\r\n            case 'message_added':\r\n                \r\n                const activeChannel = store.getActiveChannel();\r\n                let notify = _.get(activeChannel, '_id') !== _.get(payload, 'channelId') && currentUserId !== _.get(payload, 'userId');\r\n                this.onAddMessage(payload, notify);\r\n\r\n            break;\r\n            default:\r\n                break;\r\n            case 'channel_added':\r\n                //to do check payload and insert new channel\r\n                this.onAddChannel(payload);\r\n                break;\r\n        }\r\n    }\r\n    updateInfoUser(userId, field, value){\r\n        const store = this.store;\r\n        const currentUser = store.getCurrentUser();\r\n        const currentUserId = _.get(currentUser, '_id');\r\n        // Get the existing data\r\n        let me = localStorage.getItem('me');\r\n        // If no existing data, create an array\r\n        // Otherwise, convert the localStorage string to an array\r\n        me = me ? JSON.parse(me) : {};\r\n        // Add new data to localStorage Array\r\n        me[field] = value;\r\n        // Save back to localStorage\r\n        localStorage.setItem('me', JSON.stringify(me));\r\n        store.setCurrentUser(me);\r\n        console.log('me', me);\r\n        store.users = store.users.update(userId, (user) => {\r\n            if(user){\r\n                switch(field){\r\n                    case 'avatar':\r\n                        user.avatar = value;\r\n                    break;\r\n                    case 'name':\r\n                        user.name = value;\r\n                    break;\r\n                    case 'birthday':\r\n                        user.birthday = value;\r\n                    break;\r\n                    case 'phone':\r\n                        user.phone = value;\r\n                    break;\r\n                    case 'country':\r\n                        user.country = value;\r\n                    break;\r\n                    default:\r\n                    break;\r\n                }\r\n            }\r\n            return user;\r\n        });\r\n        store.update();\r\n\r\n    }\r\n    onUpdateTypestatus(channelId, isTyping = false, typier){\r\n        const store = this.store;\r\n        store.channels = store.channels.update(channelId, (channel) => {\r\n            if(channel){\r\n                channel.typing = isTyping;\r\n                channel.typier = typier;\r\n            }\r\n            return channel;\r\n        });\r\n        store.update();\r\n    }\r\n\r\n    onUpdateUserStatus(userId, isOnline = false){\r\n        const store = this.store;\r\n    \r\n        store.users = store.users.update(userId, (user) => {\r\n            if(user){\r\n                user.online = isOnline;\r\n                user.lastConnection = new Date()\r\n            }\r\n            \r\n            return user;\r\n        });\r\n        store.update();\r\n        \r\n    }\r\n\r\n    onAddMessage(payload, notify = false){\r\n        let user = _.get(payload, 'user');\r\n        const store = this.store;\r\n        const currentUser = store.getCurrentUser();\r\n        const currentUserId = _.toString(_.get(currentUser, '_id'));\r\n        \r\n        //add user to cache\r\n        user = store.addUserToCache(user);\r\n\r\n        const messageObject = {\r\n            _id: payload._id,\r\n            body: _.get(payload, 'body', ''),\r\n            userId: _.get(payload, 'userId'),\r\n            channelId: _.get(payload, 'channelId'),\r\n            created: _.get(payload, 'created', new Date()),\r\n            type: _.get(payload, 'type', ''),\r\n            me: currentUserId === _.toString(_.get(payload, 'userId')),\r\n            user: user,\r\n        };\r\n        // console.log(\"Mess listen from fetch: \", messageObject);\r\n        store.setMessage(messageObject, notify);\r\n\r\n    }\r\n\r\n    onAddChannel(payload){\r\n        const store = this.store;\r\n        const channelId = `${payload._id}`;\r\n        const userId = `${payload.userId}`;\r\n        const users = _.get(payload, 'users', []);\r\n        let channel = { \r\n            \r\n            _id:channelId,  \r\n            title: _.get(payload, 'title', '' ),\r\n            lastMessage: _.get(payload, 'lastMessage', ''),\r\n            members: new OrderedMap(),\r\n            messages: new OrderedMap(),\r\n            isNew: false,\r\n            userId: userId,\r\n            created: new Date(),\r\n            typing: false,\r\n        };\r\n        _.each(users, (user) => {\r\n            //add this user to store.users collection\r\n            const memberId = `${user._id}`;\r\n            this.store.addUserToCache(user);\r\n            channel.members = channel.members.set(memberId, true);\r\n        });\r\n        const channelMessages = store.messages.filter((m) => _.toString(m.channelId) === channelId);\r\n        channelMessages.forEach((msg) => {\r\n            const msgId = _.toString(_.get(msg, '_id'));\r\n            channel.messages = channel.messages.set(msgId, true);\r\n        })\r\n        store.addChannel(channelId, channel);\r\n    }\r\n    send( msg = {}){\r\n        try{\r\n            const isConnected = this.isConnected;\r\n            if(this.ws && isConnected){\r\n                const msgString = JSON.stringify(msg);\r\n                this.ws.send(msgString);\r\n            }\r\n        }\r\n        catch{\r\n            console.log(\"An Error when Send info to server is connecting!\")\r\n        }\r\n       \r\n    }\r\n    authentication(){\r\n        const store = this.store;\r\n        const tokenId = store.getUserTokenId();\r\n        const message = {\r\n            action: 'auth',\r\n            payload: `${tokenId}`\r\n        }\r\n            this.send(message);\r\n    }\r\n\r\n    connect(){\r\n\r\n        const ws = new WebSocket('ws://localhost:8080');\r\n        this.ws = ws;\r\n        ws.onopen = () => {\r\n            //tell to server who are you ?\r\n            this.isConnected = true;\r\n            this.authentication();\r\n            \r\n            ws.onmessage = (e) => {\r\n                this.readMessage(_.get(e, 'data',''));\r\n                console.log(\"Message from server: \", e.data);\r\n            }\r\n        }\r\n\r\n        ws.onclose = () => {\r\n            this.isConnected = false;\r\n            this.store.update();\r\n        }\r\n\r\n        ws.onerror = () => {\r\n            this.isConnected = false;\r\n            this.store.update();\r\n        }\r\n\r\n    }\r\n}"]},"metadata":{},"sourceType":"module"}