{"ast":null,"code":"import { createElement, PureComponent, cloneElement, Component } from 'react';\nimport _extends from '@babel/runtime/helpers/esm/extends';\nimport _assertThisInitialized from '@babel/runtime/helpers/esm/assertThisInitialized';\nimport _inheritsLoose from '@babel/runtime/helpers/esm/inheritsLoose';\nimport memoizeOne from 'memoize-one';\nimport { findDOMNode } from 'react-dom';\nimport _objectWithoutPropertiesLoose from '@babel/runtime/helpers/esm/objectWithoutPropertiesLoose'; // Animation frame based implementation of setTimeout.\n// Inspired by Joe Lambert, https://gist.github.com/joelambert/1002116#file-requesttimeout-js\n\nvar hasNativePerformanceNow = typeof performance === 'object' && typeof performance.now === 'function';\nvar now = hasNativePerformanceNow ? function () {\n  return performance.now();\n} : function () {\n  return Date.now();\n};\n\nfunction cancelTimeout(timeoutID) {\n  cancelAnimationFrame(timeoutID.id);\n}\n\nfunction requestTimeout(callback, delay) {\n  var start = now();\n\n  function tick() {\n    if (now() - start >= delay) {\n      callback.call(null);\n    } else {\n      timeoutID.id = requestAnimationFrame(tick);\n    }\n  }\n\n  var timeoutID = {\n    id: requestAnimationFrame(tick)\n  };\n  return timeoutID;\n}\n\nvar IS_SCROLLING_DEBOUNCE_INTERVAL = 150;\n\nvar defaultItemKey = function defaultItemKey(index, data) {\n  return index;\n}; // In DEV mode, this Set helps us only log a warning once per component instace.\n// This avoids spamming the console every time a render happens.\n\n\nvar devWarningsDirection = null;\nvar devWarningsTagName = null;\n\nif (process.env.NODE_ENV !== 'production') {\n  if (typeof window !== 'undefined' && typeof window.WeakSet !== 'undefined') {\n    devWarningsDirection = /*#__PURE__*/new WeakSet();\n    devWarningsTagName = /*#__PURE__*/new WeakSet();\n  }\n}\n\nfunction createListComponent(_ref) {\n  var _class, _temp;\n\n  var getItemOffset = _ref.getItemOffset,\n      getEstimatedTotalSize = _ref.getEstimatedTotalSize,\n      getItemSize = _ref.getItemSize,\n      getOffsetForIndexAndAlignment = _ref.getOffsetForIndexAndAlignment,\n      getStartIndexForOffset = _ref.getStartIndexForOffset,\n      getStopIndexForStartIndex = _ref.getStopIndexForStartIndex,\n      initInstanceProps = _ref.initInstanceProps,\n      shouldResetStyleCacheOnItemSizeChange = _ref.shouldResetStyleCacheOnItemSizeChange,\n      validateProps = _ref.validateProps;\n  return _temp = _class = /*#__PURE__*/function (_PureComponent) {\n    _inheritsLoose(List, _PureComponent); // Always use explicit constructor for React components.\n    // It produces less code after transpilation. (#26)\n    // eslint-disable-next-line no-useless-constructor\n\n\n    function List(props) {\n      var _this;\n\n      _this = _PureComponent.call(this, props) || this;\n      _this._instanceProps = initInstanceProps(_this.props, _assertThisInitialized(_this));\n      _this._outerRef = void 0;\n      _this._resetIsScrollingTimeoutId = null;\n      _this.state = {\n        instance: _assertThisInitialized(_this),\n        isScrolling: false,\n        scrollDirection: 'forward',\n        scrollOffset: typeof _this.props.initialScrollOffset === 'number' ? _this.props.initialScrollOffset : 0,\n        scrollUpdateWasRequested: false\n      };\n      _this._callOnItemsRendered = void 0;\n      _this._callOnItemsRendered = memoizeOne(function (overscanStartIndex, overscanStopIndex, visibleStartIndex, visibleStopIndex) {\n        return _this.props.onItemsRendered({\n          overscanStartIndex: overscanStartIndex,\n          overscanStopIndex: overscanStopIndex,\n          visibleStartIndex: visibleStartIndex,\n          visibleStopIndex: visibleStopIndex\n        });\n      });\n      _this._callOnScroll = void 0;\n      _this._callOnScroll = memoizeOne(function (scrollDirection, scrollOffset, scrollUpdateWasRequested) {\n        return _this.props.onScroll({\n          scrollDirection: scrollDirection,\n          scrollOffset: scrollOffset,\n          scrollUpdateWasRequested: scrollUpdateWasRequested\n        });\n      });\n      _this._getItemStyle = void 0;\n\n      _this._getItemStyle = function (index) {\n        var _this$props = _this.props,\n            direction = _this$props.direction,\n            itemSize = _this$props.itemSize,\n            layout = _this$props.layout;\n\n        var itemStyleCache = _this._getItemStyleCache(shouldResetStyleCacheOnItemSizeChange && itemSize, shouldResetStyleCacheOnItemSizeChange && layout, shouldResetStyleCacheOnItemSizeChange && direction);\n\n        var style;\n\n        if (itemStyleCache.hasOwnProperty(index)) {\n          style = itemStyleCache[index];\n        } else {\n          var _style;\n\n          var _offset = getItemOffset(_this.props, index, _this._instanceProps);\n\n          var size = getItemSize(_this.props, index, _this._instanceProps); // TODO Deprecate direction \"horizontal\"\n\n          var isHorizontal = direction === 'horizontal' || layout === 'horizontal';\n          itemStyleCache[index] = style = (_style = {\n            position: 'absolute'\n          }, _style[direction === 'rtl' ? 'right' : 'left'] = isHorizontal ? _offset : 0, _style.top = !isHorizontal ? _offset : 0, _style.height = !isHorizontal ? size : '100%', _style.width = isHorizontal ? size : '100%', _style);\n        }\n\n        return style;\n      };\n\n      _this._itemStyleCache = void 0;\n      _this._getItemStyleCache = void 0;\n      _this._getItemStyleCache = memoizeOne(function (_, __, ___) {\n        _this._itemStyleCache = {};\n        return _this._itemStyleCache;\n      });\n\n      _this._onScrollHorizontal = function (event) {\n        var _event$currentTarget = event.currentTarget,\n            clientWidth = _event$currentTarget.clientWidth,\n            scrollLeft = _event$currentTarget.scrollLeft,\n            scrollWidth = _event$currentTarget.scrollWidth;\n\n        _this.setState(function (prevState) {\n          if (prevState.scrollOffset === scrollLeft) {\n            // Scroll position may have been updated by cDM/cDU,\n            // In which case we don't need to trigger another render,\n            // And we don't want to update state.isScrolling.\n            return null;\n          }\n\n          var direction = _this.props.direction; // HACK According to the spec, scrollLeft should be negative for RTL aligned elements.\n          // Chrome does not seem to adhere; its scrolLeft values are positive (measured relative to the left).\n          // See https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollLeft\n\n          var scrollOffset = scrollLeft;\n\n          if (direction === 'rtl') {\n            if (scrollLeft <= 0) {\n              scrollOffset = -scrollOffset;\n            } else {\n              scrollOffset = scrollWidth - clientWidth - scrollLeft;\n            }\n          }\n\n          return {\n            isScrolling: true,\n            scrollDirection: prevState.scrollOffset < scrollLeft ? 'forward' : 'backward',\n            scrollOffset: scrollOffset,\n            scrollUpdateWasRequested: false\n          };\n        }, _this._resetIsScrollingDebounced);\n      };\n\n      _this._onScrollVertical = function (event) {\n        var scrollTop = event.currentTarget.scrollTop;\n\n        _this.setState(function (prevState) {\n          if (prevState.scrollOffset === scrollTop) {\n            // Scroll position may have been updated by cDM/cDU,\n            // In which case we don't need to trigger another render,\n            // And we don't want to update state.isScrolling.\n            return null;\n          }\n\n          return {\n            isScrolling: true,\n            scrollDirection: prevState.scrollOffset < scrollTop ? 'forward' : 'backward',\n            scrollOffset: scrollTop,\n            scrollUpdateWasRequested: false\n          };\n        }, _this._resetIsScrollingDebounced);\n      };\n\n      _this._outerRefSetter = function (ref) {\n        var outerRef = _this.props.outerRef;\n        _this._outerRef = ref;\n\n        if (typeof outerRef === 'function') {\n          outerRef(ref);\n        } else if (outerRef != null && typeof outerRef === 'object' && outerRef.hasOwnProperty('current')) {\n          outerRef.current = ref;\n        }\n      };\n\n      _this._resetIsScrollingDebounced = function () {\n        if (_this._resetIsScrollingTimeoutId !== null) {\n          cancelTimeout(_this._resetIsScrollingTimeoutId);\n        }\n\n        _this._resetIsScrollingTimeoutId = requestTimeout(_this._resetIsScrolling, IS_SCROLLING_DEBOUNCE_INTERVAL);\n      };\n\n      _this._resetIsScrolling = function () {\n        _this._resetIsScrollingTimeoutId = null;\n\n        _this.setState({\n          isScrolling: false\n        }, function () {\n          // Clear style cache after state update has been committed.\n          // This way we don't break pure sCU for items that don't use isScrolling param.\n          _this._getItemStyleCache(-1, null);\n        });\n      };\n\n      _this._instanceProps = initInstanceProps(_this.props, _assertThisInitialized(_this));\n      return _this;\n    }\n\n    List.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, prevState) {\n      validateSharedProps(nextProps, prevState);\n      validateProps(nextProps);\n      return null;\n    };\n\n    var _proto = List.prototype;\n\n    _proto.scrollTo = function scrollTo(scrollOffset) {\n      this.setState(function (prevState) {\n        return {\n          scrollDirection: prevState.scrollOffset < scrollOffset ? 'forward' : 'backward',\n          scrollOffset: scrollOffset,\n          scrollUpdateWasRequested: true\n        };\n      }, this._resetIsScrollingDebounced);\n    };\n\n    _proto.scrollToItem = function scrollToItem(index, align) {\n      if (align === void 0) {\n        align = 'auto';\n      }\n\n      var scrollOffset = this.state.scrollOffset;\n      this.scrollTo(getOffsetForIndexAndAlignment(this.props, index, align, scrollOffset, this._instanceProps));\n    };\n\n    _proto.componentDidMount = function componentDidMount() {\n      var _this$props2 = this.props,\n          direction = _this$props2.direction,\n          initialScrollOffset = _this$props2.initialScrollOffset,\n          layout = _this$props2.layout;\n\n      if (typeof initialScrollOffset === 'number' && this._outerRef !== null) {\n        // TODO Deprecate direction \"horizontal\"\n        if (direction === 'horizontal' || layout === 'horizontal') {\n          this._outerRef.scrollLeft = initialScrollOffset;\n        } else {\n          this._outerRef.scrollTop = initialScrollOffset;\n        }\n      }\n\n      this._callPropsCallbacks();\n\n      this._commitHook();\n    };\n\n    _proto.componentDidUpdate = function componentDidUpdate() {\n      var _this$props3 = this.props,\n          direction = _this$props3.direction,\n          layout = _this$props3.layout;\n      var _this$state = this.state,\n          scrollOffset = _this$state.scrollOffset,\n          scrollUpdateWasRequested = _this$state.scrollUpdateWasRequested;\n\n      if (scrollUpdateWasRequested && this._outerRef !== null) {\n        // TODO Deprecate direction \"horizontal\"\n        if (direction === 'horizontal' || layout === 'horizontal') {\n          this._outerRef.scrollLeft = scrollOffset;\n        } else {\n          this._outerRef.scrollTop = scrollOffset;\n        }\n      }\n\n      this._callPropsCallbacks();\n\n      this._commitHook();\n    };\n\n    _proto.componentWillUnmount = function componentWillUnmount() {\n      if (this._resetIsScrollingTimeoutId !== null) {\n        cancelTimeout(this._resetIsScrollingTimeoutId);\n      }\n\n      this._unmountHook();\n    };\n\n    _proto.render = function render() {\n      var _this$props4 = this.props,\n          className = _this$props4.className,\n          direction = _this$props4.direction,\n          height = _this$props4.height,\n          innerRef = _this$props4.innerRef,\n          innerElementType = _this$props4.innerElementType,\n          innerTagName = _this$props4.innerTagName,\n          layout = _this$props4.layout,\n          outerElementType = _this$props4.outerElementType,\n          outerTagName = _this$props4.outerTagName,\n          style = _this$props4.style,\n          width = _this$props4.width;\n      var isScrolling = this.state.isScrolling; // TODO Deprecate direction \"horizontal\"\n\n      var isHorizontal = direction === 'horizontal' || layout === 'horizontal';\n      var onScroll = isHorizontal ? this._onScrollHorizontal : this._onScrollVertical;\n\n      var items = this._renderItems(); // Read this value AFTER items have been created,\n      // So their actual sizes (if variable) are taken into consideration.\n\n\n      var estimatedTotalSize = getEstimatedTotalSize(this.props, this._instanceProps);\n      return createElement(outerElementType || outerTagName || 'div', {\n        className: className,\n        onScroll: onScroll,\n        ref: this._outerRefSetter,\n        style: _extends({\n          height: height,\n          width: width,\n          overflow: 'auto',\n          position: 'relative',\n          WebkitOverflowScrolling: 'touch',\n          willChange: 'transform',\n          direction: direction\n        }, style)\n      }, createElement(innerElementType || innerTagName || 'div', {\n        children: items,\n        ref: innerRef,\n        style: {\n          height: isHorizontal ? '100%' : estimatedTotalSize,\n          pointerEvents: isScrolling ? 'none' : '',\n          width: isHorizontal ? estimatedTotalSize : '100%'\n        }\n      }));\n    };\n\n    _proto._callPropsCallbacks = function _callPropsCallbacks() {\n      if (typeof this.props.onItemsRendered === 'function') {\n        var itemCount = this.props.itemCount;\n\n        if (itemCount > 0) {\n          var _this$_getRangeToRend = this._getRangeToRender(),\n              _overscanStartIndex = _this$_getRangeToRend[0],\n              _overscanStopIndex = _this$_getRangeToRend[1],\n              _visibleStartIndex = _this$_getRangeToRend[2],\n              _visibleStopIndex = _this$_getRangeToRend[3];\n\n          this._callOnItemsRendered(_overscanStartIndex, _overscanStopIndex, _visibleStartIndex, _visibleStopIndex);\n        }\n      }\n\n      if (typeof this.props.onScroll === 'function') {\n        var _this$state2 = this.state,\n            _scrollDirection = _this$state2.scrollDirection,\n            _scrollOffset = _this$state2.scrollOffset,\n            _scrollUpdateWasRequested = _this$state2.scrollUpdateWasRequested;\n\n        this._callOnScroll(_scrollDirection, _scrollOffset, _scrollUpdateWasRequested);\n      }\n    } // This method is called after mount and update.\n    // List implementations can override this method to be notified.\n    ;\n\n    _proto._commitHook = function _commitHook() {} // This method is called before unmounting.\n    // List implementations can override this method to be notified.\n    ;\n\n    _proto._unmountHook = function _unmountHook() {} // Lazily create and cache item styles while scrolling,\n    // So that pure component sCU will prevent re-renders.\n    // We maintain this cache, and pass a style prop rather than index,\n    // So that List can clear cached styles and force item re-render if necessary.\n    ;\n\n    _proto._getRangeToRender = function _getRangeToRender() {\n      var _this$props5 = this.props,\n          itemCount = _this$props5.itemCount,\n          overscanCount = _this$props5.overscanCount;\n      var _this$state3 = this.state,\n          isScrolling = _this$state3.isScrolling,\n          scrollDirection = _this$state3.scrollDirection,\n          scrollOffset = _this$state3.scrollOffset;\n\n      if (itemCount === 0) {\n        return [0, 0, 0, 0];\n      }\n\n      var startIndex = getStartIndexForOffset(this.props, scrollOffset, this._instanceProps);\n      var stopIndex = getStopIndexForStartIndex(this.props, startIndex, scrollOffset, this._instanceProps); // Overscan by one item in each direction so that tab/focus works.\n      // If there isn't at least one extra item, tab loops back around.\n\n      var overscanBackward = !isScrolling || scrollDirection === 'backward' ? Math.max(1, overscanCount) : 1;\n      var overscanForward = !isScrolling || scrollDirection === 'forward' ? Math.max(1, overscanCount) : 1;\n      return [Math.max(0, startIndex - overscanBackward), Math.max(0, Math.min(itemCount - 1, stopIndex + overscanForward)), startIndex, stopIndex];\n    };\n\n    _proto._renderItems = function _renderItems() {\n      var _this$props6 = this.props,\n          children = _this$props6.children,\n          itemCount = _this$props6.itemCount,\n          itemData = _this$props6.itemData,\n          _this$props6$itemKey = _this$props6.itemKey,\n          itemKey = _this$props6$itemKey === void 0 ? defaultItemKey : _this$props6$itemKey,\n          useIsScrolling = _this$props6.useIsScrolling;\n      var isScrolling = this.state.isScrolling;\n\n      var _this$_getRangeToRend2 = this._getRangeToRender(),\n          startIndex = _this$_getRangeToRend2[0],\n          stopIndex = _this$_getRangeToRend2[1];\n\n      var items = [];\n\n      if (itemCount > 0) {\n        for (var _index = startIndex; _index <= stopIndex; _index++) {\n          items.push(createElement(children, {\n            data: itemData,\n            key: itemKey(_index, itemData),\n            index: _index,\n            isScrolling: useIsScrolling ? isScrolling : undefined,\n            style: this._getItemStyle(_index)\n          }));\n        }\n      }\n\n      return items;\n    };\n\n    return List;\n  }(PureComponent), _class.defaultProps = {\n    direction: 'ltr',\n    itemData: undefined,\n    layout: 'vertical',\n    overscanCount: 2,\n    useIsScrolling: false\n  }, _temp;\n} // NOTE: I considered further wrapping individual items with a pure ListItem component.\n// This would avoid ever calling the render function for the same index more than once,\n// But it would also add the overhead of a lot of components/fibers.\n// I assume people already do this (render function returning a class component),\n// So my doing it would just unnecessarily double the wrappers.\n\n\nvar validateSharedProps = function validateSharedProps(_ref2, _ref3) {\n  var children = _ref2.children,\n      direction = _ref2.direction,\n      height = _ref2.height,\n      layout = _ref2.layout,\n      innerTagName = _ref2.innerTagName,\n      outerTagName = _ref2.outerTagName,\n      width = _ref2.width;\n  var instance = _ref3.instance;\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (innerTagName != null || outerTagName != null) {\n      if (devWarningsTagName && !devWarningsTagName.has(instance)) {\n        devWarningsTagName.add(instance);\n        console.warn('The innerTagName and outerTagName props have been deprecated. ' + 'Please use the innerElementType and outerElementType props instead.');\n      }\n    } // TODO Deprecate direction \"horizontal\"\n\n\n    var isHorizontal = direction === 'horizontal' || layout === 'horizontal';\n\n    switch (direction) {\n      case 'horizontal':\n      case 'vertical':\n        if (devWarningsDirection && !devWarningsDirection.has(instance)) {\n          devWarningsDirection.add(instance);\n          console.warn('The direction prop should be either \"ltr\" (default) or \"rtl\". ' + 'Please use the layout prop to specify \"vertical\" (default) or \"horizontal\" orientation.');\n        }\n\n        break;\n\n      case 'ltr':\n      case 'rtl':\n        // Valid values\n        break;\n\n      default:\n        throw Error('An invalid \"direction\" prop has been specified. ' + 'Value should be either \"ltr\" or \"rtl\". ' + (\"\\\"\" + direction + \"\\\" was specified.\"));\n    }\n\n    switch (layout) {\n      case 'horizontal':\n      case 'vertical':\n        // Valid values\n        break;\n\n      default:\n        throw Error('An invalid \"layout\" prop has been specified. ' + 'Value should be either \"horizontal\" or \"vertical\". ' + (\"\\\"\" + layout + \"\\\" was specified.\"));\n    }\n\n    if (children == null) {\n      throw Error('An invalid \"children\" prop has been specified. ' + 'Value should be a React component. ' + (\"\\\"\" + (children === null ? 'null' : typeof children) + \"\\\" was specified.\"));\n    }\n\n    if (isHorizontal && typeof width !== 'number') {\n      throw Error('An invalid \"width\" prop has been specified. ' + 'Horizontal lists must specify a number for width. ' + (\"\\\"\" + (width === null ? 'null' : typeof width) + \"\\\" was specified.\"));\n    } else if (!isHorizontal && typeof height !== 'number') {\n      throw Error('An invalid \"height\" prop has been specified. ' + 'Vertical lists must specify a number for height. ' + (\"\\\"\" + (height === null ? 'null' : typeof height) + \"\\\" was specified.\"));\n    }\n  }\n};\n\nvar findDOMNodeWarningsSet = null;\n\nif (process.env.NODE_ENV !== 'production') {\n  findDOMNodeWarningsSet = /*#__PURE__*/new Set();\n}\n\nvar ItemMeasurer = /*#__PURE__*/function (_Component) {\n  _inheritsLoose(ItemMeasurer, _Component);\n\n  function ItemMeasurer() {\n    var _this;\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _Component.call.apply(_Component, [this].concat(args)) || this;\n    _this._didProvideValidRef = false;\n    _this._node = null;\n    _this._resizeObserver = null;\n\n    _this._measureItem = function (isCommitPhase) {\n      var _this$props = _this.props,\n          direction = _this$props.direction,\n          layout = _this$props.layout,\n          handleNewMeasurements = _this$props.handleNewMeasurements,\n          index = _this$props.index,\n          oldSize = _this$props.size;\n      var node = _this._node;\n\n      if (node && node.ownerDocument && node.ownerDocument.defaultView && node instanceof node.ownerDocument.defaultView.HTMLElement) {\n        var newSize = direction === 'horizontal' || layout === 'horizontal' ? Math.ceil(node.offsetWidth) : Math.ceil(node.offsetHeight);\n\n        if (oldSize !== newSize) {\n          handleNewMeasurements(index, newSize, isCommitPhase);\n        }\n      }\n    };\n\n    _this._refSetter = function (ref) {\n      if (_this._resizeObserver !== null && _this._node !== null) {\n        _this._resizeObserver.unobserve(_this._node);\n      }\n\n      if (ref instanceof HTMLElement) {\n        _this._didProvideValidRef = true;\n        _this._node = ref;\n      } else if (ref !== null) {\n        _this._node = findDOMNode(ref);\n      }\n\n      if (_this._resizeObserver !== null && _this._node !== null) {\n        _this._resizeObserver.observe(_this._node);\n      }\n    };\n\n    _this._onResize = function () {\n      _this._measureItem(false);\n    };\n\n    return _this;\n  }\n\n  var _proto = ItemMeasurer.prototype;\n\n  _proto.componentDidMount = function componentDidMount() {\n    if (process.env.NODE_ENV !== 'production') {\n      if (!this._didProvideValidRef) {\n        var item = this.props.item;\n        var displayName = item && item.type ? item.type.displayName || item.type.name || '(unknown)' : '(unknown)';\n\n        if (!findDOMNodeWarningsSet.has(displayName)) {\n          findDOMNodeWarningsSet.add(displayName);\n          console.warn('DynamicSizeList item renderers should attach a ref to the topmost HTMLElement they render. ' + (\"The item renderer \\\"\" + displayName + \"\\\" did not attach a ref to a valid HTMLElement. \") + 'findDOMNode() will be used as a fallback, but is slower and more error prone than using a ref.\\n\\n' + 'Learn more about ref forwarding: ' + 'https://reactjs.org/docs/forwarding-refs.html#forwarding-refs-to-dom-components');\n        }\n      }\n    } // Force sync measure for the initial mount.\n    // This is necessary to support the DynamicSizeList layout logic.\n\n\n    this._measureItem(true);\n\n    if (typeof ResizeObserver !== 'undefined') {\n      // Watch for resizes due to changed content,\n      // Or changes in the size of the parent container.\n      this._resizeObserver = new ResizeObserver(this._onResize);\n\n      if (this._node !== null) {\n        this._resizeObserver.observe(this._node);\n      }\n    }\n  };\n\n  _proto.componentWillUnmount = function componentWillUnmount() {\n    if (this._resizeObserver !== null) {\n      this._resizeObserver.disconnect();\n    }\n  };\n\n  _proto.render = function render() {\n    return cloneElement(this.props.item, {\n      ref: this._refSetter\n    });\n  };\n\n  return ItemMeasurer;\n}(Component);\n\nvar DEFAULT_ESTIMATED_ITEM_SIZE = 50;\n\nvar getItemMetadata = function getItemMetadata(props, index, instanceProps) {\n  var estimatedItemSize = instanceProps.estimatedItemSize,\n      instance = instanceProps.instance,\n      itemOffsetMap = instanceProps.itemOffsetMap,\n      itemSizeMap = instanceProps.itemSizeMap,\n      lastMeasuredIndex = instanceProps.lastMeasuredIndex,\n      lastPositionedIndex = instanceProps.lastPositionedIndex; // If the specified item has not yet been measured,\n  // Just return an estimated size for now.\n\n  if (index > lastMeasuredIndex) {\n    return {\n      offset: 0,\n      size: estimatedItemSize\n    };\n  } // Lazily update positions if they are stale.\n\n\n  if (index > lastPositionedIndex) {\n    if (lastPositionedIndex < 0) {\n      itemOffsetMap[0] = 0;\n    }\n\n    for (var i = Math.max(1, lastPositionedIndex + 1); i <= index; i++) {\n      var prevOffset = itemOffsetMap[i - 1]; // In some browsers (e.g. Firefox) fast scrolling may skip rows.\n      // In this case, our assumptions about last measured indices may be incorrect.\n      // Handle this edge case to prevent NaN values from breaking styles.\n      // Slow scrolling back over these skipped rows will adjust their sizes.\n\n      var prevSize = itemSizeMap[i - 1] || 0;\n      itemOffsetMap[i] = prevOffset + prevSize; // Reset cached style to clear stale position.\n\n      delete instance._itemStyleCache[i];\n    }\n\n    instanceProps.lastPositionedIndex = index;\n  }\n\n  var offset = itemOffsetMap[index];\n  var size = itemSizeMap[index];\n  return {\n    offset: offset,\n    size: size\n  };\n};\n\nvar findNearestItemBinarySearch = function findNearestItemBinarySearch(props, instanceProps, high, low, offset) {\n  while (low <= high) {\n    var middle = low + Math.floor((high - low) / 2);\n    var currentOffset = getItemMetadata(props, middle, instanceProps).offset;\n\n    if (currentOffset === offset) {\n      return middle;\n    } else if (currentOffset < offset) {\n      low = middle + 1;\n    } else if (currentOffset > offset) {\n      high = middle - 1;\n    }\n  }\n\n  if (low > 0) {\n    return low - 1;\n  } else {\n    return 0;\n  }\n};\n\nvar getEstimatedTotalSize = function getEstimatedTotalSize(_ref, _ref2) {\n  var itemCount = _ref.itemCount;\n  var itemSizeMap = _ref2.itemSizeMap,\n      estimatedItemSize = _ref2.estimatedItemSize,\n      lastMeasuredIndex = _ref2.lastMeasuredIndex,\n      totalMeasuredSize = _ref2.totalMeasuredSize;\n  return totalMeasuredSize + (itemCount - lastMeasuredIndex - 1) * estimatedItemSize;\n};\n\nvar DynamicSizeList = /*#__PURE__*/createListComponent({\n  getItemOffset: function getItemOffset(props, index, instanceProps) {\n    return getItemMetadata(props, index, instanceProps).offset;\n  },\n  getItemSize: function getItemSize(props, index, instanceProps) {\n    // Do not hard-code item dimensions.\n    // We don't know them initially.\n    // Even once we do, changes in item content or list size should reflow.\n    return undefined;\n  },\n  getEstimatedTotalSize: getEstimatedTotalSize,\n  getOffsetForIndexAndAlignment: function getOffsetForIndexAndAlignment(props, index, align, scrollOffset, instanceProps) {\n    var direction = props.direction,\n        layout = props.layout,\n        height = props.height,\n        width = props.width;\n\n    if (process.env.NODE_ENV !== 'production') {\n      var lastMeasuredIndex = instanceProps.lastMeasuredIndex;\n\n      if (index > lastMeasuredIndex) {\n        console.warn(\"DynamicSizeList does not support scrolling to items that yave not yet measured. \" + (\"scrollToItem() was called with index \" + index + \" but the last measured item was \" + lastMeasuredIndex + \".\"));\n      }\n    }\n\n    var size = direction === 'horizontal' || layout === 'horizontal' ? width : height;\n    var itemMetadata = getItemMetadata(props, index, instanceProps); // Get estimated total size after ItemMetadata is computed,\n    // To ensure it reflects actual measurements instead of just estimates.\n\n    var estimatedTotalSize = getEstimatedTotalSize(props, instanceProps);\n    var maxOffset = Math.min(estimatedTotalSize - size, itemMetadata.offset);\n    var minOffset = Math.max(0, itemMetadata.offset - size + itemMetadata.size);\n\n    switch (align) {\n      case 'start':\n        return maxOffset;\n\n      case 'end':\n        return minOffset;\n\n      case 'center':\n        return Math.round(minOffset + (maxOffset - minOffset) / 2);\n\n      case 'auto':\n      default:\n        if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {\n          return scrollOffset;\n        } else if (scrollOffset - minOffset < maxOffset - scrollOffset) {\n          return minOffset;\n        } else {\n          return maxOffset;\n        }\n\n    }\n  },\n  getStartIndexForOffset: function getStartIndexForOffset(props, offset, instanceProps) {\n    var lastMeasuredIndex = instanceProps.lastMeasuredIndex,\n        totalMeasuredSize = instanceProps.totalMeasuredSize; // If we've already positioned and measured past this point,\n    // Use a binary search to find the closets cell.\n\n    if (offset <= totalMeasuredSize) {\n      return findNearestItemBinarySearch(props, instanceProps, lastMeasuredIndex, 0, offset);\n    } // Otherwise render a new batch of items starting from where we left off.\n\n\n    return lastMeasuredIndex + 1;\n  },\n  getStopIndexForStartIndex: function getStopIndexForStartIndex(props, startIndex, scrollOffset, instanceProps) {\n    var direction = props.direction,\n        layout = props.layout,\n        height = props.height,\n        itemCount = props.itemCount,\n        width = props.width;\n    var size = direction === 'horizontal' || layout === 'horizontal' ? width : height;\n    var itemMetadata = getItemMetadata(props, startIndex, instanceProps);\n    var maxOffset = scrollOffset + size;\n    var offset = itemMetadata.offset + itemMetadata.size;\n    var stopIndex = startIndex;\n\n    while (stopIndex < itemCount - 1 && offset < maxOffset) {\n      stopIndex++;\n      offset += getItemMetadata(props, stopIndex, instanceProps).size;\n    }\n\n    return stopIndex;\n  },\n  initInstanceProps: function initInstanceProps(props, instance) {\n    var _ref3 = props,\n        estimatedItemSize = _ref3.estimatedItemSize;\n    var instanceProps = {\n      estimatedItemSize: estimatedItemSize || DEFAULT_ESTIMATED_ITEM_SIZE,\n      instance: instance,\n      itemOffsetMap: {},\n      itemSizeMap: {},\n      lastMeasuredIndex: -1,\n      lastPositionedIndex: -1,\n      totalMeasuredSize: 0\n    };\n    var debounceForceUpdateID = null;\n\n    var debounceForceUpdate = function debounceForceUpdate() {\n      if (debounceForceUpdateID === null) {\n        debounceForceUpdateID = setTimeout(function () {\n          debounceForceUpdateID = null;\n          instance.forceUpdate();\n        }, 1);\n      }\n    }; // This method is called before unmounting.\n\n\n    instance._unmountHook = function () {\n      if (debounceForceUpdateID !== null) {\n        clearTimeout(debounceForceUpdateID);\n        debounceForceUpdateID = null;\n      }\n    };\n\n    var hasNewMeasurements = false;\n    var sizeDeltaTotal = 0; // This method is called after mount and update.\n\n    instance._commitHook = function () {\n      if (hasNewMeasurements) {\n        hasNewMeasurements = false; // Edge case where cell sizes changed, but cancelled each other out.\n        // We still need to re-render in this case,\n        // Even though we don't need to adjust scroll offset.\n\n        if (sizeDeltaTotal === 0) {\n          instance.forceUpdate();\n          return;\n        }\n\n        var shouldForceUpdate; // In the setState commit hook, we'll decrement sizeDeltaTotal.\n        // In case the state update is processed synchronously,\n        // And triggers additional size updates itself,\n        // We should only drecement by the amount we updated state for originally.\n\n        var sizeDeltaForStateUpdate = sizeDeltaTotal; // If the user is scrolling up, we need to adjust the scroll offset,\n        // To prevent items from \"jumping\" as items before them have been resized.\n\n        instance.setState(function (prevState) {\n          if (prevState.scrollDirection === 'backward' && !prevState.scrollUpdateWasRequested) {\n            // TRICKY\n            // If item(s) have changed size since they were last displayed, content will appear to jump.\n            // To avoid this, we need to make small adjustments as a user scrolls to preserve apparent position.\n            // This also ensures that the first item eventually aligns with scroll offset 0.\n            return {\n              scrollOffset: prevState.scrollOffset + sizeDeltaForStateUpdate\n            };\n          } else {\n            // There's no state to update,\n            // But we still want to re-render in this case.\n            shouldForceUpdate = true;\n            return null;\n          }\n        }, function () {\n          if (shouldForceUpdate) {\n            instance.forceUpdate();\n          } else {\n            var scrollOffset = instance.state.scrollOffset;\n            var _instance$props = instance.props,\n                direction = _instance$props.direction,\n                layout = _instance$props.layout; // Adjusting scroll offset directly interrupts smooth scrolling for some browsers (e.g. Firefox).\n            // The relative scrollBy() method doesn't interrupt (or at least it won't as of Firefox v65).\n            // Other browsers (e.g. Chrome, Safari) seem to handle both adjustments equally well.\n            // See https://bugzilla.mozilla.org/show_bug.cgi?id=1502059\n\n            var element = instance._outerRef; // $FlowFixMe Property scrollBy is missing in HTMLDivElement\n\n            if (typeof element.scrollBy === 'function') {\n              element.scrollBy(direction === 'horizontal' || layout === 'horizontal' ? sizeDeltaForStateUpdate : 0, direction === 'horizontal' || layout === 'horizontal' ? 0 : sizeDeltaForStateUpdate);\n            } else if (direction === 'horizontal' || layout === 'horizontal') {\n              element.scrollLeft = scrollOffset;\n            } else {\n              element.scrollTop = scrollOffset;\n            }\n          }\n\n          sizeDeltaTotal -= sizeDeltaForStateUpdate;\n        });\n      }\n    }; // This function may be called out of order!\n    // It is not safe to reposition items here.\n    // Be careful when comparing index and lastMeasuredIndex.\n\n\n    var handleNewMeasurements = function handleNewMeasurements(index, newSize, isFirstMeasureAfterMounting) {\n      var itemSizeMap = instanceProps.itemSizeMap,\n          lastMeasuredIndex = instanceProps.lastMeasuredIndex,\n          lastPositionedIndex = instanceProps.lastPositionedIndex; // In some browsers (e.g. Firefox) fast scrolling may skip rows.\n      // In this case, our assumptions about last measured indices may be incorrect.\n      // Handle this edge case to prevent NaN values from breaking styles.\n      // Slow scrolling back over these skipped rows will adjust their sizes.\n\n      var oldSize = itemSizeMap[index] || 0; // Mark offsets after this as stale so that getItemMetadata() will lazily recalculate it.\n\n      if (index < lastPositionedIndex) {\n        instanceProps.lastPositionedIndex = index;\n      }\n\n      if (index <= lastMeasuredIndex) {\n        if (oldSize === newSize) {\n          return;\n        } // Adjust total size estimate by the delta in size.\n\n\n        instanceProps.totalMeasuredSize += newSize - oldSize; // Record the size delta here in case the user is scrolling up.\n        // In that event, we need to adjust the scroll offset by thie amount,\n        // To prevent items from \"jumping\" as items before them are resized.\n        // We only do this for items that are newly measured (after mounting).\n        // Ones that change size later do not need to affect scroll offset.\n\n        if (isFirstMeasureAfterMounting) {\n          sizeDeltaTotal += newSize - oldSize;\n        }\n      } else {\n        instanceProps.lastMeasuredIndex = index;\n        instanceProps.totalMeasuredSize += newSize;\n      }\n\n      itemSizeMap[index] = newSize; // Even though the size has changed, we don't need to reset the cached style,\n      // Because dynamic list items don't have constrained sizes.\n      // This enables them to resize when their content (or container size) changes.\n      // It also lets us avoid an unnecessary render in this case.\n\n      if (isFirstMeasureAfterMounting) {\n        hasNewMeasurements = true;\n      } else {\n        debounceForceUpdate();\n      }\n    };\n\n    instance._handleNewMeasurements = handleNewMeasurements; // Override the item-rendering process to wrap items with ItemMeasurer.\n    // This keep the external API simpler.\n\n    instance._renderItems = function () {\n      var _instance$props2 = instance.props,\n          children = _instance$props2.children,\n          direction = _instance$props2.direction,\n          layout = _instance$props2.layout,\n          itemCount = _instance$props2.itemCount,\n          itemData = _instance$props2.itemData,\n          _instance$props2$item = _instance$props2.itemKey,\n          itemKey = _instance$props2$item === void 0 ? defaultItemKey : _instance$props2$item,\n          useIsScrolling = _instance$props2.useIsScrolling;\n      var isScrolling = instance.state.isScrolling;\n\n      var _instance$_getRangeTo = instance._getRangeToRender(),\n          startIndex = _instance$_getRangeTo[0],\n          stopIndex = _instance$_getRangeTo[1];\n\n      var items = [];\n\n      if (itemCount > 0) {\n        for (var _index = startIndex; _index <= stopIndex; _index++) {\n          var _getItemMetadata = getItemMetadata(instance.props, _index, instanceProps),\n              size = _getItemMetadata.size; // It's important to read style after fetching item metadata.\n          // getItemMetadata() will clear stale styles.\n\n\n          var style = instance._getItemStyle(_index);\n\n          var item = createElement(children, {\n            data: itemData,\n            index: _index,\n            isScrolling: useIsScrolling ? isScrolling : undefined,\n            style: style\n          }); // Always wrap children in a ItemMeasurer to detect changes in size.\n\n          items.push(createElement(ItemMeasurer, {\n            direction: direction,\n            layout: layout,\n            handleNewMeasurements: handleNewMeasurements,\n            index: _index,\n            item: item,\n            key: itemKey(_index),\n            size: size\n          }));\n        }\n      }\n\n      return items;\n    };\n\n    return instanceProps;\n  },\n  shouldResetStyleCacheOnItemSizeChange: false,\n  validateProps: function validateProps(_ref4) {\n    var itemSize = _ref4.itemSize;\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (itemSize !== undefined) {\n        throw Error('An unexpected \"itemSize\" prop has been provided.');\n      }\n    }\n  }\n});\nvar size = -1; // This utility copied from \"dom-helpers\" package.\n\nfunction getScrollbarSize(recalculate) {\n  if (recalculate === void 0) {\n    recalculate = false;\n  }\n\n  if (size === -1 || recalculate) {\n    var div = document.createElement('div');\n    var style = div.style;\n    style.width = '50px';\n    style.height = '50px';\n    style.overflow = 'scroll';\n    document.body.appendChild(div);\n    size = div.offsetWidth - div.clientWidth;\n    document.body.removeChild(div);\n  }\n\n  return size;\n}\n\nvar IS_SCROLLING_DEBOUNCE_INTERVAL$1 = 150;\n\nvar defaultItemKey$1 = function defaultItemKey(_ref) {\n  var columnIndex = _ref.columnIndex,\n      data = _ref.data,\n      rowIndex = _ref.rowIndex;\n  return rowIndex + \":\" + columnIndex;\n}; // In DEV mode, this Set helps us only log a warning once per component instace.\n// This avoids spamming the console every time a render happens.\n\n\nvar devWarningsOverscanCount = null;\nvar devWarningsTagName$1 = null;\n\nif (process.env.NODE_ENV !== 'production') {\n  if (typeof window !== 'undefined' && typeof window.WeakSet !== 'undefined') {\n    devWarningsOverscanCount = /*#__PURE__*/new WeakSet();\n    devWarningsTagName$1 = /*#__PURE__*/new WeakSet();\n  }\n}\n\nfunction createGridComponent(_ref2) {\n  var _class, _temp;\n\n  var getColumnOffset = _ref2.getColumnOffset,\n      getColumnStartIndexForOffset = _ref2.getColumnStartIndexForOffset,\n      getColumnStopIndexForStartIndex = _ref2.getColumnStopIndexForStartIndex,\n      getColumnWidth = _ref2.getColumnWidth,\n      getEstimatedTotalHeight = _ref2.getEstimatedTotalHeight,\n      getEstimatedTotalWidth = _ref2.getEstimatedTotalWidth,\n      getOffsetForColumnAndAlignment = _ref2.getOffsetForColumnAndAlignment,\n      getOffsetForRowAndAlignment = _ref2.getOffsetForRowAndAlignment,\n      getRowHeight = _ref2.getRowHeight,\n      getRowOffset = _ref2.getRowOffset,\n      getRowStartIndexForOffset = _ref2.getRowStartIndexForOffset,\n      getRowStopIndexForStartIndex = _ref2.getRowStopIndexForStartIndex,\n      initInstanceProps = _ref2.initInstanceProps,\n      shouldResetStyleCacheOnItemSizeChange = _ref2.shouldResetStyleCacheOnItemSizeChange,\n      validateProps = _ref2.validateProps;\n  return _temp = _class = /*#__PURE__*/function (_PureComponent) {\n    _inheritsLoose(Grid, _PureComponent); // Always use explicit constructor for React components.\n    // It produces less code after transpilation. (#26)\n    // eslint-disable-next-line no-useless-constructor\n\n\n    function Grid(props) {\n      var _this;\n\n      _this = _PureComponent.call(this, props) || this;\n      _this._instanceProps = initInstanceProps(_this.props, _assertThisInitialized(_this));\n      _this._resetIsScrollingTimeoutId = null;\n      _this._outerRef = void 0;\n      _this.state = {\n        instance: _assertThisInitialized(_this),\n        isScrolling: false,\n        horizontalScrollDirection: 'forward',\n        scrollLeft: typeof _this.props.initialScrollLeft === 'number' ? _this.props.initialScrollLeft : 0,\n        scrollTop: typeof _this.props.initialScrollTop === 'number' ? _this.props.initialScrollTop : 0,\n        scrollUpdateWasRequested: false,\n        verticalScrollDirection: 'forward'\n      };\n      _this._callOnItemsRendered = void 0;\n      _this._callOnItemsRendered = memoizeOne(function (overscanColumnStartIndex, overscanColumnStopIndex, overscanRowStartIndex, overscanRowStopIndex, visibleColumnStartIndex, visibleColumnStopIndex, visibleRowStartIndex, visibleRowStopIndex) {\n        return _this.props.onItemsRendered({\n          overscanColumnStartIndex: overscanColumnStartIndex,\n          overscanColumnStopIndex: overscanColumnStopIndex,\n          overscanRowStartIndex: overscanRowStartIndex,\n          overscanRowStopIndex: overscanRowStopIndex,\n          visibleColumnStartIndex: visibleColumnStartIndex,\n          visibleColumnStopIndex: visibleColumnStopIndex,\n          visibleRowStartIndex: visibleRowStartIndex,\n          visibleRowStopIndex: visibleRowStopIndex\n        });\n      });\n      _this._callOnScroll = void 0;\n      _this._callOnScroll = memoizeOne(function (scrollLeft, scrollTop, horizontalScrollDirection, verticalScrollDirection, scrollUpdateWasRequested) {\n        return _this.props.onScroll({\n          horizontalScrollDirection: horizontalScrollDirection,\n          scrollLeft: scrollLeft,\n          scrollTop: scrollTop,\n          verticalScrollDirection: verticalScrollDirection,\n          scrollUpdateWasRequested: scrollUpdateWasRequested\n        });\n      });\n      _this._getItemStyle = void 0;\n\n      _this._getItemStyle = function (rowIndex, columnIndex) {\n        var _this$props = _this.props,\n            columnWidth = _this$props.columnWidth,\n            direction = _this$props.direction,\n            rowHeight = _this$props.rowHeight;\n\n        var itemStyleCache = _this._getItemStyleCache(shouldResetStyleCacheOnItemSizeChange && columnWidth, shouldResetStyleCacheOnItemSizeChange && direction, shouldResetStyleCacheOnItemSizeChange && rowHeight);\n\n        var key = rowIndex + \":\" + columnIndex;\n        var style;\n\n        if (itemStyleCache.hasOwnProperty(key)) {\n          style = itemStyleCache[key];\n        } else {\n          var _style;\n\n          itemStyleCache[key] = style = (_style = {\n            position: 'absolute'\n          }, _style[direction === 'rtl' ? 'right' : 'left'] = getColumnOffset(_this.props, columnIndex, _this._instanceProps), _style.top = getRowOffset(_this.props, rowIndex, _this._instanceProps), _style.height = getRowHeight(_this.props, rowIndex, _this._instanceProps), _style.width = getColumnWidth(_this.props, columnIndex, _this._instanceProps), _style);\n        }\n\n        return style;\n      };\n\n      _this._getItemStyleCache = void 0;\n      _this._getItemStyleCache = memoizeOne(function (_, __, ___) {\n        return {};\n      });\n\n      _this._onScroll = function (event) {\n        var _event$currentTarget = event.currentTarget,\n            clientWidth = _event$currentTarget.clientWidth,\n            scrollLeft = _event$currentTarget.scrollLeft,\n            scrollTop = _event$currentTarget.scrollTop,\n            scrollWidth = _event$currentTarget.scrollWidth;\n\n        _this.setState(function (prevState) {\n          if (prevState.scrollLeft === scrollLeft && prevState.scrollTop === scrollTop) {\n            // Scroll position may have been updated by cDM/cDU,\n            // In which case we don't need to trigger another render,\n            // And we don't want to update state.isScrolling.\n            return null;\n          }\n\n          var direction = _this.props.direction; // HACK According to the spec, scrollLeft should be negative for RTL aligned elements.\n          // Chrome does not seem to adhere; its scrolLeft values are positive (measured relative to the left).\n          // See https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollLeft\n\n          var calculatedScrollLeft = scrollLeft;\n\n          if (direction === 'rtl') {\n            if (scrollLeft <= 0) {\n              calculatedScrollLeft = -scrollLeft;\n            } else {\n              calculatedScrollLeft = scrollWidth - clientWidth - scrollLeft;\n            }\n          }\n\n          return {\n            isScrolling: true,\n            horizontalScrollDirection: prevState.scrollLeft < scrollLeft ? 'forward' : 'backward',\n            scrollLeft: calculatedScrollLeft,\n            scrollTop: scrollTop,\n            verticalScrollDirection: prevState.scrollTop < scrollTop ? 'forward' : 'backward',\n            scrollUpdateWasRequested: false\n          };\n        }, _this._resetIsScrollingDebounced);\n      };\n\n      _this._outerRefSetter = function (ref) {\n        var outerRef = _this.props.outerRef;\n        _this._outerRef = ref;\n\n        if (typeof outerRef === 'function') {\n          outerRef(ref);\n        } else if (outerRef != null && typeof outerRef === 'object' && outerRef.hasOwnProperty('current')) {\n          outerRef.current = ref;\n        }\n      };\n\n      _this._resetIsScrollingDebounced = function () {\n        if (_this._resetIsScrollingTimeoutId !== null) {\n          cancelTimeout(_this._resetIsScrollingTimeoutId);\n        }\n\n        _this._resetIsScrollingTimeoutId = requestTimeout(_this._resetIsScrolling, IS_SCROLLING_DEBOUNCE_INTERVAL$1);\n      };\n\n      _this._resetIsScrolling = function () {\n        _this._resetIsScrollingTimeoutId = null;\n\n        _this.setState({\n          isScrolling: false\n        }, function () {\n          // Clear style cache after state update has been committed.\n          // This way we don't break pure sCU for items that don't use isScrolling param.\n          _this._getItemStyleCache(-1);\n        });\n      };\n\n      return _this;\n    }\n\n    Grid.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, prevState) {\n      validateSharedProps$1(nextProps, prevState);\n      validateProps(nextProps);\n      return null;\n    };\n\n    var _proto = Grid.prototype;\n\n    _proto.scrollTo = function scrollTo(_ref3) {\n      var scrollLeft = _ref3.scrollLeft,\n          scrollTop = _ref3.scrollTop;\n      this.setState(function (prevState) {\n        if (scrollLeft === undefined) {\n          scrollLeft = prevState.scrollLeft;\n        }\n\n        if (scrollTop === undefined) {\n          scrollTop = prevState.scrollTop;\n        }\n\n        return {\n          horizontalScrollDirection: prevState.scrollLeft < scrollLeft ? 'forward' : 'backward',\n          scrollLeft: scrollLeft,\n          scrollTop: scrollTop,\n          scrollUpdateWasRequested: true,\n          verticalScrollDirection: prevState.scrollTop < scrollTop ? 'forward' : 'backward'\n        };\n      }, this._resetIsScrollingDebounced);\n    };\n\n    _proto.scrollToItem = function scrollToItem(_ref4) {\n      var _ref4$align = _ref4.align,\n          align = _ref4$align === void 0 ? 'auto' : _ref4$align,\n          columnIndex = _ref4.columnIndex,\n          rowIndex = _ref4.rowIndex;\n      var _this$props2 = this.props,\n          height = _this$props2.height,\n          width = _this$props2.width;\n      var _this$state = this.state,\n          scrollLeft = _this$state.scrollLeft,\n          scrollTop = _this$state.scrollTop;\n      var scrollbarSize = getScrollbarSize();\n      var estimatedTotalHeight = getEstimatedTotalHeight(this.props, this._instanceProps);\n      var estimatedTotalWidth = getEstimatedTotalWidth(this.props, this._instanceProps); // The scrollbar size should be considered when scrolling an item into view,\n      // to ensure it's fully visible.\n      // But we only need to account for its size when it's actually visible.\n\n      var horizontalScrollbarSize = estimatedTotalWidth > width ? scrollbarSize : 0;\n      var verticalScrollbarSize = estimatedTotalHeight > height ? scrollbarSize : 0;\n      this.scrollTo({\n        scrollLeft: columnIndex !== undefined ? getOffsetForColumnAndAlignment(this.props, columnIndex, align, scrollLeft, this._instanceProps, verticalScrollbarSize) : scrollLeft,\n        scrollTop: rowIndex !== undefined ? getOffsetForRowAndAlignment(this.props, rowIndex, align, scrollTop, this._instanceProps, horizontalScrollbarSize) : scrollTop\n      });\n    };\n\n    _proto.componentDidMount = function componentDidMount() {\n      var _this$props3 = this.props,\n          initialScrollLeft = _this$props3.initialScrollLeft,\n          initialScrollTop = _this$props3.initialScrollTop;\n\n      if (typeof initialScrollLeft === 'number' && this._outerRef != null) {\n        this._outerRef.scrollLeft = initialScrollLeft;\n      }\n\n      if (typeof initialScrollTop === 'number' && this._outerRef != null) {\n        this._outerRef.scrollTop = initialScrollTop;\n      }\n\n      this._callPropsCallbacks();\n    };\n\n    _proto.componentDidUpdate = function componentDidUpdate() {\n      var _this$state2 = this.state,\n          scrollLeft = _this$state2.scrollLeft,\n          scrollTop = _this$state2.scrollTop,\n          scrollUpdateWasRequested = _this$state2.scrollUpdateWasRequested;\n\n      if (scrollUpdateWasRequested && this._outerRef !== null) {\n        this._outerRef.scrollLeft = scrollLeft;\n        this._outerRef.scrollTop = scrollTop;\n      }\n\n      this._callPropsCallbacks();\n    };\n\n    _proto.componentWillUnmount = function componentWillUnmount() {\n      if (this._resetIsScrollingTimeoutId !== null) {\n        cancelTimeout(this._resetIsScrollingTimeoutId);\n      }\n    };\n\n    _proto.render = function render() {\n      var _this$props4 = this.props,\n          children = _this$props4.children,\n          className = _this$props4.className,\n          columnCount = _this$props4.columnCount,\n          direction = _this$props4.direction,\n          height = _this$props4.height,\n          innerRef = _this$props4.innerRef,\n          innerElementType = _this$props4.innerElementType,\n          innerTagName = _this$props4.innerTagName,\n          itemData = _this$props4.itemData,\n          _this$props4$itemKey = _this$props4.itemKey,\n          itemKey = _this$props4$itemKey === void 0 ? defaultItemKey$1 : _this$props4$itemKey,\n          outerElementType = _this$props4.outerElementType,\n          outerTagName = _this$props4.outerTagName,\n          rowCount = _this$props4.rowCount,\n          style = _this$props4.style,\n          useIsScrolling = _this$props4.useIsScrolling,\n          width = _this$props4.width;\n      var isScrolling = this.state.isScrolling;\n\n      var _this$_getHorizontalR = this._getHorizontalRangeToRender(),\n          columnStartIndex = _this$_getHorizontalR[0],\n          columnStopIndex = _this$_getHorizontalR[1];\n\n      var _this$_getVerticalRan = this._getVerticalRangeToRender(),\n          rowStartIndex = _this$_getVerticalRan[0],\n          rowStopIndex = _this$_getVerticalRan[1];\n\n      var items = [];\n\n      if (columnCount > 0 && rowCount) {\n        for (var _rowIndex = rowStartIndex; _rowIndex <= rowStopIndex; _rowIndex++) {\n          for (var _columnIndex = columnStartIndex; _columnIndex <= columnStopIndex; _columnIndex++) {\n            items.push(createElement(children, {\n              columnIndex: _columnIndex,\n              data: itemData,\n              isScrolling: useIsScrolling ? isScrolling : undefined,\n              key: itemKey({\n                columnIndex: _columnIndex,\n                data: itemData,\n                rowIndex: _rowIndex\n              }),\n              rowIndex: _rowIndex,\n              style: this._getItemStyle(_rowIndex, _columnIndex)\n            }));\n          }\n        }\n      } // Read this value AFTER items have been created,\n      // So their actual sizes (if variable) are taken into consideration.\n\n\n      var estimatedTotalHeight = getEstimatedTotalHeight(this.props, this._instanceProps);\n      var estimatedTotalWidth = getEstimatedTotalWidth(this.props, this._instanceProps);\n      return createElement(outerElementType || outerTagName || 'div', {\n        className: className,\n        onScroll: this._onScroll,\n        ref: this._outerRefSetter,\n        style: _extends({\n          position: 'relative',\n          height: height,\n          width: width,\n          overflow: 'auto',\n          WebkitOverflowScrolling: 'touch',\n          willChange: 'transform',\n          direction: direction\n        }, style)\n      }, createElement(innerElementType || innerTagName || 'div', {\n        children: items,\n        ref: innerRef,\n        style: {\n          height: estimatedTotalHeight,\n          pointerEvents: isScrolling ? 'none' : '',\n          width: estimatedTotalWidth\n        }\n      }));\n    };\n\n    _proto._callPropsCallbacks = function _callPropsCallbacks() {\n      var _this$props5 = this.props,\n          columnCount = _this$props5.columnCount,\n          onItemsRendered = _this$props5.onItemsRendered,\n          onScroll = _this$props5.onScroll,\n          rowCount = _this$props5.rowCount;\n\n      if (typeof onItemsRendered === 'function') {\n        if (columnCount > 0 && rowCount > 0) {\n          var _this$_getHorizontalR2 = this._getHorizontalRangeToRender(),\n              _overscanColumnStartIndex = _this$_getHorizontalR2[0],\n              _overscanColumnStopIndex = _this$_getHorizontalR2[1],\n              _visibleColumnStartIndex = _this$_getHorizontalR2[2],\n              _visibleColumnStopIndex = _this$_getHorizontalR2[3];\n\n          var _this$_getVerticalRan2 = this._getVerticalRangeToRender(),\n              _overscanRowStartIndex = _this$_getVerticalRan2[0],\n              _overscanRowStopIndex = _this$_getVerticalRan2[1],\n              _visibleRowStartIndex = _this$_getVerticalRan2[2],\n              _visibleRowStopIndex = _this$_getVerticalRan2[3];\n\n          this._callOnItemsRendered(_overscanColumnStartIndex, _overscanColumnStopIndex, _overscanRowStartIndex, _overscanRowStopIndex, _visibleColumnStartIndex, _visibleColumnStopIndex, _visibleRowStartIndex, _visibleRowStopIndex);\n        }\n      }\n\n      if (typeof onScroll === 'function') {\n        var _this$state3 = this.state,\n            _horizontalScrollDirection = _this$state3.horizontalScrollDirection,\n            _scrollLeft = _this$state3.scrollLeft,\n            _scrollTop = _this$state3.scrollTop,\n            _scrollUpdateWasRequested = _this$state3.scrollUpdateWasRequested,\n            _verticalScrollDirection = _this$state3.verticalScrollDirection;\n\n        this._callOnScroll(_scrollLeft, _scrollTop, _horizontalScrollDirection, _verticalScrollDirection, _scrollUpdateWasRequested);\n      }\n    } // Lazily create and cache item styles while scrolling,\n    // So that pure component sCU will prevent re-renders.\n    // We maintain this cache, and pass a style prop rather than index,\n    // So that List can clear cached styles and force item re-render if necessary.\n    ;\n\n    _proto._getHorizontalRangeToRender = function _getHorizontalRangeToRender() {\n      var _this$props6 = this.props,\n          columnCount = _this$props6.columnCount,\n          overscanColumnsCount = _this$props6.overscanColumnsCount,\n          overscanCount = _this$props6.overscanCount,\n          rowCount = _this$props6.rowCount;\n      var _this$state4 = this.state,\n          horizontalScrollDirection = _this$state4.horizontalScrollDirection,\n          isScrolling = _this$state4.isScrolling,\n          scrollLeft = _this$state4.scrollLeft;\n      var overscanCountResolved = overscanColumnsCount || overscanCount || 1;\n\n      if (columnCount === 0 || rowCount === 0) {\n        return [0, 0, 0, 0];\n      }\n\n      var startIndex = getColumnStartIndexForOffset(this.props, scrollLeft, this._instanceProps);\n      var stopIndex = getColumnStopIndexForStartIndex(this.props, startIndex, scrollLeft, this._instanceProps); // Overscan by one item in each direction so that tab/focus works.\n      // If there isn't at least one extra item, tab loops back around.\n\n      var overscanBackward = !isScrolling || horizontalScrollDirection === 'backward' ? Math.max(1, overscanCountResolved) : 1;\n      var overscanForward = !isScrolling || horizontalScrollDirection === 'forward' ? Math.max(1, overscanCountResolved) : 1;\n      return [Math.max(0, startIndex - overscanBackward), Math.max(0, Math.min(columnCount - 1, stopIndex + overscanForward)), startIndex, stopIndex];\n    };\n\n    _proto._getVerticalRangeToRender = function _getVerticalRangeToRender() {\n      var _this$props7 = this.props,\n          columnCount = _this$props7.columnCount,\n          overscanCount = _this$props7.overscanCount,\n          overscanRowsCount = _this$props7.overscanRowsCount,\n          rowCount = _this$props7.rowCount;\n      var _this$state5 = this.state,\n          isScrolling = _this$state5.isScrolling,\n          verticalScrollDirection = _this$state5.verticalScrollDirection,\n          scrollTop = _this$state5.scrollTop;\n      var overscanCountResolved = overscanRowsCount || overscanCount || 1;\n\n      if (columnCount === 0 || rowCount === 0) {\n        return [0, 0, 0, 0];\n      }\n\n      var startIndex = getRowStartIndexForOffset(this.props, scrollTop, this._instanceProps);\n      var stopIndex = getRowStopIndexForStartIndex(this.props, startIndex, scrollTop, this._instanceProps); // Overscan by one item in each direction so that tab/focus works.\n      // If there isn't at least one extra item, tab loops back around.\n\n      var overscanBackward = !isScrolling || verticalScrollDirection === 'backward' ? Math.max(1, overscanCountResolved) : 1;\n      var overscanForward = !isScrolling || verticalScrollDirection === 'forward' ? Math.max(1, overscanCountResolved) : 1;\n      return [Math.max(0, startIndex - overscanBackward), Math.max(0, Math.min(rowCount - 1, stopIndex + overscanForward)), startIndex, stopIndex];\n    };\n\n    return Grid;\n  }(PureComponent), _class.defaultProps = {\n    direction: 'ltr',\n    itemData: undefined,\n    useIsScrolling: false\n  }, _temp;\n}\n\nvar validateSharedProps$1 = function validateSharedProps(_ref5, _ref6) {\n  var children = _ref5.children,\n      direction = _ref5.direction,\n      height = _ref5.height,\n      innerTagName = _ref5.innerTagName,\n      outerTagName = _ref5.outerTagName,\n      overscanCount = _ref5.overscanCount,\n      width = _ref5.width;\n  var instance = _ref6.instance;\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (typeof overscanCount === 'number') {\n      if (devWarningsOverscanCount && !devWarningsOverscanCount.has(instance)) {\n        devWarningsOverscanCount.add(instance);\n        console.warn('The overscanCount prop has been deprecated. ' + 'Please use the overscanColumnsCount and overscanRowsCount props instead.');\n      }\n    }\n\n    if (innerTagName != null || outerTagName != null) {\n      if (devWarningsTagName$1 && !devWarningsTagName$1.has(instance)) {\n        devWarningsTagName$1.add(instance);\n        console.warn('The innerTagName and outerTagName props have been deprecated. ' + 'Please use the innerElementType and outerElementType props instead.');\n      }\n    }\n\n    if (children == null) {\n      throw Error('An invalid \"children\" prop has been specified. ' + 'Value should be a React component. ' + (\"\\\"\" + (children === null ? 'null' : typeof children) + \"\\\" was specified.\"));\n    }\n\n    switch (direction) {\n      case 'ltr':\n      case 'rtl':\n        // Valid values\n        break;\n\n      default:\n        throw Error('An invalid \"direction\" prop has been specified. ' + 'Value should be either \"ltr\" or \"rtl\". ' + (\"\\\"\" + direction + \"\\\" was specified.\"));\n    }\n\n    if (typeof width !== 'number') {\n      throw Error('An invalid \"width\" prop has been specified. ' + 'Grids must specify a number for width. ' + (\"\\\"\" + (width === null ? 'null' : typeof width) + \"\\\" was specified.\"));\n    }\n\n    if (typeof height !== 'number') {\n      throw Error('An invalid \"height\" prop has been specified. ' + 'Grids must specify a number for height. ' + (\"\\\"\" + (height === null ? 'null' : typeof height) + \"\\\" was specified.\"));\n    }\n  }\n};\n\nvar FixedSizeGrid = /*#__PURE__*/createGridComponent({\n  getColumnOffset: function getColumnOffset(_ref, index) {\n    var columnWidth = _ref.columnWidth;\n    return index * columnWidth;\n  },\n  getColumnWidth: function getColumnWidth(_ref2, index) {\n    var columnWidth = _ref2.columnWidth;\n    return columnWidth;\n  },\n  getRowOffset: function getRowOffset(_ref3, index) {\n    var rowHeight = _ref3.rowHeight;\n    return index * rowHeight;\n  },\n  getRowHeight: function getRowHeight(_ref4, index) {\n    var rowHeight = _ref4.rowHeight;\n    return rowHeight;\n  },\n  getEstimatedTotalHeight: function getEstimatedTotalHeight(_ref5) {\n    var rowCount = _ref5.rowCount,\n        rowHeight = _ref5.rowHeight;\n    return rowHeight * rowCount;\n  },\n  getEstimatedTotalWidth: function getEstimatedTotalWidth(_ref6) {\n    var columnCount = _ref6.columnCount,\n        columnWidth = _ref6.columnWidth;\n    return columnWidth * columnCount;\n  },\n  getOffsetForColumnAndAlignment: function getOffsetForColumnAndAlignment(_ref7, columnIndex, align, scrollLeft, instanceProps, scrollbarSize) {\n    var columnCount = _ref7.columnCount,\n        columnWidth = _ref7.columnWidth,\n        width = _ref7.width;\n    var maxOffset = Math.max(0, Math.min(columnCount * columnWidth - width, columnIndex * columnWidth));\n    var minOffset = Math.max(0, columnIndex * columnWidth - width + scrollbarSize + columnWidth);\n\n    switch (align) {\n      case 'start':\n        return maxOffset;\n\n      case 'end':\n        return minOffset;\n\n      case 'center':\n        return Math.round(minOffset + (maxOffset - minOffset) / 2);\n\n      case 'auto':\n      default:\n        if (scrollLeft >= minOffset && scrollLeft <= maxOffset) {\n          return scrollLeft;\n        } else if (scrollLeft - minOffset < maxOffset - scrollLeft) {\n          return minOffset;\n        } else {\n          return maxOffset;\n        }\n\n    }\n  },\n  getOffsetForRowAndAlignment: function getOffsetForRowAndAlignment(_ref8, rowIndex, align, scrollTop, instanceProps, scrollbarSize) {\n    var rowHeight = _ref8.rowHeight,\n        height = _ref8.height,\n        rowCount = _ref8.rowCount;\n    var maxOffset = Math.max(0, Math.min(rowCount * rowHeight - height, rowIndex * rowHeight));\n    var minOffset = Math.max(0, rowIndex * rowHeight - height + scrollbarSize + rowHeight);\n\n    switch (align) {\n      case 'start':\n        return maxOffset;\n\n      case 'end':\n        return minOffset;\n\n      case 'center':\n        return Math.round(minOffset + (maxOffset - minOffset) / 2);\n\n      case 'auto':\n      default:\n        if (scrollTop >= minOffset && scrollTop <= maxOffset) {\n          return scrollTop;\n        } else if (scrollTop - minOffset < maxOffset - scrollTop) {\n          return minOffset;\n        } else {\n          return maxOffset;\n        }\n\n    }\n  },\n  getColumnStartIndexForOffset: function getColumnStartIndexForOffset(_ref9, scrollLeft) {\n    var columnWidth = _ref9.columnWidth,\n        columnCount = _ref9.columnCount;\n    return Math.max(0, Math.min(columnCount - 1, Math.floor(scrollLeft / columnWidth)));\n  },\n  getColumnStopIndexForStartIndex: function getColumnStopIndexForStartIndex(_ref10, startIndex, scrollLeft) {\n    var columnWidth = _ref10.columnWidth,\n        columnCount = _ref10.columnCount,\n        width = _ref10.width;\n    var left = startIndex * columnWidth;\n    return Math.max(0, Math.min(columnCount - 1, startIndex + Math.floor((width + (scrollLeft - left)) / columnWidth)));\n  },\n  getRowStartIndexForOffset: function getRowStartIndexForOffset(_ref11, scrollTop) {\n    var rowHeight = _ref11.rowHeight,\n        rowCount = _ref11.rowCount;\n    return Math.max(0, Math.min(rowCount - 1, Math.floor(scrollTop / rowHeight)));\n  },\n  getRowStopIndexForStartIndex: function getRowStopIndexForStartIndex(_ref12, startIndex, scrollTop) {\n    var rowHeight = _ref12.rowHeight,\n        rowCount = _ref12.rowCount,\n        height = _ref12.height;\n    var left = startIndex * rowHeight;\n    return Math.max(0, Math.min(rowCount - 1, startIndex + Math.floor((height + (scrollTop - left)) / rowHeight)));\n  },\n  initInstanceProps: function initInstanceProps(props) {// Noop\n  },\n  shouldResetStyleCacheOnItemSizeChange: true,\n  validateProps: function validateProps(_ref13) {\n    var columnWidth = _ref13.columnWidth,\n        rowHeight = _ref13.rowHeight;\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (typeof columnWidth !== 'number') {\n        throw Error('An invalid \"columnWidth\" prop has been specified. ' + 'Value should be a number. ' + (\"\\\"\" + (columnWidth === null ? 'null' : typeof columnWidth) + \"\\\" was specified.\"));\n      }\n\n      if (typeof rowHeight !== 'number') {\n        throw Error('An invalid \"rowHeight\" prop has been specified. ' + 'Value should be a number. ' + (\"\\\"\" + (rowHeight === null ? 'null' : typeof rowHeight) + \"\\\" was specified.\"));\n      }\n    }\n  }\n});\nvar FixedSizeList = /*#__PURE__*/createListComponent({\n  getItemOffset: function getItemOffset(_ref, index) {\n    var itemSize = _ref.itemSize,\n        size = _ref.size;\n    return index * itemSize;\n  },\n  getItemSize: function getItemSize(_ref2, index) {\n    var itemSize = _ref2.itemSize,\n        size = _ref2.size;\n    return itemSize;\n  },\n  getEstimatedTotalSize: function getEstimatedTotalSize(_ref3) {\n    var itemCount = _ref3.itemCount,\n        itemSize = _ref3.itemSize;\n    return itemSize * itemCount;\n  },\n  getOffsetForIndexAndAlignment: function getOffsetForIndexAndAlignment(_ref4, index, align, scrollOffset) {\n    var direction = _ref4.direction,\n        height = _ref4.height,\n        itemCount = _ref4.itemCount,\n        itemSize = _ref4.itemSize,\n        layout = _ref4.layout,\n        width = _ref4.width; // TODO Deprecate direction \"horizontal\"\n\n    var isHorizontal = direction === 'horizontal' || layout === 'horizontal';\n    var size = isHorizontal ? width : height;\n    var maxOffset = Math.max(0, Math.min(itemCount * itemSize - size, index * itemSize));\n    var minOffset = Math.max(0, index * itemSize - size + itemSize);\n\n    switch (align) {\n      case 'start':\n        return maxOffset;\n\n      case 'end':\n        return minOffset;\n\n      case 'center':\n        return Math.round(minOffset + (maxOffset - minOffset) / 2);\n\n      case 'auto':\n      default:\n        if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {\n          return scrollOffset;\n        } else if (scrollOffset - minOffset < maxOffset - scrollOffset) {\n          return minOffset;\n        } else {\n          return maxOffset;\n        }\n\n    }\n  },\n  getStartIndexForOffset: function getStartIndexForOffset(_ref5, offset) {\n    var itemCount = _ref5.itemCount,\n        itemSize = _ref5.itemSize;\n    return Math.max(0, Math.min(itemCount - 1, Math.floor(offset / itemSize)));\n  },\n  getStopIndexForStartIndex: function getStopIndexForStartIndex(_ref6, startIndex, scrollOffset) {\n    var direction = _ref6.direction,\n        height = _ref6.height,\n        itemCount = _ref6.itemCount,\n        itemSize = _ref6.itemSize,\n        layout = _ref6.layout,\n        width = _ref6.width; // TODO Deprecate direction \"horizontal\"\n\n    var isHorizontal = direction === 'horizontal' || layout === 'horizontal';\n    var offset = startIndex * itemSize;\n    var size = isHorizontal ? width : height;\n    return Math.max(0, Math.min(itemCount - 1, startIndex + Math.floor((size + (scrollOffset - offset)) / itemSize)));\n  },\n  initInstanceProps: function initInstanceProps(props) {// Noop\n  },\n  shouldResetStyleCacheOnItemSizeChange: true,\n  validateProps: function validateProps(_ref7) {\n    var itemSize = _ref7.itemSize;\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (typeof itemSize !== 'number') {\n        throw Error('An invalid \"itemSize\" prop has been specified. ' + 'Value should be a number. ' + (\"\\\"\" + (itemSize === null ? 'null' : typeof itemSize) + \"\\\" was specified.\"));\n      }\n    }\n  }\n});\nvar DEFAULT_ESTIMATED_ITEM_SIZE$1 = 50;\n\nvar getEstimatedTotalHeight = function getEstimatedTotalHeight(_ref, _ref2) {\n  var rowCount = _ref.rowCount;\n  var rowMetadataMap = _ref2.rowMetadataMap,\n      estimatedRowHeight = _ref2.estimatedRowHeight,\n      lastMeasuredRowIndex = _ref2.lastMeasuredRowIndex;\n  var totalSizeOfMeasuredRows = 0; // Edge case check for when the number of items decreases while a scroll is in progress.\n  // https://github.com/bvaughn/react-window/pull/138\n\n  if (lastMeasuredRowIndex >= rowCount) {\n    lastMeasuredRowIndex = rowCount - 1;\n  }\n\n  if (lastMeasuredRowIndex >= 0) {\n    var itemMetadata = rowMetadataMap[lastMeasuredRowIndex];\n    totalSizeOfMeasuredRows = itemMetadata.offset + itemMetadata.size;\n  }\n\n  var numUnmeasuredItems = rowCount - lastMeasuredRowIndex - 1;\n  var totalSizeOfUnmeasuredItems = numUnmeasuredItems * estimatedRowHeight;\n  return totalSizeOfMeasuredRows + totalSizeOfUnmeasuredItems;\n};\n\nvar getEstimatedTotalWidth = function getEstimatedTotalWidth(_ref3, _ref4) {\n  var columnCount = _ref3.columnCount;\n  var columnMetadataMap = _ref4.columnMetadataMap,\n      estimatedColumnWidth = _ref4.estimatedColumnWidth,\n      lastMeasuredColumnIndex = _ref4.lastMeasuredColumnIndex;\n  var totalSizeOfMeasuredRows = 0; // Edge case check for when the number of items decreases while a scroll is in progress.\n  // https://github.com/bvaughn/react-window/pull/138\n\n  if (lastMeasuredColumnIndex >= columnCount) {\n    lastMeasuredColumnIndex = columnCount - 1;\n  }\n\n  if (lastMeasuredColumnIndex >= 0) {\n    var itemMetadata = columnMetadataMap[lastMeasuredColumnIndex];\n    totalSizeOfMeasuredRows = itemMetadata.offset + itemMetadata.size;\n  }\n\n  var numUnmeasuredItems = columnCount - lastMeasuredColumnIndex - 1;\n  var totalSizeOfUnmeasuredItems = numUnmeasuredItems * estimatedColumnWidth;\n  return totalSizeOfMeasuredRows + totalSizeOfUnmeasuredItems;\n};\n\nvar getItemMetadata$1 = function getItemMetadata(itemType, props, index, instanceProps) {\n  var itemMetadataMap, itemSize, lastMeasuredIndex;\n\n  if (itemType === 'column') {\n    itemMetadataMap = instanceProps.columnMetadataMap;\n    itemSize = props.columnWidth;\n    lastMeasuredIndex = instanceProps.lastMeasuredColumnIndex;\n  } else {\n    itemMetadataMap = instanceProps.rowMetadataMap;\n    itemSize = props.rowHeight;\n    lastMeasuredIndex = instanceProps.lastMeasuredRowIndex;\n  }\n\n  if (index > lastMeasuredIndex) {\n    var offset = 0;\n\n    if (lastMeasuredIndex >= 0) {\n      var itemMetadata = itemMetadataMap[lastMeasuredIndex];\n      offset = itemMetadata.offset + itemMetadata.size;\n    }\n\n    for (var i = lastMeasuredIndex + 1; i <= index; i++) {\n      var size = itemSize(i);\n      itemMetadataMap[i] = {\n        offset: offset,\n        size: size\n      };\n      offset += size;\n    }\n\n    if (itemType === 'column') {\n      instanceProps.lastMeasuredColumnIndex = index;\n    } else {\n      instanceProps.lastMeasuredRowIndex = index;\n    }\n  }\n\n  return itemMetadataMap[index];\n};\n\nvar findNearestItem = function findNearestItem(itemType, props, instanceProps, offset) {\n  var itemMetadataMap, lastMeasuredIndex;\n\n  if (itemType === 'column') {\n    itemMetadataMap = instanceProps.columnMetadataMap;\n    lastMeasuredIndex = instanceProps.lastMeasuredColumnIndex;\n  } else {\n    itemMetadataMap = instanceProps.rowMetadataMap;\n    lastMeasuredIndex = instanceProps.lastMeasuredRowIndex;\n  }\n\n  var lastMeasuredItemOffset = lastMeasuredIndex > 0 ? itemMetadataMap[lastMeasuredIndex].offset : 0;\n\n  if (lastMeasuredItemOffset >= offset) {\n    // If we've already measured items within this range just use a binary search as it's faster.\n    return findNearestItemBinarySearch$1(itemType, props, instanceProps, lastMeasuredIndex, 0, offset);\n  } else {\n    // If we haven't yet measured this high, fallback to an exponential search with an inner binary search.\n    // The exponential search avoids pre-computing sizes for the full set of items as a binary search would.\n    // The overall complexity for this approach is O(log n).\n    return findNearestItemExponentialSearch(itemType, props, instanceProps, Math.max(0, lastMeasuredIndex), offset);\n  }\n};\n\nvar findNearestItemBinarySearch$1 = function findNearestItemBinarySearch(itemType, props, instanceProps, high, low, offset) {\n  while (low <= high) {\n    var middle = low + Math.floor((high - low) / 2);\n    var currentOffset = getItemMetadata$1(itemType, props, middle, instanceProps).offset;\n\n    if (currentOffset === offset) {\n      return middle;\n    } else if (currentOffset < offset) {\n      low = middle + 1;\n    } else if (currentOffset > offset) {\n      high = middle - 1;\n    }\n  }\n\n  if (low > 0) {\n    return low - 1;\n  } else {\n    return 0;\n  }\n};\n\nvar findNearestItemExponentialSearch = function findNearestItemExponentialSearch(itemType, props, instanceProps, index, offset) {\n  var itemCount = itemType === 'column' ? props.columnCount : props.rowCount;\n  var interval = 1;\n\n  while (index < itemCount && getItemMetadata$1(itemType, props, index, instanceProps).offset < offset) {\n    index += interval;\n    interval *= 2;\n  }\n\n  return findNearestItemBinarySearch$1(itemType, props, instanceProps, Math.min(index, itemCount - 1), Math.floor(index / 2), offset);\n};\n\nvar getOffsetForIndexAndAlignment = function getOffsetForIndexAndAlignment(itemType, props, index, align, scrollOffset, instanceProps, scrollbarSize) {\n  var size = itemType === 'column' ? props.width : props.height;\n  var itemMetadata = getItemMetadata$1(itemType, props, index, instanceProps); // Get estimated total size after ItemMetadata is computed,\n  // To ensure it reflects actual measurements instead of just estimates.\n\n  var estimatedTotalSize = itemType === 'column' ? getEstimatedTotalWidth(props, instanceProps) : getEstimatedTotalHeight(props, instanceProps);\n  var maxOffset = Math.max(0, Math.min(estimatedTotalSize - size, itemMetadata.offset));\n  var minOffset = Math.max(0, itemMetadata.offset - size + scrollbarSize + itemMetadata.size);\n\n  switch (align) {\n    case 'start':\n      return maxOffset;\n\n    case 'end':\n      return minOffset;\n\n    case 'center':\n      return Math.round(minOffset + (maxOffset - minOffset) / 2);\n\n    case 'auto':\n    default:\n      if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {\n        return scrollOffset;\n      } else if (scrollOffset - minOffset < maxOffset - scrollOffset) {\n        return minOffset;\n      } else {\n        return maxOffset;\n      }\n\n  }\n};\n\nvar VariableSizeGrid = /*#__PURE__*/createGridComponent({\n  getColumnOffset: function getColumnOffset(props, index, instanceProps) {\n    return getItemMetadata$1('column', props, index, instanceProps).offset;\n  },\n  getColumnStartIndexForOffset: function getColumnStartIndexForOffset(props, scrollLeft, instanceProps) {\n    return findNearestItem('column', props, instanceProps, scrollLeft);\n  },\n  getColumnStopIndexForStartIndex: function getColumnStopIndexForStartIndex(props, startIndex, scrollLeft, instanceProps) {\n    var columnCount = props.columnCount,\n        width = props.width;\n    var itemMetadata = getItemMetadata$1('column', props, startIndex, instanceProps);\n    var maxOffset = scrollLeft + width;\n    var offset = itemMetadata.offset + itemMetadata.size;\n    var stopIndex = startIndex;\n\n    while (stopIndex < columnCount - 1 && offset < maxOffset) {\n      stopIndex++;\n      offset += getItemMetadata$1('column', props, stopIndex, instanceProps).size;\n    }\n\n    return stopIndex;\n  },\n  getColumnWidth: function getColumnWidth(props, index, instanceProps) {\n    return instanceProps.columnMetadataMap[index].size;\n  },\n  getEstimatedTotalHeight: getEstimatedTotalHeight,\n  getEstimatedTotalWidth: getEstimatedTotalWidth,\n  getOffsetForColumnAndAlignment: function getOffsetForColumnAndAlignment(props, index, align, scrollOffset, instanceProps, scrollbarSize) {\n    return getOffsetForIndexAndAlignment('column', props, index, align, scrollOffset, instanceProps, scrollbarSize);\n  },\n  getOffsetForRowAndAlignment: function getOffsetForRowAndAlignment(props, index, align, scrollOffset, instanceProps, scrollbarSize) {\n    return getOffsetForIndexAndAlignment('row', props, index, align, scrollOffset, instanceProps, scrollbarSize);\n  },\n  getRowOffset: function getRowOffset(props, index, instanceProps) {\n    return getItemMetadata$1('row', props, index, instanceProps).offset;\n  },\n  getRowHeight: function getRowHeight(props, index, instanceProps) {\n    return instanceProps.rowMetadataMap[index].size;\n  },\n  getRowStartIndexForOffset: function getRowStartIndexForOffset(props, scrollTop, instanceProps) {\n    return findNearestItem('row', props, instanceProps, scrollTop);\n  },\n  getRowStopIndexForStartIndex: function getRowStopIndexForStartIndex(props, startIndex, scrollTop, instanceProps) {\n    var rowCount = props.rowCount,\n        height = props.height;\n    var itemMetadata = getItemMetadata$1('row', props, startIndex, instanceProps);\n    var maxOffset = scrollTop + height;\n    var offset = itemMetadata.offset + itemMetadata.size;\n    var stopIndex = startIndex;\n\n    while (stopIndex < rowCount - 1 && offset < maxOffset) {\n      stopIndex++;\n      offset += getItemMetadata$1('row', props, stopIndex, instanceProps).size;\n    }\n\n    return stopIndex;\n  },\n  initInstanceProps: function initInstanceProps(props, instance) {\n    var _ref5 = props,\n        estimatedColumnWidth = _ref5.estimatedColumnWidth,\n        estimatedRowHeight = _ref5.estimatedRowHeight;\n    var instanceProps = {\n      columnMetadataMap: {},\n      estimatedColumnWidth: estimatedColumnWidth || DEFAULT_ESTIMATED_ITEM_SIZE$1,\n      estimatedRowHeight: estimatedRowHeight || DEFAULT_ESTIMATED_ITEM_SIZE$1,\n      lastMeasuredColumnIndex: -1,\n      lastMeasuredRowIndex: -1,\n      rowMetadataMap: {}\n    };\n\n    instance.resetAfterColumnIndex = function (columnIndex, shouldForceUpdate) {\n      if (shouldForceUpdate === void 0) {\n        shouldForceUpdate = true;\n      }\n\n      instance.resetAfterIndices({\n        columnIndex: columnIndex,\n        shouldForceUpdate: shouldForceUpdate\n      });\n    };\n\n    instance.resetAfterRowIndex = function (rowIndex, shouldForceUpdate) {\n      if (shouldForceUpdate === void 0) {\n        shouldForceUpdate = true;\n      }\n\n      instance.resetAfterIndices({\n        rowIndex: rowIndex,\n        shouldForceUpdate: shouldForceUpdate\n      });\n    };\n\n    instance.resetAfterIndices = function (_ref6) {\n      var columnIndex = _ref6.columnIndex,\n          rowIndex = _ref6.rowIndex,\n          _ref6$shouldForceUpda = _ref6.shouldForceUpdate,\n          shouldForceUpdate = _ref6$shouldForceUpda === void 0 ? true : _ref6$shouldForceUpda;\n\n      if (typeof columnIndex === 'number') {\n        instanceProps.lastMeasuredColumnIndex = Math.min(instanceProps.lastMeasuredColumnIndex, columnIndex - 1);\n      }\n\n      if (typeof rowIndex === 'number') {\n        instanceProps.lastMeasuredRowIndex = Math.min(instanceProps.lastMeasuredRowIndex, rowIndex - 1);\n      } // We could potentially optimize further by only evicting styles after this index,\n      // But since styles are only cached while scrolling is in progress-\n      // It seems an unnecessary optimization.\n      // It's unlikely that resetAfterIndex() will be called while a user is scrolling.\n\n\n      instance._getItemStyleCache(-1);\n\n      if (shouldForceUpdate) {\n        instance.forceUpdate();\n      }\n    };\n\n    return instanceProps;\n  },\n  shouldResetStyleCacheOnItemSizeChange: false,\n  validateProps: function validateProps(_ref7) {\n    var columnWidth = _ref7.columnWidth,\n        rowHeight = _ref7.rowHeight;\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (typeof columnWidth !== 'function') {\n        throw Error('An invalid \"columnWidth\" prop has been specified. ' + 'Value should be a function. ' + (\"\\\"\" + (columnWidth === null ? 'null' : typeof columnWidth) + \"\\\" was specified.\"));\n      } else if (typeof rowHeight !== 'function') {\n        throw Error('An invalid \"rowHeight\" prop has been specified. ' + 'Value should be a function. ' + (\"\\\"\" + (rowHeight === null ? 'null' : typeof rowHeight) + \"\\\" was specified.\"));\n      }\n    }\n  }\n});\nvar DEFAULT_ESTIMATED_ITEM_SIZE$2 = 50;\n\nvar getItemMetadata$2 = function getItemMetadata(props, index, instanceProps) {\n  var _ref = props,\n      itemSize = _ref.itemSize;\n  var itemMetadataMap = instanceProps.itemMetadataMap,\n      lastMeasuredIndex = instanceProps.lastMeasuredIndex;\n\n  if (index > lastMeasuredIndex) {\n    var offset = 0;\n\n    if (lastMeasuredIndex >= 0) {\n      var itemMetadata = itemMetadataMap[lastMeasuredIndex];\n      offset = itemMetadata.offset + itemMetadata.size;\n    }\n\n    for (var i = lastMeasuredIndex + 1; i <= index; i++) {\n      var size = itemSize(i);\n      itemMetadataMap[i] = {\n        offset: offset,\n        size: size\n      };\n      offset += size;\n    }\n\n    instanceProps.lastMeasuredIndex = index;\n  }\n\n  return itemMetadataMap[index];\n};\n\nvar findNearestItem$1 = function findNearestItem(props, instanceProps, offset) {\n  var itemMetadataMap = instanceProps.itemMetadataMap,\n      lastMeasuredIndex = instanceProps.lastMeasuredIndex;\n  var lastMeasuredItemOffset = lastMeasuredIndex > 0 ? itemMetadataMap[lastMeasuredIndex].offset : 0;\n\n  if (lastMeasuredItemOffset >= offset) {\n    // If we've already measured items within this range just use a binary search as it's faster.\n    return findNearestItemBinarySearch$2(props, instanceProps, lastMeasuredIndex, 0, offset);\n  } else {\n    // If we haven't yet measured this high, fallback to an exponential search with an inner binary search.\n    // The exponential search avoids pre-computing sizes for the full set of items as a binary search would.\n    // The overall complexity for this approach is O(log n).\n    return findNearestItemExponentialSearch$1(props, instanceProps, Math.max(0, lastMeasuredIndex), offset);\n  }\n};\n\nvar findNearestItemBinarySearch$2 = function findNearestItemBinarySearch(props, instanceProps, high, low, offset) {\n  while (low <= high) {\n    var middle = low + Math.floor((high - low) / 2);\n    var currentOffset = getItemMetadata$2(props, middle, instanceProps).offset;\n\n    if (currentOffset === offset) {\n      return middle;\n    } else if (currentOffset < offset) {\n      low = middle + 1;\n    } else if (currentOffset > offset) {\n      high = middle - 1;\n    }\n  }\n\n  if (low > 0) {\n    return low - 1;\n  } else {\n    return 0;\n  }\n};\n\nvar findNearestItemExponentialSearch$1 = function findNearestItemExponentialSearch(props, instanceProps, index, offset) {\n  var itemCount = props.itemCount;\n  var interval = 1;\n\n  while (index < itemCount && getItemMetadata$2(props, index, instanceProps).offset < offset) {\n    index += interval;\n    interval *= 2;\n  }\n\n  return findNearestItemBinarySearch$2(props, instanceProps, Math.min(index, itemCount - 1), Math.floor(index / 2), offset);\n};\n\nvar getEstimatedTotalSize$1 = function getEstimatedTotalSize(_ref2, _ref3) {\n  var itemCount = _ref2.itemCount;\n  var itemMetadataMap = _ref3.itemMetadataMap,\n      estimatedItemSize = _ref3.estimatedItemSize,\n      lastMeasuredIndex = _ref3.lastMeasuredIndex;\n  var totalSizeOfMeasuredItems = 0; // Edge case check for when the number of items decreases while a scroll is in progress.\n  // https://github.com/bvaughn/react-window/pull/138\n\n  if (lastMeasuredIndex >= itemCount) {\n    lastMeasuredIndex = itemCount - 1;\n  }\n\n  if (lastMeasuredIndex >= 0) {\n    var itemMetadata = itemMetadataMap[lastMeasuredIndex];\n    totalSizeOfMeasuredItems = itemMetadata.offset + itemMetadata.size;\n  }\n\n  var numUnmeasuredItems = itemCount - lastMeasuredIndex - 1;\n  var totalSizeOfUnmeasuredItems = numUnmeasuredItems * estimatedItemSize;\n  return totalSizeOfMeasuredItems + totalSizeOfUnmeasuredItems;\n};\n\nvar VariableSizeList = /*#__PURE__*/createListComponent({\n  getItemOffset: function getItemOffset(props, index, instanceProps) {\n    return getItemMetadata$2(props, index, instanceProps).offset;\n  },\n  getItemSize: function getItemSize(props, index, instanceProps) {\n    return instanceProps.itemMetadataMap[index].size;\n  },\n  getEstimatedTotalSize: getEstimatedTotalSize$1,\n  getOffsetForIndexAndAlignment: function getOffsetForIndexAndAlignment(props, index, align, scrollOffset, instanceProps) {\n    var direction = props.direction,\n        height = props.height,\n        layout = props.layout,\n        width = props.width; // TODO Deprecate direction \"horizontal\"\n\n    var isHorizontal = direction === 'horizontal' || layout === 'horizontal';\n    var size = isHorizontal ? width : height;\n    var itemMetadata = getItemMetadata$2(props, index, instanceProps); // Get estimated total size after ItemMetadata is computed,\n    // To ensure it reflects actual measurements instead of just estimates.\n\n    var estimatedTotalSize = getEstimatedTotalSize$1(props, instanceProps);\n    var maxOffset = Math.max(0, Math.min(estimatedTotalSize - size, itemMetadata.offset));\n    var minOffset = Math.max(0, itemMetadata.offset - size + itemMetadata.size);\n\n    switch (align) {\n      case 'start':\n        return maxOffset;\n\n      case 'end':\n        return minOffset;\n\n      case 'center':\n        return Math.round(minOffset + (maxOffset - minOffset) / 2);\n\n      case 'auto':\n      default:\n        if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {\n          return scrollOffset;\n        } else if (scrollOffset - minOffset < maxOffset - scrollOffset) {\n          return minOffset;\n        } else {\n          return maxOffset;\n        }\n\n    }\n  },\n  getStartIndexForOffset: function getStartIndexForOffset(props, offset, instanceProps) {\n    return findNearestItem$1(props, instanceProps, offset);\n  },\n  getStopIndexForStartIndex: function getStopIndexForStartIndex(props, startIndex, scrollOffset, instanceProps) {\n    var direction = props.direction,\n        height = props.height,\n        itemCount = props.itemCount,\n        layout = props.layout,\n        width = props.width; // TODO Deprecate direction \"horizontal\"\n\n    var isHorizontal = direction === 'horizontal' || layout === 'horizontal';\n    var size = isHorizontal ? width : height;\n    var itemMetadata = getItemMetadata$2(props, startIndex, instanceProps);\n    var maxOffset = scrollOffset + size;\n    var offset = itemMetadata.offset + itemMetadata.size;\n    var stopIndex = startIndex;\n\n    while (stopIndex < itemCount - 1 && offset < maxOffset) {\n      stopIndex++;\n      offset += getItemMetadata$2(props, stopIndex, instanceProps).size;\n    }\n\n    return stopIndex;\n  },\n  initInstanceProps: function initInstanceProps(props, instance) {\n    var _ref4 = props,\n        estimatedItemSize = _ref4.estimatedItemSize;\n    var instanceProps = {\n      itemMetadataMap: {},\n      estimatedItemSize: estimatedItemSize || DEFAULT_ESTIMATED_ITEM_SIZE$2,\n      lastMeasuredIndex: -1\n    };\n\n    instance.resetAfterIndex = function (index, shouldForceUpdate) {\n      if (shouldForceUpdate === void 0) {\n        shouldForceUpdate = true;\n      }\n\n      instanceProps.lastMeasuredIndex = Math.min(instanceProps.lastMeasuredIndex, index - 1); // We could potentially optimize further by only evicting styles after this index,\n      // But since styles are only cached while scrolling is in progress-\n      // It seems an unnecessary optimization.\n      // It's unlikely that resetAfterIndex() will be called while a user is scrolling.\n\n      instance._getItemStyleCache(-1);\n\n      if (shouldForceUpdate) {\n        instance.forceUpdate();\n      }\n    };\n\n    return instanceProps;\n  },\n  shouldResetStyleCacheOnItemSizeChange: false,\n  validateProps: function validateProps(_ref5) {\n    var itemSize = _ref5.itemSize;\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (typeof itemSize !== 'function') {\n        throw Error('An invalid \"itemSize\" prop has been specified. ' + 'Value should be a function. ' + (\"\\\"\" + (itemSize === null ? 'null' : typeof itemSize) + \"\\\" was specified.\"));\n      }\n    }\n  }\n}); // Pulled from react-compat\n// https://github.com/developit/preact-compat/blob/7c5de00e7c85e2ffd011bf3af02899b63f699d3a/src/index.js#L349\n\nfunction shallowDiffers(prev, next) {\n  for (var attribute in prev) {\n    if (!(attribute in next)) {\n      return true;\n    }\n  }\n\n  for (var _attribute in next) {\n    if (prev[_attribute] !== next[_attribute]) {\n      return true;\n    }\n  }\n\n  return false;\n} // It knows to compare individual style props and ignore the wrapper object.\n// See https://reactjs.org/docs/react-api.html#reactmemo\n\n\nfunction areEqual(prevProps, nextProps) {\n  var prevStyle = prevProps.style,\n      prevRest = _objectWithoutPropertiesLoose(prevProps, [\"style\"]);\n\n  var nextStyle = nextProps.style,\n      nextRest = _objectWithoutPropertiesLoose(nextProps, [\"style\"]);\n\n  return !shallowDiffers(prevStyle, nextStyle) && !shallowDiffers(prevRest, nextRest);\n} // It knows to compare individual style props and ignore the wrapper object.\n// See https://reactjs.org/docs/react-component.html#shouldcomponentupdate\n\n\nfunction shouldComponentUpdate(nextProps, nextState) {\n  return !areEqual(this.props, nextProps) || shallowDiffers(this.state, nextState);\n}\n\nexport { DynamicSizeList, FixedSizeGrid, FixedSizeList, VariableSizeGrid, VariableSizeList, areEqual, shouldComponentUpdate };","map":{"version":3,"sources":["C:/myProJects/Server/weatherapp/node_modules/react-window-dynamic/dist/index.esm.js"],"names":["createElement","PureComponent","cloneElement","Component","_extends","_assertThisInitialized","_inheritsLoose","memoizeOne","findDOMNode","_objectWithoutPropertiesLoose","hasNativePerformanceNow","performance","now","Date","cancelTimeout","timeoutID","cancelAnimationFrame","id","requestTimeout","callback","delay","start","tick","call","requestAnimationFrame","IS_SCROLLING_DEBOUNCE_INTERVAL","defaultItemKey","index","data","devWarningsDirection","devWarningsTagName","process","env","NODE_ENV","window","WeakSet","createListComponent","_ref","_class","_temp","getItemOffset","getEstimatedTotalSize","getItemSize","getOffsetForIndexAndAlignment","getStartIndexForOffset","getStopIndexForStartIndex","initInstanceProps","shouldResetStyleCacheOnItemSizeChange","validateProps","_PureComponent","List","props","_this","_instanceProps","_outerRef","_resetIsScrollingTimeoutId","state","instance","isScrolling","scrollDirection","scrollOffset","initialScrollOffset","scrollUpdateWasRequested","_callOnItemsRendered","overscanStartIndex","overscanStopIndex","visibleStartIndex","visibleStopIndex","onItemsRendered","_callOnScroll","onScroll","_getItemStyle","_this$props","direction","itemSize","layout","itemStyleCache","_getItemStyleCache","style","hasOwnProperty","_style","_offset","size","isHorizontal","position","top","height","width","_itemStyleCache","_","__","___","_onScrollHorizontal","event","_event$currentTarget","currentTarget","clientWidth","scrollLeft","scrollWidth","setState","prevState","_resetIsScrollingDebounced","_onScrollVertical","scrollTop","_outerRefSetter","ref","outerRef","current","_resetIsScrolling","getDerivedStateFromProps","nextProps","validateSharedProps","_proto","prototype","scrollTo","scrollToItem","align","componentDidMount","_this$props2","_callPropsCallbacks","_commitHook","componentDidUpdate","_this$props3","_this$state","componentWillUnmount","_unmountHook","render","_this$props4","className","innerRef","innerElementType","innerTagName","outerElementType","outerTagName","items","_renderItems","estimatedTotalSize","overflow","WebkitOverflowScrolling","willChange","children","pointerEvents","itemCount","_this$_getRangeToRend","_getRangeToRender","_overscanStartIndex","_overscanStopIndex","_visibleStartIndex","_visibleStopIndex","_this$state2","_scrollDirection","_scrollOffset","_scrollUpdateWasRequested","_this$props5","overscanCount","_this$state3","startIndex","stopIndex","overscanBackward","Math","max","overscanForward","min","_this$props6","itemData","_this$props6$itemKey","itemKey","useIsScrolling","_this$_getRangeToRend2","_index","push","key","undefined","defaultProps","_ref2","_ref3","has","add","console","warn","Error","findDOMNodeWarningsSet","Set","ItemMeasurer","_Component","_len","arguments","length","args","Array","_key","apply","concat","_didProvideValidRef","_node","_resizeObserver","_measureItem","isCommitPhase","handleNewMeasurements","oldSize","node","ownerDocument","defaultView","HTMLElement","newSize","ceil","offsetWidth","offsetHeight","_refSetter","unobserve","observe","_onResize","item","displayName","type","name","ResizeObserver","disconnect","DEFAULT_ESTIMATED_ITEM_SIZE","getItemMetadata","instanceProps","estimatedItemSize","itemOffsetMap","itemSizeMap","lastMeasuredIndex","lastPositionedIndex","offset","i","prevOffset","prevSize","findNearestItemBinarySearch","high","low","middle","floor","currentOffset","totalMeasuredSize","DynamicSizeList","itemMetadata","maxOffset","minOffset","round","debounceForceUpdateID","debounceForceUpdate","setTimeout","forceUpdate","clearTimeout","hasNewMeasurements","sizeDeltaTotal","shouldForceUpdate","sizeDeltaForStateUpdate","_instance$props","element","scrollBy","isFirstMeasureAfterMounting","_handleNewMeasurements","_instance$props2","_instance$props2$item","_instance$_getRangeTo","_getItemMetadata","_ref4","getScrollbarSize","recalculate","div","document","body","appendChild","removeChild","IS_SCROLLING_DEBOUNCE_INTERVAL$1","defaultItemKey$1","columnIndex","rowIndex","devWarningsOverscanCount","devWarningsTagName$1","createGridComponent","getColumnOffset","getColumnStartIndexForOffset","getColumnStopIndexForStartIndex","getColumnWidth","getEstimatedTotalHeight","getEstimatedTotalWidth","getOffsetForColumnAndAlignment","getOffsetForRowAndAlignment","getRowHeight","getRowOffset","getRowStartIndexForOffset","getRowStopIndexForStartIndex","Grid","horizontalScrollDirection","initialScrollLeft","initialScrollTop","verticalScrollDirection","overscanColumnStartIndex","overscanColumnStopIndex","overscanRowStartIndex","overscanRowStopIndex","visibleColumnStartIndex","visibleColumnStopIndex","visibleRowStartIndex","visibleRowStopIndex","columnWidth","rowHeight","_onScroll","calculatedScrollLeft","validateSharedProps$1","_ref4$align","scrollbarSize","estimatedTotalHeight","estimatedTotalWidth","horizontalScrollbarSize","verticalScrollbarSize","columnCount","_this$props4$itemKey","rowCount","_this$_getHorizontalR","_getHorizontalRangeToRender","columnStartIndex","columnStopIndex","_this$_getVerticalRan","_getVerticalRangeToRender","rowStartIndex","rowStopIndex","_rowIndex","_columnIndex","_this$_getHorizontalR2","_overscanColumnStartIndex","_overscanColumnStopIndex","_visibleColumnStartIndex","_visibleColumnStopIndex","_this$_getVerticalRan2","_overscanRowStartIndex","_overscanRowStopIndex","_visibleRowStartIndex","_visibleRowStopIndex","_horizontalScrollDirection","_scrollLeft","_scrollTop","_verticalScrollDirection","overscanColumnsCount","_this$state4","overscanCountResolved","_this$props7","overscanRowsCount","_this$state5","_ref5","_ref6","FixedSizeGrid","_ref7","_ref8","_ref9","_ref10","left","_ref11","_ref12","_ref13","FixedSizeList","DEFAULT_ESTIMATED_ITEM_SIZE$1","rowMetadataMap","estimatedRowHeight","lastMeasuredRowIndex","totalSizeOfMeasuredRows","numUnmeasuredItems","totalSizeOfUnmeasuredItems","columnMetadataMap","estimatedColumnWidth","lastMeasuredColumnIndex","getItemMetadata$1","itemType","itemMetadataMap","findNearestItem","lastMeasuredItemOffset","findNearestItemBinarySearch$1","findNearestItemExponentialSearch","interval","VariableSizeGrid","resetAfterColumnIndex","resetAfterIndices","resetAfterRowIndex","_ref6$shouldForceUpda","DEFAULT_ESTIMATED_ITEM_SIZE$2","getItemMetadata$2","findNearestItem$1","findNearestItemBinarySearch$2","findNearestItemExponentialSearch$1","getEstimatedTotalSize$1","totalSizeOfMeasuredItems","VariableSizeList","resetAfterIndex","shallowDiffers","prev","next","attribute","_attribute","areEqual","prevProps","prevStyle","prevRest","nextStyle","nextRest","shouldComponentUpdate","nextState"],"mappings":"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","sourcesContent":["import { createElement, PureComponent, cloneElement, Component } from 'react';\nimport _extends from '@babel/runtime/helpers/esm/extends';\nimport _assertThisInitialized from '@babel/runtime/helpers/esm/assertThisInitialized';\nimport _inheritsLoose from '@babel/runtime/helpers/esm/inheritsLoose';\nimport memoizeOne from 'memoize-one';\nimport { findDOMNode } from 'react-dom';\nimport _objectWithoutPropertiesLoose from '@babel/runtime/helpers/esm/objectWithoutPropertiesLoose';\n\n// Animation frame based implementation of setTimeout.\n// Inspired by Joe Lambert, https://gist.github.com/joelambert/1002116#file-requesttimeout-js\nvar hasNativePerformanceNow = typeof performance === 'object' && typeof performance.now === 'function';\nvar now = hasNativePerformanceNow ? function () {\n  return performance.now();\n} : function () {\n  return Date.now();\n};\nfunction cancelTimeout(timeoutID) {\n  cancelAnimationFrame(timeoutID.id);\n}\nfunction requestTimeout(callback, delay) {\n  var start = now();\n\n  function tick() {\n    if (now() - start >= delay) {\n      callback.call(null);\n    } else {\n      timeoutID.id = requestAnimationFrame(tick);\n    }\n  }\n\n  var timeoutID = {\n    id: requestAnimationFrame(tick)\n  };\n  return timeoutID;\n}\n\nvar IS_SCROLLING_DEBOUNCE_INTERVAL = 150;\nvar defaultItemKey = function defaultItemKey(index, data) {\n  return index;\n}; // In DEV mode, this Set helps us only log a warning once per component instace.\n// This avoids spamming the console every time a render happens.\n\nvar devWarningsDirection = null;\nvar devWarningsTagName = null;\n\nif (process.env.NODE_ENV !== 'production') {\n  if (typeof window !== 'undefined' && typeof window.WeakSet !== 'undefined') {\n    devWarningsDirection = /*#__PURE__*/new WeakSet();\n    devWarningsTagName = /*#__PURE__*/new WeakSet();\n  }\n}\n\nfunction createListComponent(_ref) {\n  var _class, _temp;\n\n  var getItemOffset = _ref.getItemOffset,\n      getEstimatedTotalSize = _ref.getEstimatedTotalSize,\n      getItemSize = _ref.getItemSize,\n      getOffsetForIndexAndAlignment = _ref.getOffsetForIndexAndAlignment,\n      getStartIndexForOffset = _ref.getStartIndexForOffset,\n      getStopIndexForStartIndex = _ref.getStopIndexForStartIndex,\n      initInstanceProps = _ref.initInstanceProps,\n      shouldResetStyleCacheOnItemSizeChange = _ref.shouldResetStyleCacheOnItemSizeChange,\n      validateProps = _ref.validateProps;\n  return _temp = _class = /*#__PURE__*/function (_PureComponent) {\n    _inheritsLoose(List, _PureComponent);\n\n    // Always use explicit constructor for React components.\n    // It produces less code after transpilation. (#26)\n    // eslint-disable-next-line no-useless-constructor\n    function List(props) {\n      var _this;\n\n      _this = _PureComponent.call(this, props) || this;\n      _this._instanceProps = initInstanceProps(_this.props, _assertThisInitialized(_this));\n      _this._outerRef = void 0;\n      _this._resetIsScrollingTimeoutId = null;\n      _this.state = {\n        instance: _assertThisInitialized(_this),\n        isScrolling: false,\n        scrollDirection: 'forward',\n        scrollOffset: typeof _this.props.initialScrollOffset === 'number' ? _this.props.initialScrollOffset : 0,\n        scrollUpdateWasRequested: false\n      };\n      _this._callOnItemsRendered = void 0;\n      _this._callOnItemsRendered = memoizeOne(function (overscanStartIndex, overscanStopIndex, visibleStartIndex, visibleStopIndex) {\n        return _this.props.onItemsRendered({\n          overscanStartIndex: overscanStartIndex,\n          overscanStopIndex: overscanStopIndex,\n          visibleStartIndex: visibleStartIndex,\n          visibleStopIndex: visibleStopIndex\n        });\n      });\n      _this._callOnScroll = void 0;\n      _this._callOnScroll = memoizeOne(function (scrollDirection, scrollOffset, scrollUpdateWasRequested) {\n        return _this.props.onScroll({\n          scrollDirection: scrollDirection,\n          scrollOffset: scrollOffset,\n          scrollUpdateWasRequested: scrollUpdateWasRequested\n        });\n      });\n      _this._getItemStyle = void 0;\n\n      _this._getItemStyle = function (index) {\n        var _this$props = _this.props,\n            direction = _this$props.direction,\n            itemSize = _this$props.itemSize,\n            layout = _this$props.layout;\n\n        var itemStyleCache = _this._getItemStyleCache(shouldResetStyleCacheOnItemSizeChange && itemSize, shouldResetStyleCacheOnItemSizeChange && layout, shouldResetStyleCacheOnItemSizeChange && direction);\n\n        var style;\n\n        if (itemStyleCache.hasOwnProperty(index)) {\n          style = itemStyleCache[index];\n        } else {\n          var _style;\n\n          var _offset = getItemOffset(_this.props, index, _this._instanceProps);\n\n          var size = getItemSize(_this.props, index, _this._instanceProps); // TODO Deprecate direction \"horizontal\"\n\n          var isHorizontal = direction === 'horizontal' || layout === 'horizontal';\n          itemStyleCache[index] = style = (_style = {\n            position: 'absolute'\n          }, _style[direction === 'rtl' ? 'right' : 'left'] = isHorizontal ? _offset : 0, _style.top = !isHorizontal ? _offset : 0, _style.height = !isHorizontal ? size : '100%', _style.width = isHorizontal ? size : '100%', _style);\n        }\n\n        return style;\n      };\n\n      _this._itemStyleCache = void 0;\n      _this._getItemStyleCache = void 0;\n      _this._getItemStyleCache = memoizeOne(function (_, __, ___) {\n        _this._itemStyleCache = {};\n        return _this._itemStyleCache;\n      });\n\n      _this._onScrollHorizontal = function (event) {\n        var _event$currentTarget = event.currentTarget,\n            clientWidth = _event$currentTarget.clientWidth,\n            scrollLeft = _event$currentTarget.scrollLeft,\n            scrollWidth = _event$currentTarget.scrollWidth;\n\n        _this.setState(function (prevState) {\n          if (prevState.scrollOffset === scrollLeft) {\n            // Scroll position may have been updated by cDM/cDU,\n            // In which case we don't need to trigger another render,\n            // And we don't want to update state.isScrolling.\n            return null;\n          }\n\n          var direction = _this.props.direction; // HACK According to the spec, scrollLeft should be negative for RTL aligned elements.\n          // Chrome does not seem to adhere; its scrolLeft values are positive (measured relative to the left).\n          // See https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollLeft\n\n          var scrollOffset = scrollLeft;\n\n          if (direction === 'rtl') {\n            if (scrollLeft <= 0) {\n              scrollOffset = -scrollOffset;\n            } else {\n              scrollOffset = scrollWidth - clientWidth - scrollLeft;\n            }\n          }\n\n          return {\n            isScrolling: true,\n            scrollDirection: prevState.scrollOffset < scrollLeft ? 'forward' : 'backward',\n            scrollOffset: scrollOffset,\n            scrollUpdateWasRequested: false\n          };\n        }, _this._resetIsScrollingDebounced);\n      };\n\n      _this._onScrollVertical = function (event) {\n        var scrollTop = event.currentTarget.scrollTop;\n\n        _this.setState(function (prevState) {\n          if (prevState.scrollOffset === scrollTop) {\n            // Scroll position may have been updated by cDM/cDU,\n            // In which case we don't need to trigger another render,\n            // And we don't want to update state.isScrolling.\n            return null;\n          }\n\n          return {\n            isScrolling: true,\n            scrollDirection: prevState.scrollOffset < scrollTop ? 'forward' : 'backward',\n            scrollOffset: scrollTop,\n            scrollUpdateWasRequested: false\n          };\n        }, _this._resetIsScrollingDebounced);\n      };\n\n      _this._outerRefSetter = function (ref) {\n        var outerRef = _this.props.outerRef;\n        _this._outerRef = ref;\n\n        if (typeof outerRef === 'function') {\n          outerRef(ref);\n        } else if (outerRef != null && typeof outerRef === 'object' && outerRef.hasOwnProperty('current')) {\n          outerRef.current = ref;\n        }\n      };\n\n      _this._resetIsScrollingDebounced = function () {\n        if (_this._resetIsScrollingTimeoutId !== null) {\n          cancelTimeout(_this._resetIsScrollingTimeoutId);\n        }\n\n        _this._resetIsScrollingTimeoutId = requestTimeout(_this._resetIsScrolling, IS_SCROLLING_DEBOUNCE_INTERVAL);\n      };\n\n      _this._resetIsScrolling = function () {\n        _this._resetIsScrollingTimeoutId = null;\n\n        _this.setState({\n          isScrolling: false\n        }, function () {\n          // Clear style cache after state update has been committed.\n          // This way we don't break pure sCU for items that don't use isScrolling param.\n          _this._getItemStyleCache(-1, null);\n        });\n      };\n\n      _this._instanceProps = initInstanceProps(_this.props, _assertThisInitialized(_this));\n      return _this;\n    }\n\n    List.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, prevState) {\n      validateSharedProps(nextProps, prevState);\n      validateProps(nextProps);\n      return null;\n    };\n\n    var _proto = List.prototype;\n\n    _proto.scrollTo = function scrollTo(scrollOffset) {\n      this.setState(function (prevState) {\n        return {\n          scrollDirection: prevState.scrollOffset < scrollOffset ? 'forward' : 'backward',\n          scrollOffset: scrollOffset,\n          scrollUpdateWasRequested: true\n        };\n      }, this._resetIsScrollingDebounced);\n    };\n\n    _proto.scrollToItem = function scrollToItem(index, align) {\n      if (align === void 0) {\n        align = 'auto';\n      }\n\n      var scrollOffset = this.state.scrollOffset;\n      this.scrollTo(getOffsetForIndexAndAlignment(this.props, index, align, scrollOffset, this._instanceProps));\n    };\n\n    _proto.componentDidMount = function componentDidMount() {\n      var _this$props2 = this.props,\n          direction = _this$props2.direction,\n          initialScrollOffset = _this$props2.initialScrollOffset,\n          layout = _this$props2.layout;\n\n      if (typeof initialScrollOffset === 'number' && this._outerRef !== null) {\n        // TODO Deprecate direction \"horizontal\"\n        if (direction === 'horizontal' || layout === 'horizontal') {\n          this._outerRef.scrollLeft = initialScrollOffset;\n        } else {\n          this._outerRef.scrollTop = initialScrollOffset;\n        }\n      }\n\n      this._callPropsCallbacks();\n\n      this._commitHook();\n    };\n\n    _proto.componentDidUpdate = function componentDidUpdate() {\n      var _this$props3 = this.props,\n          direction = _this$props3.direction,\n          layout = _this$props3.layout;\n      var _this$state = this.state,\n          scrollOffset = _this$state.scrollOffset,\n          scrollUpdateWasRequested = _this$state.scrollUpdateWasRequested;\n\n      if (scrollUpdateWasRequested && this._outerRef !== null) {\n        // TODO Deprecate direction \"horizontal\"\n        if (direction === 'horizontal' || layout === 'horizontal') {\n          this._outerRef.scrollLeft = scrollOffset;\n        } else {\n          this._outerRef.scrollTop = scrollOffset;\n        }\n      }\n\n      this._callPropsCallbacks();\n\n      this._commitHook();\n    };\n\n    _proto.componentWillUnmount = function componentWillUnmount() {\n      if (this._resetIsScrollingTimeoutId !== null) {\n        cancelTimeout(this._resetIsScrollingTimeoutId);\n      }\n\n      this._unmountHook();\n    };\n\n    _proto.render = function render() {\n      var _this$props4 = this.props,\n          className = _this$props4.className,\n          direction = _this$props4.direction,\n          height = _this$props4.height,\n          innerRef = _this$props4.innerRef,\n          innerElementType = _this$props4.innerElementType,\n          innerTagName = _this$props4.innerTagName,\n          layout = _this$props4.layout,\n          outerElementType = _this$props4.outerElementType,\n          outerTagName = _this$props4.outerTagName,\n          style = _this$props4.style,\n          width = _this$props4.width;\n      var isScrolling = this.state.isScrolling; // TODO Deprecate direction \"horizontal\"\n\n      var isHorizontal = direction === 'horizontal' || layout === 'horizontal';\n      var onScroll = isHorizontal ? this._onScrollHorizontal : this._onScrollVertical;\n\n      var items = this._renderItems(); // Read this value AFTER items have been created,\n      // So their actual sizes (if variable) are taken into consideration.\n\n\n      var estimatedTotalSize = getEstimatedTotalSize(this.props, this._instanceProps);\n      return createElement(outerElementType || outerTagName || 'div', {\n        className: className,\n        onScroll: onScroll,\n        ref: this._outerRefSetter,\n        style: _extends({\n          height: height,\n          width: width,\n          overflow: 'auto',\n          position: 'relative',\n          WebkitOverflowScrolling: 'touch',\n          willChange: 'transform',\n          direction: direction\n        }, style)\n      }, createElement(innerElementType || innerTagName || 'div', {\n        children: items,\n        ref: innerRef,\n        style: {\n          height: isHorizontal ? '100%' : estimatedTotalSize,\n          pointerEvents: isScrolling ? 'none' : '',\n          width: isHorizontal ? estimatedTotalSize : '100%'\n        }\n      }));\n    };\n\n    _proto._callPropsCallbacks = function _callPropsCallbacks() {\n      if (typeof this.props.onItemsRendered === 'function') {\n        var itemCount = this.props.itemCount;\n\n        if (itemCount > 0) {\n          var _this$_getRangeToRend = this._getRangeToRender(),\n              _overscanStartIndex = _this$_getRangeToRend[0],\n              _overscanStopIndex = _this$_getRangeToRend[1],\n              _visibleStartIndex = _this$_getRangeToRend[2],\n              _visibleStopIndex = _this$_getRangeToRend[3];\n\n          this._callOnItemsRendered(_overscanStartIndex, _overscanStopIndex, _visibleStartIndex, _visibleStopIndex);\n        }\n      }\n\n      if (typeof this.props.onScroll === 'function') {\n        var _this$state2 = this.state,\n            _scrollDirection = _this$state2.scrollDirection,\n            _scrollOffset = _this$state2.scrollOffset,\n            _scrollUpdateWasRequested = _this$state2.scrollUpdateWasRequested;\n\n        this._callOnScroll(_scrollDirection, _scrollOffset, _scrollUpdateWasRequested);\n      }\n    } // This method is called after mount and update.\n    // List implementations can override this method to be notified.\n    ;\n\n    _proto._commitHook = function _commitHook() {} // This method is called before unmounting.\n    // List implementations can override this method to be notified.\n    ;\n\n    _proto._unmountHook = function _unmountHook() {} // Lazily create and cache item styles while scrolling,\n    // So that pure component sCU will prevent re-renders.\n    // We maintain this cache, and pass a style prop rather than index,\n    // So that List can clear cached styles and force item re-render if necessary.\n    ;\n\n    _proto._getRangeToRender = function _getRangeToRender() {\n      var _this$props5 = this.props,\n          itemCount = _this$props5.itemCount,\n          overscanCount = _this$props5.overscanCount;\n      var _this$state3 = this.state,\n          isScrolling = _this$state3.isScrolling,\n          scrollDirection = _this$state3.scrollDirection,\n          scrollOffset = _this$state3.scrollOffset;\n\n      if (itemCount === 0) {\n        return [0, 0, 0, 0];\n      }\n\n      var startIndex = getStartIndexForOffset(this.props, scrollOffset, this._instanceProps);\n      var stopIndex = getStopIndexForStartIndex(this.props, startIndex, scrollOffset, this._instanceProps); // Overscan by one item in each direction so that tab/focus works.\n      // If there isn't at least one extra item, tab loops back around.\n\n      var overscanBackward = !isScrolling || scrollDirection === 'backward' ? Math.max(1, overscanCount) : 1;\n      var overscanForward = !isScrolling || scrollDirection === 'forward' ? Math.max(1, overscanCount) : 1;\n      return [Math.max(0, startIndex - overscanBackward), Math.max(0, Math.min(itemCount - 1, stopIndex + overscanForward)), startIndex, stopIndex];\n    };\n\n    _proto._renderItems = function _renderItems() {\n      var _this$props6 = this.props,\n          children = _this$props6.children,\n          itemCount = _this$props6.itemCount,\n          itemData = _this$props6.itemData,\n          _this$props6$itemKey = _this$props6.itemKey,\n          itemKey = _this$props6$itemKey === void 0 ? defaultItemKey : _this$props6$itemKey,\n          useIsScrolling = _this$props6.useIsScrolling;\n      var isScrolling = this.state.isScrolling;\n\n      var _this$_getRangeToRend2 = this._getRangeToRender(),\n          startIndex = _this$_getRangeToRend2[0],\n          stopIndex = _this$_getRangeToRend2[1];\n\n      var items = [];\n\n      if (itemCount > 0) {\n        for (var _index = startIndex; _index <= stopIndex; _index++) {\n          items.push(createElement(children, {\n            data: itemData,\n            key: itemKey(_index, itemData),\n            index: _index,\n            isScrolling: useIsScrolling ? isScrolling : undefined,\n            style: this._getItemStyle(_index)\n          }));\n        }\n      }\n\n      return items;\n    };\n\n    return List;\n  }(PureComponent), _class.defaultProps = {\n    direction: 'ltr',\n    itemData: undefined,\n    layout: 'vertical',\n    overscanCount: 2,\n    useIsScrolling: false\n  }, _temp;\n} // NOTE: I considered further wrapping individual items with a pure ListItem component.\n// This would avoid ever calling the render function for the same index more than once,\n// But it would also add the overhead of a lot of components/fibers.\n// I assume people already do this (render function returning a class component),\n// So my doing it would just unnecessarily double the wrappers.\n\nvar validateSharedProps = function validateSharedProps(_ref2, _ref3) {\n  var children = _ref2.children,\n      direction = _ref2.direction,\n      height = _ref2.height,\n      layout = _ref2.layout,\n      innerTagName = _ref2.innerTagName,\n      outerTagName = _ref2.outerTagName,\n      width = _ref2.width;\n  var instance = _ref3.instance;\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (innerTagName != null || outerTagName != null) {\n      if (devWarningsTagName && !devWarningsTagName.has(instance)) {\n        devWarningsTagName.add(instance);\n        console.warn('The innerTagName and outerTagName props have been deprecated. ' + 'Please use the innerElementType and outerElementType props instead.');\n      }\n    } // TODO Deprecate direction \"horizontal\"\n\n\n    var isHorizontal = direction === 'horizontal' || layout === 'horizontal';\n\n    switch (direction) {\n      case 'horizontal':\n      case 'vertical':\n        if (devWarningsDirection && !devWarningsDirection.has(instance)) {\n          devWarningsDirection.add(instance);\n          console.warn('The direction prop should be either \"ltr\" (default) or \"rtl\". ' + 'Please use the layout prop to specify \"vertical\" (default) or \"horizontal\" orientation.');\n        }\n\n        break;\n\n      case 'ltr':\n      case 'rtl':\n        // Valid values\n        break;\n\n      default:\n        throw Error('An invalid \"direction\" prop has been specified. ' + 'Value should be either \"ltr\" or \"rtl\". ' + (\"\\\"\" + direction + \"\\\" was specified.\"));\n    }\n\n    switch (layout) {\n      case 'horizontal':\n      case 'vertical':\n        // Valid values\n        break;\n\n      default:\n        throw Error('An invalid \"layout\" prop has been specified. ' + 'Value should be either \"horizontal\" or \"vertical\". ' + (\"\\\"\" + layout + \"\\\" was specified.\"));\n    }\n\n    if (children == null) {\n      throw Error('An invalid \"children\" prop has been specified. ' + 'Value should be a React component. ' + (\"\\\"\" + (children === null ? 'null' : typeof children) + \"\\\" was specified.\"));\n    }\n\n    if (isHorizontal && typeof width !== 'number') {\n      throw Error('An invalid \"width\" prop has been specified. ' + 'Horizontal lists must specify a number for width. ' + (\"\\\"\" + (width === null ? 'null' : typeof width) + \"\\\" was specified.\"));\n    } else if (!isHorizontal && typeof height !== 'number') {\n      throw Error('An invalid \"height\" prop has been specified. ' + 'Vertical lists must specify a number for height. ' + (\"\\\"\" + (height === null ? 'null' : typeof height) + \"\\\" was specified.\"));\n    }\n  }\n};\n\nvar findDOMNodeWarningsSet = null;\n\nif (process.env.NODE_ENV !== 'production') {\n  findDOMNodeWarningsSet = /*#__PURE__*/new Set();\n}\n\nvar ItemMeasurer = /*#__PURE__*/function (_Component) {\n  _inheritsLoose(ItemMeasurer, _Component);\n\n  function ItemMeasurer() {\n    var _this;\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _Component.call.apply(_Component, [this].concat(args)) || this;\n    _this._didProvideValidRef = false;\n    _this._node = null;\n    _this._resizeObserver = null;\n\n    _this._measureItem = function (isCommitPhase) {\n      var _this$props = _this.props,\n          direction = _this$props.direction,\n          layout = _this$props.layout,\n          handleNewMeasurements = _this$props.handleNewMeasurements,\n          index = _this$props.index,\n          oldSize = _this$props.size;\n      var node = _this._node;\n\n      if (node && node.ownerDocument && node.ownerDocument.defaultView && node instanceof node.ownerDocument.defaultView.HTMLElement) {\n        var newSize = direction === 'horizontal' || layout === 'horizontal' ? Math.ceil(node.offsetWidth) : Math.ceil(node.offsetHeight);\n\n        if (oldSize !== newSize) {\n          handleNewMeasurements(index, newSize, isCommitPhase);\n        }\n      }\n    };\n\n    _this._refSetter = function (ref) {\n      if (_this._resizeObserver !== null && _this._node !== null) {\n        _this._resizeObserver.unobserve(_this._node);\n      }\n\n      if (ref instanceof HTMLElement) {\n        _this._didProvideValidRef = true;\n        _this._node = ref;\n      } else if (ref !== null) {\n        _this._node = findDOMNode(ref);\n      }\n\n      if (_this._resizeObserver !== null && _this._node !== null) {\n        _this._resizeObserver.observe(_this._node);\n      }\n    };\n\n    _this._onResize = function () {\n      _this._measureItem(false);\n    };\n\n    return _this;\n  }\n\n  var _proto = ItemMeasurer.prototype;\n\n  _proto.componentDidMount = function componentDidMount() {\n    if (process.env.NODE_ENV !== 'production') {\n      if (!this._didProvideValidRef) {\n        var item = this.props.item;\n        var displayName = item && item.type ? item.type.displayName || item.type.name || '(unknown)' : '(unknown)';\n\n        if (!findDOMNodeWarningsSet.has(displayName)) {\n          findDOMNodeWarningsSet.add(displayName);\n          console.warn('DynamicSizeList item renderers should attach a ref to the topmost HTMLElement they render. ' + (\"The item renderer \\\"\" + displayName + \"\\\" did not attach a ref to a valid HTMLElement. \") + 'findDOMNode() will be used as a fallback, but is slower and more error prone than using a ref.\\n\\n' + 'Learn more about ref forwarding: ' + 'https://reactjs.org/docs/forwarding-refs.html#forwarding-refs-to-dom-components');\n        }\n      }\n    } // Force sync measure for the initial mount.\n    // This is necessary to support the DynamicSizeList layout logic.\n\n\n    this._measureItem(true);\n\n    if (typeof ResizeObserver !== 'undefined') {\n      // Watch for resizes due to changed content,\n      // Or changes in the size of the parent container.\n      this._resizeObserver = new ResizeObserver(this._onResize);\n\n      if (this._node !== null) {\n        this._resizeObserver.observe(this._node);\n      }\n    }\n  };\n\n  _proto.componentWillUnmount = function componentWillUnmount() {\n    if (this._resizeObserver !== null) {\n      this._resizeObserver.disconnect();\n    }\n  };\n\n  _proto.render = function render() {\n    return cloneElement(this.props.item, {\n      ref: this._refSetter\n    });\n  };\n\n  return ItemMeasurer;\n}(Component);\n\nvar DEFAULT_ESTIMATED_ITEM_SIZE = 50;\n\nvar getItemMetadata = function getItemMetadata(props, index, instanceProps) {\n  var estimatedItemSize = instanceProps.estimatedItemSize,\n      instance = instanceProps.instance,\n      itemOffsetMap = instanceProps.itemOffsetMap,\n      itemSizeMap = instanceProps.itemSizeMap,\n      lastMeasuredIndex = instanceProps.lastMeasuredIndex,\n      lastPositionedIndex = instanceProps.lastPositionedIndex; // If the specified item has not yet been measured,\n  // Just return an estimated size for now.\n\n  if (index > lastMeasuredIndex) {\n    return {\n      offset: 0,\n      size: estimatedItemSize\n    };\n  } // Lazily update positions if they are stale.\n\n\n  if (index > lastPositionedIndex) {\n    if (lastPositionedIndex < 0) {\n      itemOffsetMap[0] = 0;\n    }\n\n    for (var i = Math.max(1, lastPositionedIndex + 1); i <= index; i++) {\n      var prevOffset = itemOffsetMap[i - 1]; // In some browsers (e.g. Firefox) fast scrolling may skip rows.\n      // In this case, our assumptions about last measured indices may be incorrect.\n      // Handle this edge case to prevent NaN values from breaking styles.\n      // Slow scrolling back over these skipped rows will adjust their sizes.\n\n      var prevSize = itemSizeMap[i - 1] || 0;\n      itemOffsetMap[i] = prevOffset + prevSize; // Reset cached style to clear stale position.\n\n      delete instance._itemStyleCache[i];\n    }\n\n    instanceProps.lastPositionedIndex = index;\n  }\n\n  var offset = itemOffsetMap[index];\n  var size = itemSizeMap[index];\n  return {\n    offset: offset,\n    size: size\n  };\n};\n\nvar findNearestItemBinarySearch = function findNearestItemBinarySearch(props, instanceProps, high, low, offset) {\n  while (low <= high) {\n    var middle = low + Math.floor((high - low) / 2);\n    var currentOffset = getItemMetadata(props, middle, instanceProps).offset;\n\n    if (currentOffset === offset) {\n      return middle;\n    } else if (currentOffset < offset) {\n      low = middle + 1;\n    } else if (currentOffset > offset) {\n      high = middle - 1;\n    }\n  }\n\n  if (low > 0) {\n    return low - 1;\n  } else {\n    return 0;\n  }\n};\n\nvar getEstimatedTotalSize = function getEstimatedTotalSize(_ref, _ref2) {\n  var itemCount = _ref.itemCount;\n  var itemSizeMap = _ref2.itemSizeMap,\n      estimatedItemSize = _ref2.estimatedItemSize,\n      lastMeasuredIndex = _ref2.lastMeasuredIndex,\n      totalMeasuredSize = _ref2.totalMeasuredSize;\n  return totalMeasuredSize + (itemCount - lastMeasuredIndex - 1) * estimatedItemSize;\n};\n\nvar DynamicSizeList = /*#__PURE__*/createListComponent({\n  getItemOffset: function getItemOffset(props, index, instanceProps) {\n    return getItemMetadata(props, index, instanceProps).offset;\n  },\n  getItemSize: function getItemSize(props, index, instanceProps) {\n    // Do not hard-code item dimensions.\n    // We don't know them initially.\n    // Even once we do, changes in item content or list size should reflow.\n    return undefined;\n  },\n  getEstimatedTotalSize: getEstimatedTotalSize,\n  getOffsetForIndexAndAlignment: function getOffsetForIndexAndAlignment(props, index, align, scrollOffset, instanceProps) {\n    var direction = props.direction,\n        layout = props.layout,\n        height = props.height,\n        width = props.width;\n\n    if (process.env.NODE_ENV !== 'production') {\n      var lastMeasuredIndex = instanceProps.lastMeasuredIndex;\n\n      if (index > lastMeasuredIndex) {\n        console.warn(\"DynamicSizeList does not support scrolling to items that yave not yet measured. \" + (\"scrollToItem() was called with index \" + index + \" but the last measured item was \" + lastMeasuredIndex + \".\"));\n      }\n    }\n\n    var size = direction === 'horizontal' || layout === 'horizontal' ? width : height;\n    var itemMetadata = getItemMetadata(props, index, instanceProps); // Get estimated total size after ItemMetadata is computed,\n    // To ensure it reflects actual measurements instead of just estimates.\n\n    var estimatedTotalSize = getEstimatedTotalSize(props, instanceProps);\n    var maxOffset = Math.min(estimatedTotalSize - size, itemMetadata.offset);\n    var minOffset = Math.max(0, itemMetadata.offset - size + itemMetadata.size);\n\n    switch (align) {\n      case 'start':\n        return maxOffset;\n\n      case 'end':\n        return minOffset;\n\n      case 'center':\n        return Math.round(minOffset + (maxOffset - minOffset) / 2);\n\n      case 'auto':\n      default:\n        if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {\n          return scrollOffset;\n        } else if (scrollOffset - minOffset < maxOffset - scrollOffset) {\n          return minOffset;\n        } else {\n          return maxOffset;\n        }\n\n    }\n  },\n  getStartIndexForOffset: function getStartIndexForOffset(props, offset, instanceProps) {\n    var lastMeasuredIndex = instanceProps.lastMeasuredIndex,\n        totalMeasuredSize = instanceProps.totalMeasuredSize; // If we've already positioned and measured past this point,\n    // Use a binary search to find the closets cell.\n\n    if (offset <= totalMeasuredSize) {\n      return findNearestItemBinarySearch(props, instanceProps, lastMeasuredIndex, 0, offset);\n    } // Otherwise render a new batch of items starting from where we left off.\n\n\n    return lastMeasuredIndex + 1;\n  },\n  getStopIndexForStartIndex: function getStopIndexForStartIndex(props, startIndex, scrollOffset, instanceProps) {\n    var direction = props.direction,\n        layout = props.layout,\n        height = props.height,\n        itemCount = props.itemCount,\n        width = props.width;\n    var size = direction === 'horizontal' || layout === 'horizontal' ? width : height;\n    var itemMetadata = getItemMetadata(props, startIndex, instanceProps);\n    var maxOffset = scrollOffset + size;\n    var offset = itemMetadata.offset + itemMetadata.size;\n    var stopIndex = startIndex;\n\n    while (stopIndex < itemCount - 1 && offset < maxOffset) {\n      stopIndex++;\n      offset += getItemMetadata(props, stopIndex, instanceProps).size;\n    }\n\n    return stopIndex;\n  },\n  initInstanceProps: function initInstanceProps(props, instance) {\n    var _ref3 = props,\n        estimatedItemSize = _ref3.estimatedItemSize;\n    var instanceProps = {\n      estimatedItemSize: estimatedItemSize || DEFAULT_ESTIMATED_ITEM_SIZE,\n      instance: instance,\n      itemOffsetMap: {},\n      itemSizeMap: {},\n      lastMeasuredIndex: -1,\n      lastPositionedIndex: -1,\n      totalMeasuredSize: 0\n    };\n    var debounceForceUpdateID = null;\n\n    var debounceForceUpdate = function debounceForceUpdate() {\n      if (debounceForceUpdateID === null) {\n        debounceForceUpdateID = setTimeout(function () {\n          debounceForceUpdateID = null;\n          instance.forceUpdate();\n        }, 1);\n      }\n    }; // This method is called before unmounting.\n\n\n    instance._unmountHook = function () {\n      if (debounceForceUpdateID !== null) {\n        clearTimeout(debounceForceUpdateID);\n        debounceForceUpdateID = null;\n      }\n    };\n\n    var hasNewMeasurements = false;\n    var sizeDeltaTotal = 0; // This method is called after mount and update.\n\n    instance._commitHook = function () {\n      if (hasNewMeasurements) {\n        hasNewMeasurements = false; // Edge case where cell sizes changed, but cancelled each other out.\n        // We still need to re-render in this case,\n        // Even though we don't need to adjust scroll offset.\n\n        if (sizeDeltaTotal === 0) {\n          instance.forceUpdate();\n          return;\n        }\n\n        var shouldForceUpdate; // In the setState commit hook, we'll decrement sizeDeltaTotal.\n        // In case the state update is processed synchronously,\n        // And triggers additional size updates itself,\n        // We should only drecement by the amount we updated state for originally.\n\n        var sizeDeltaForStateUpdate = sizeDeltaTotal; // If the user is scrolling up, we need to adjust the scroll offset,\n        // To prevent items from \"jumping\" as items before them have been resized.\n\n        instance.setState(function (prevState) {\n          if (prevState.scrollDirection === 'backward' && !prevState.scrollUpdateWasRequested) {\n            // TRICKY\n            // If item(s) have changed size since they were last displayed, content will appear to jump.\n            // To avoid this, we need to make small adjustments as a user scrolls to preserve apparent position.\n            // This also ensures that the first item eventually aligns with scroll offset 0.\n            return {\n              scrollOffset: prevState.scrollOffset + sizeDeltaForStateUpdate\n            };\n          } else {\n            // There's no state to update,\n            // But we still want to re-render in this case.\n            shouldForceUpdate = true;\n            return null;\n          }\n        }, function () {\n          if (shouldForceUpdate) {\n            instance.forceUpdate();\n          } else {\n            var scrollOffset = instance.state.scrollOffset;\n            var _instance$props = instance.props,\n                direction = _instance$props.direction,\n                layout = _instance$props.layout; // Adjusting scroll offset directly interrupts smooth scrolling for some browsers (e.g. Firefox).\n            // The relative scrollBy() method doesn't interrupt (or at least it won't as of Firefox v65).\n            // Other browsers (e.g. Chrome, Safari) seem to handle both adjustments equally well.\n            // See https://bugzilla.mozilla.org/show_bug.cgi?id=1502059\n\n            var element = instance._outerRef; // $FlowFixMe Property scrollBy is missing in HTMLDivElement\n\n            if (typeof element.scrollBy === 'function') {\n              element.scrollBy(direction === 'horizontal' || layout === 'horizontal' ? sizeDeltaForStateUpdate : 0, direction === 'horizontal' || layout === 'horizontal' ? 0 : sizeDeltaForStateUpdate);\n            } else if (direction === 'horizontal' || layout === 'horizontal') {\n              element.scrollLeft = scrollOffset;\n            } else {\n              element.scrollTop = scrollOffset;\n            }\n          }\n\n          sizeDeltaTotal -= sizeDeltaForStateUpdate;\n        });\n      }\n    }; // This function may be called out of order!\n    // It is not safe to reposition items here.\n    // Be careful when comparing index and lastMeasuredIndex.\n\n\n    var handleNewMeasurements = function handleNewMeasurements(index, newSize, isFirstMeasureAfterMounting) {\n      var itemSizeMap = instanceProps.itemSizeMap,\n          lastMeasuredIndex = instanceProps.lastMeasuredIndex,\n          lastPositionedIndex = instanceProps.lastPositionedIndex; // In some browsers (e.g. Firefox) fast scrolling may skip rows.\n      // In this case, our assumptions about last measured indices may be incorrect.\n      // Handle this edge case to prevent NaN values from breaking styles.\n      // Slow scrolling back over these skipped rows will adjust their sizes.\n\n      var oldSize = itemSizeMap[index] || 0; // Mark offsets after this as stale so that getItemMetadata() will lazily recalculate it.\n\n      if (index < lastPositionedIndex) {\n        instanceProps.lastPositionedIndex = index;\n      }\n\n      if (index <= lastMeasuredIndex) {\n        if (oldSize === newSize) {\n          return;\n        } // Adjust total size estimate by the delta in size.\n\n\n        instanceProps.totalMeasuredSize += newSize - oldSize; // Record the size delta here in case the user is scrolling up.\n        // In that event, we need to adjust the scroll offset by thie amount,\n        // To prevent items from \"jumping\" as items before them are resized.\n        // We only do this for items that are newly measured (after mounting).\n        // Ones that change size later do not need to affect scroll offset.\n\n        if (isFirstMeasureAfterMounting) {\n          sizeDeltaTotal += newSize - oldSize;\n        }\n      } else {\n        instanceProps.lastMeasuredIndex = index;\n        instanceProps.totalMeasuredSize += newSize;\n      }\n\n      itemSizeMap[index] = newSize; // Even though the size has changed, we don't need to reset the cached style,\n      // Because dynamic list items don't have constrained sizes.\n      // This enables them to resize when their content (or container size) changes.\n      // It also lets us avoid an unnecessary render in this case.\n\n      if (isFirstMeasureAfterMounting) {\n        hasNewMeasurements = true;\n      } else {\n        debounceForceUpdate();\n      }\n    };\n\n    instance._handleNewMeasurements = handleNewMeasurements; // Override the item-rendering process to wrap items with ItemMeasurer.\n    // This keep the external API simpler.\n\n    instance._renderItems = function () {\n      var _instance$props2 = instance.props,\n          children = _instance$props2.children,\n          direction = _instance$props2.direction,\n          layout = _instance$props2.layout,\n          itemCount = _instance$props2.itemCount,\n          itemData = _instance$props2.itemData,\n          _instance$props2$item = _instance$props2.itemKey,\n          itemKey = _instance$props2$item === void 0 ? defaultItemKey : _instance$props2$item,\n          useIsScrolling = _instance$props2.useIsScrolling;\n      var isScrolling = instance.state.isScrolling;\n\n      var _instance$_getRangeTo = instance._getRangeToRender(),\n          startIndex = _instance$_getRangeTo[0],\n          stopIndex = _instance$_getRangeTo[1];\n\n      var items = [];\n\n      if (itemCount > 0) {\n        for (var _index = startIndex; _index <= stopIndex; _index++) {\n          var _getItemMetadata = getItemMetadata(instance.props, _index, instanceProps),\n              size = _getItemMetadata.size; // It's important to read style after fetching item metadata.\n          // getItemMetadata() will clear stale styles.\n\n\n          var style = instance._getItemStyle(_index);\n\n          var item = createElement(children, {\n            data: itemData,\n            index: _index,\n            isScrolling: useIsScrolling ? isScrolling : undefined,\n            style: style\n          }); // Always wrap children in a ItemMeasurer to detect changes in size.\n\n          items.push(createElement(ItemMeasurer, {\n            direction: direction,\n            layout: layout,\n            handleNewMeasurements: handleNewMeasurements,\n            index: _index,\n            item: item,\n            key: itemKey(_index),\n            size: size\n          }));\n        }\n      }\n\n      return items;\n    };\n\n    return instanceProps;\n  },\n  shouldResetStyleCacheOnItemSizeChange: false,\n  validateProps: function validateProps(_ref4) {\n    var itemSize = _ref4.itemSize;\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (itemSize !== undefined) {\n        throw Error('An unexpected \"itemSize\" prop has been provided.');\n      }\n    }\n  }\n});\n\nvar size = -1; // This utility copied from \"dom-helpers\" package.\n\nfunction getScrollbarSize(recalculate) {\n  if (recalculate === void 0) {\n    recalculate = false;\n  }\n\n  if (size === -1 || recalculate) {\n    var div = document.createElement('div');\n    var style = div.style;\n    style.width = '50px';\n    style.height = '50px';\n    style.overflow = 'scroll';\n    document.body.appendChild(div);\n    size = div.offsetWidth - div.clientWidth;\n    document.body.removeChild(div);\n  }\n\n  return size;\n}\n\nvar IS_SCROLLING_DEBOUNCE_INTERVAL$1 = 150;\n\nvar defaultItemKey$1 = function defaultItemKey(_ref) {\n  var columnIndex = _ref.columnIndex,\n      data = _ref.data,\n      rowIndex = _ref.rowIndex;\n  return rowIndex + \":\" + columnIndex;\n}; // In DEV mode, this Set helps us only log a warning once per component instace.\n// This avoids spamming the console every time a render happens.\n\n\nvar devWarningsOverscanCount = null;\nvar devWarningsTagName$1 = null;\n\nif (process.env.NODE_ENV !== 'production') {\n  if (typeof window !== 'undefined' && typeof window.WeakSet !== 'undefined') {\n    devWarningsOverscanCount = /*#__PURE__*/new WeakSet();\n    devWarningsTagName$1 = /*#__PURE__*/new WeakSet();\n  }\n}\n\nfunction createGridComponent(_ref2) {\n  var _class, _temp;\n\n  var getColumnOffset = _ref2.getColumnOffset,\n      getColumnStartIndexForOffset = _ref2.getColumnStartIndexForOffset,\n      getColumnStopIndexForStartIndex = _ref2.getColumnStopIndexForStartIndex,\n      getColumnWidth = _ref2.getColumnWidth,\n      getEstimatedTotalHeight = _ref2.getEstimatedTotalHeight,\n      getEstimatedTotalWidth = _ref2.getEstimatedTotalWidth,\n      getOffsetForColumnAndAlignment = _ref2.getOffsetForColumnAndAlignment,\n      getOffsetForRowAndAlignment = _ref2.getOffsetForRowAndAlignment,\n      getRowHeight = _ref2.getRowHeight,\n      getRowOffset = _ref2.getRowOffset,\n      getRowStartIndexForOffset = _ref2.getRowStartIndexForOffset,\n      getRowStopIndexForStartIndex = _ref2.getRowStopIndexForStartIndex,\n      initInstanceProps = _ref2.initInstanceProps,\n      shouldResetStyleCacheOnItemSizeChange = _ref2.shouldResetStyleCacheOnItemSizeChange,\n      validateProps = _ref2.validateProps;\n  return _temp = _class = /*#__PURE__*/function (_PureComponent) {\n    _inheritsLoose(Grid, _PureComponent);\n\n    // Always use explicit constructor for React components.\n    // It produces less code after transpilation. (#26)\n    // eslint-disable-next-line no-useless-constructor\n    function Grid(props) {\n      var _this;\n\n      _this = _PureComponent.call(this, props) || this;\n      _this._instanceProps = initInstanceProps(_this.props, _assertThisInitialized(_this));\n      _this._resetIsScrollingTimeoutId = null;\n      _this._outerRef = void 0;\n      _this.state = {\n        instance: _assertThisInitialized(_this),\n        isScrolling: false,\n        horizontalScrollDirection: 'forward',\n        scrollLeft: typeof _this.props.initialScrollLeft === 'number' ? _this.props.initialScrollLeft : 0,\n        scrollTop: typeof _this.props.initialScrollTop === 'number' ? _this.props.initialScrollTop : 0,\n        scrollUpdateWasRequested: false,\n        verticalScrollDirection: 'forward'\n      };\n      _this._callOnItemsRendered = void 0;\n      _this._callOnItemsRendered = memoizeOne(function (overscanColumnStartIndex, overscanColumnStopIndex, overscanRowStartIndex, overscanRowStopIndex, visibleColumnStartIndex, visibleColumnStopIndex, visibleRowStartIndex, visibleRowStopIndex) {\n        return _this.props.onItemsRendered({\n          overscanColumnStartIndex: overscanColumnStartIndex,\n          overscanColumnStopIndex: overscanColumnStopIndex,\n          overscanRowStartIndex: overscanRowStartIndex,\n          overscanRowStopIndex: overscanRowStopIndex,\n          visibleColumnStartIndex: visibleColumnStartIndex,\n          visibleColumnStopIndex: visibleColumnStopIndex,\n          visibleRowStartIndex: visibleRowStartIndex,\n          visibleRowStopIndex: visibleRowStopIndex\n        });\n      });\n      _this._callOnScroll = void 0;\n      _this._callOnScroll = memoizeOne(function (scrollLeft, scrollTop, horizontalScrollDirection, verticalScrollDirection, scrollUpdateWasRequested) {\n        return _this.props.onScroll({\n          horizontalScrollDirection: horizontalScrollDirection,\n          scrollLeft: scrollLeft,\n          scrollTop: scrollTop,\n          verticalScrollDirection: verticalScrollDirection,\n          scrollUpdateWasRequested: scrollUpdateWasRequested\n        });\n      });\n      _this._getItemStyle = void 0;\n\n      _this._getItemStyle = function (rowIndex, columnIndex) {\n        var _this$props = _this.props,\n            columnWidth = _this$props.columnWidth,\n            direction = _this$props.direction,\n            rowHeight = _this$props.rowHeight;\n\n        var itemStyleCache = _this._getItemStyleCache(shouldResetStyleCacheOnItemSizeChange && columnWidth, shouldResetStyleCacheOnItemSizeChange && direction, shouldResetStyleCacheOnItemSizeChange && rowHeight);\n\n        var key = rowIndex + \":\" + columnIndex;\n        var style;\n\n        if (itemStyleCache.hasOwnProperty(key)) {\n          style = itemStyleCache[key];\n        } else {\n          var _style;\n\n          itemStyleCache[key] = style = (_style = {\n            position: 'absolute'\n          }, _style[direction === 'rtl' ? 'right' : 'left'] = getColumnOffset(_this.props, columnIndex, _this._instanceProps), _style.top = getRowOffset(_this.props, rowIndex, _this._instanceProps), _style.height = getRowHeight(_this.props, rowIndex, _this._instanceProps), _style.width = getColumnWidth(_this.props, columnIndex, _this._instanceProps), _style);\n        }\n\n        return style;\n      };\n\n      _this._getItemStyleCache = void 0;\n      _this._getItemStyleCache = memoizeOne(function (_, __, ___) {\n        return {};\n      });\n\n      _this._onScroll = function (event) {\n        var _event$currentTarget = event.currentTarget,\n            clientWidth = _event$currentTarget.clientWidth,\n            scrollLeft = _event$currentTarget.scrollLeft,\n            scrollTop = _event$currentTarget.scrollTop,\n            scrollWidth = _event$currentTarget.scrollWidth;\n\n        _this.setState(function (prevState) {\n          if (prevState.scrollLeft === scrollLeft && prevState.scrollTop === scrollTop) {\n            // Scroll position may have been updated by cDM/cDU,\n            // In which case we don't need to trigger another render,\n            // And we don't want to update state.isScrolling.\n            return null;\n          }\n\n          var direction = _this.props.direction; // HACK According to the spec, scrollLeft should be negative for RTL aligned elements.\n          // Chrome does not seem to adhere; its scrolLeft values are positive (measured relative to the left).\n          // See https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollLeft\n\n          var calculatedScrollLeft = scrollLeft;\n\n          if (direction === 'rtl') {\n            if (scrollLeft <= 0) {\n              calculatedScrollLeft = -scrollLeft;\n            } else {\n              calculatedScrollLeft = scrollWidth - clientWidth - scrollLeft;\n            }\n          }\n\n          return {\n            isScrolling: true,\n            horizontalScrollDirection: prevState.scrollLeft < scrollLeft ? 'forward' : 'backward',\n            scrollLeft: calculatedScrollLeft,\n            scrollTop: scrollTop,\n            verticalScrollDirection: prevState.scrollTop < scrollTop ? 'forward' : 'backward',\n            scrollUpdateWasRequested: false\n          };\n        }, _this._resetIsScrollingDebounced);\n      };\n\n      _this._outerRefSetter = function (ref) {\n        var outerRef = _this.props.outerRef;\n        _this._outerRef = ref;\n\n        if (typeof outerRef === 'function') {\n          outerRef(ref);\n        } else if (outerRef != null && typeof outerRef === 'object' && outerRef.hasOwnProperty('current')) {\n          outerRef.current = ref;\n        }\n      };\n\n      _this._resetIsScrollingDebounced = function () {\n        if (_this._resetIsScrollingTimeoutId !== null) {\n          cancelTimeout(_this._resetIsScrollingTimeoutId);\n        }\n\n        _this._resetIsScrollingTimeoutId = requestTimeout(_this._resetIsScrolling, IS_SCROLLING_DEBOUNCE_INTERVAL$1);\n      };\n\n      _this._resetIsScrolling = function () {\n        _this._resetIsScrollingTimeoutId = null;\n\n        _this.setState({\n          isScrolling: false\n        }, function () {\n          // Clear style cache after state update has been committed.\n          // This way we don't break pure sCU for items that don't use isScrolling param.\n          _this._getItemStyleCache(-1);\n        });\n      };\n\n      return _this;\n    }\n\n    Grid.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, prevState) {\n      validateSharedProps$1(nextProps, prevState);\n      validateProps(nextProps);\n      return null;\n    };\n\n    var _proto = Grid.prototype;\n\n    _proto.scrollTo = function scrollTo(_ref3) {\n      var scrollLeft = _ref3.scrollLeft,\n          scrollTop = _ref3.scrollTop;\n      this.setState(function (prevState) {\n        if (scrollLeft === undefined) {\n          scrollLeft = prevState.scrollLeft;\n        }\n\n        if (scrollTop === undefined) {\n          scrollTop = prevState.scrollTop;\n        }\n\n        return {\n          horizontalScrollDirection: prevState.scrollLeft < scrollLeft ? 'forward' : 'backward',\n          scrollLeft: scrollLeft,\n          scrollTop: scrollTop,\n          scrollUpdateWasRequested: true,\n          verticalScrollDirection: prevState.scrollTop < scrollTop ? 'forward' : 'backward'\n        };\n      }, this._resetIsScrollingDebounced);\n    };\n\n    _proto.scrollToItem = function scrollToItem(_ref4) {\n      var _ref4$align = _ref4.align,\n          align = _ref4$align === void 0 ? 'auto' : _ref4$align,\n          columnIndex = _ref4.columnIndex,\n          rowIndex = _ref4.rowIndex;\n      var _this$props2 = this.props,\n          height = _this$props2.height,\n          width = _this$props2.width;\n      var _this$state = this.state,\n          scrollLeft = _this$state.scrollLeft,\n          scrollTop = _this$state.scrollTop;\n      var scrollbarSize = getScrollbarSize();\n      var estimatedTotalHeight = getEstimatedTotalHeight(this.props, this._instanceProps);\n      var estimatedTotalWidth = getEstimatedTotalWidth(this.props, this._instanceProps); // The scrollbar size should be considered when scrolling an item into view,\n      // to ensure it's fully visible.\n      // But we only need to account for its size when it's actually visible.\n\n      var horizontalScrollbarSize = estimatedTotalWidth > width ? scrollbarSize : 0;\n      var verticalScrollbarSize = estimatedTotalHeight > height ? scrollbarSize : 0;\n      this.scrollTo({\n        scrollLeft: columnIndex !== undefined ? getOffsetForColumnAndAlignment(this.props, columnIndex, align, scrollLeft, this._instanceProps, verticalScrollbarSize) : scrollLeft,\n        scrollTop: rowIndex !== undefined ? getOffsetForRowAndAlignment(this.props, rowIndex, align, scrollTop, this._instanceProps, horizontalScrollbarSize) : scrollTop\n      });\n    };\n\n    _proto.componentDidMount = function componentDidMount() {\n      var _this$props3 = this.props,\n          initialScrollLeft = _this$props3.initialScrollLeft,\n          initialScrollTop = _this$props3.initialScrollTop;\n\n      if (typeof initialScrollLeft === 'number' && this._outerRef != null) {\n        this._outerRef.scrollLeft = initialScrollLeft;\n      }\n\n      if (typeof initialScrollTop === 'number' && this._outerRef != null) {\n        this._outerRef.scrollTop = initialScrollTop;\n      }\n\n      this._callPropsCallbacks();\n    };\n\n    _proto.componentDidUpdate = function componentDidUpdate() {\n      var _this$state2 = this.state,\n          scrollLeft = _this$state2.scrollLeft,\n          scrollTop = _this$state2.scrollTop,\n          scrollUpdateWasRequested = _this$state2.scrollUpdateWasRequested;\n\n      if (scrollUpdateWasRequested && this._outerRef !== null) {\n        this._outerRef.scrollLeft = scrollLeft;\n        this._outerRef.scrollTop = scrollTop;\n      }\n\n      this._callPropsCallbacks();\n    };\n\n    _proto.componentWillUnmount = function componentWillUnmount() {\n      if (this._resetIsScrollingTimeoutId !== null) {\n        cancelTimeout(this._resetIsScrollingTimeoutId);\n      }\n    };\n\n    _proto.render = function render() {\n      var _this$props4 = this.props,\n          children = _this$props4.children,\n          className = _this$props4.className,\n          columnCount = _this$props4.columnCount,\n          direction = _this$props4.direction,\n          height = _this$props4.height,\n          innerRef = _this$props4.innerRef,\n          innerElementType = _this$props4.innerElementType,\n          innerTagName = _this$props4.innerTagName,\n          itemData = _this$props4.itemData,\n          _this$props4$itemKey = _this$props4.itemKey,\n          itemKey = _this$props4$itemKey === void 0 ? defaultItemKey$1 : _this$props4$itemKey,\n          outerElementType = _this$props4.outerElementType,\n          outerTagName = _this$props4.outerTagName,\n          rowCount = _this$props4.rowCount,\n          style = _this$props4.style,\n          useIsScrolling = _this$props4.useIsScrolling,\n          width = _this$props4.width;\n      var isScrolling = this.state.isScrolling;\n\n      var _this$_getHorizontalR = this._getHorizontalRangeToRender(),\n          columnStartIndex = _this$_getHorizontalR[0],\n          columnStopIndex = _this$_getHorizontalR[1];\n\n      var _this$_getVerticalRan = this._getVerticalRangeToRender(),\n          rowStartIndex = _this$_getVerticalRan[0],\n          rowStopIndex = _this$_getVerticalRan[1];\n\n      var items = [];\n\n      if (columnCount > 0 && rowCount) {\n        for (var _rowIndex = rowStartIndex; _rowIndex <= rowStopIndex; _rowIndex++) {\n          for (var _columnIndex = columnStartIndex; _columnIndex <= columnStopIndex; _columnIndex++) {\n            items.push(createElement(children, {\n              columnIndex: _columnIndex,\n              data: itemData,\n              isScrolling: useIsScrolling ? isScrolling : undefined,\n              key: itemKey({\n                columnIndex: _columnIndex,\n                data: itemData,\n                rowIndex: _rowIndex\n              }),\n              rowIndex: _rowIndex,\n              style: this._getItemStyle(_rowIndex, _columnIndex)\n            }));\n          }\n        }\n      } // Read this value AFTER items have been created,\n      // So their actual sizes (if variable) are taken into consideration.\n\n\n      var estimatedTotalHeight = getEstimatedTotalHeight(this.props, this._instanceProps);\n      var estimatedTotalWidth = getEstimatedTotalWidth(this.props, this._instanceProps);\n      return createElement(outerElementType || outerTagName || 'div', {\n        className: className,\n        onScroll: this._onScroll,\n        ref: this._outerRefSetter,\n        style: _extends({\n          position: 'relative',\n          height: height,\n          width: width,\n          overflow: 'auto',\n          WebkitOverflowScrolling: 'touch',\n          willChange: 'transform',\n          direction: direction\n        }, style)\n      }, createElement(innerElementType || innerTagName || 'div', {\n        children: items,\n        ref: innerRef,\n        style: {\n          height: estimatedTotalHeight,\n          pointerEvents: isScrolling ? 'none' : '',\n          width: estimatedTotalWidth\n        }\n      }));\n    };\n\n    _proto._callPropsCallbacks = function _callPropsCallbacks() {\n      var _this$props5 = this.props,\n          columnCount = _this$props5.columnCount,\n          onItemsRendered = _this$props5.onItemsRendered,\n          onScroll = _this$props5.onScroll,\n          rowCount = _this$props5.rowCount;\n\n      if (typeof onItemsRendered === 'function') {\n        if (columnCount > 0 && rowCount > 0) {\n          var _this$_getHorizontalR2 = this._getHorizontalRangeToRender(),\n              _overscanColumnStartIndex = _this$_getHorizontalR2[0],\n              _overscanColumnStopIndex = _this$_getHorizontalR2[1],\n              _visibleColumnStartIndex = _this$_getHorizontalR2[2],\n              _visibleColumnStopIndex = _this$_getHorizontalR2[3];\n\n          var _this$_getVerticalRan2 = this._getVerticalRangeToRender(),\n              _overscanRowStartIndex = _this$_getVerticalRan2[0],\n              _overscanRowStopIndex = _this$_getVerticalRan2[1],\n              _visibleRowStartIndex = _this$_getVerticalRan2[2],\n              _visibleRowStopIndex = _this$_getVerticalRan2[3];\n\n          this._callOnItemsRendered(_overscanColumnStartIndex, _overscanColumnStopIndex, _overscanRowStartIndex, _overscanRowStopIndex, _visibleColumnStartIndex, _visibleColumnStopIndex, _visibleRowStartIndex, _visibleRowStopIndex);\n        }\n      }\n\n      if (typeof onScroll === 'function') {\n        var _this$state3 = this.state,\n            _horizontalScrollDirection = _this$state3.horizontalScrollDirection,\n            _scrollLeft = _this$state3.scrollLeft,\n            _scrollTop = _this$state3.scrollTop,\n            _scrollUpdateWasRequested = _this$state3.scrollUpdateWasRequested,\n            _verticalScrollDirection = _this$state3.verticalScrollDirection;\n\n        this._callOnScroll(_scrollLeft, _scrollTop, _horizontalScrollDirection, _verticalScrollDirection, _scrollUpdateWasRequested);\n      }\n    } // Lazily create and cache item styles while scrolling,\n    // So that pure component sCU will prevent re-renders.\n    // We maintain this cache, and pass a style prop rather than index,\n    // So that List can clear cached styles and force item re-render if necessary.\n    ;\n\n    _proto._getHorizontalRangeToRender = function _getHorizontalRangeToRender() {\n      var _this$props6 = this.props,\n          columnCount = _this$props6.columnCount,\n          overscanColumnsCount = _this$props6.overscanColumnsCount,\n          overscanCount = _this$props6.overscanCount,\n          rowCount = _this$props6.rowCount;\n      var _this$state4 = this.state,\n          horizontalScrollDirection = _this$state4.horizontalScrollDirection,\n          isScrolling = _this$state4.isScrolling,\n          scrollLeft = _this$state4.scrollLeft;\n      var overscanCountResolved = overscanColumnsCount || overscanCount || 1;\n\n      if (columnCount === 0 || rowCount === 0) {\n        return [0, 0, 0, 0];\n      }\n\n      var startIndex = getColumnStartIndexForOffset(this.props, scrollLeft, this._instanceProps);\n      var stopIndex = getColumnStopIndexForStartIndex(this.props, startIndex, scrollLeft, this._instanceProps); // Overscan by one item in each direction so that tab/focus works.\n      // If there isn't at least one extra item, tab loops back around.\n\n      var overscanBackward = !isScrolling || horizontalScrollDirection === 'backward' ? Math.max(1, overscanCountResolved) : 1;\n      var overscanForward = !isScrolling || horizontalScrollDirection === 'forward' ? Math.max(1, overscanCountResolved) : 1;\n      return [Math.max(0, startIndex - overscanBackward), Math.max(0, Math.min(columnCount - 1, stopIndex + overscanForward)), startIndex, stopIndex];\n    };\n\n    _proto._getVerticalRangeToRender = function _getVerticalRangeToRender() {\n      var _this$props7 = this.props,\n          columnCount = _this$props7.columnCount,\n          overscanCount = _this$props7.overscanCount,\n          overscanRowsCount = _this$props7.overscanRowsCount,\n          rowCount = _this$props7.rowCount;\n      var _this$state5 = this.state,\n          isScrolling = _this$state5.isScrolling,\n          verticalScrollDirection = _this$state5.verticalScrollDirection,\n          scrollTop = _this$state5.scrollTop;\n      var overscanCountResolved = overscanRowsCount || overscanCount || 1;\n\n      if (columnCount === 0 || rowCount === 0) {\n        return [0, 0, 0, 0];\n      }\n\n      var startIndex = getRowStartIndexForOffset(this.props, scrollTop, this._instanceProps);\n      var stopIndex = getRowStopIndexForStartIndex(this.props, startIndex, scrollTop, this._instanceProps); // Overscan by one item in each direction so that tab/focus works.\n      // If there isn't at least one extra item, tab loops back around.\n\n      var overscanBackward = !isScrolling || verticalScrollDirection === 'backward' ? Math.max(1, overscanCountResolved) : 1;\n      var overscanForward = !isScrolling || verticalScrollDirection === 'forward' ? Math.max(1, overscanCountResolved) : 1;\n      return [Math.max(0, startIndex - overscanBackward), Math.max(0, Math.min(rowCount - 1, stopIndex + overscanForward)), startIndex, stopIndex];\n    };\n\n    return Grid;\n  }(PureComponent), _class.defaultProps = {\n    direction: 'ltr',\n    itemData: undefined,\n    useIsScrolling: false\n  }, _temp;\n}\n\nvar validateSharedProps$1 = function validateSharedProps(_ref5, _ref6) {\n  var children = _ref5.children,\n      direction = _ref5.direction,\n      height = _ref5.height,\n      innerTagName = _ref5.innerTagName,\n      outerTagName = _ref5.outerTagName,\n      overscanCount = _ref5.overscanCount,\n      width = _ref5.width;\n  var instance = _ref6.instance;\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (typeof overscanCount === 'number') {\n      if (devWarningsOverscanCount && !devWarningsOverscanCount.has(instance)) {\n        devWarningsOverscanCount.add(instance);\n        console.warn('The overscanCount prop has been deprecated. ' + 'Please use the overscanColumnsCount and overscanRowsCount props instead.');\n      }\n    }\n\n    if (innerTagName != null || outerTagName != null) {\n      if (devWarningsTagName$1 && !devWarningsTagName$1.has(instance)) {\n        devWarningsTagName$1.add(instance);\n        console.warn('The innerTagName and outerTagName props have been deprecated. ' + 'Please use the innerElementType and outerElementType props instead.');\n      }\n    }\n\n    if (children == null) {\n      throw Error('An invalid \"children\" prop has been specified. ' + 'Value should be a React component. ' + (\"\\\"\" + (children === null ? 'null' : typeof children) + \"\\\" was specified.\"));\n    }\n\n    switch (direction) {\n      case 'ltr':\n      case 'rtl':\n        // Valid values\n        break;\n\n      default:\n        throw Error('An invalid \"direction\" prop has been specified. ' + 'Value should be either \"ltr\" or \"rtl\". ' + (\"\\\"\" + direction + \"\\\" was specified.\"));\n    }\n\n    if (typeof width !== 'number') {\n      throw Error('An invalid \"width\" prop has been specified. ' + 'Grids must specify a number for width. ' + (\"\\\"\" + (width === null ? 'null' : typeof width) + \"\\\" was specified.\"));\n    }\n\n    if (typeof height !== 'number') {\n      throw Error('An invalid \"height\" prop has been specified. ' + 'Grids must specify a number for height. ' + (\"\\\"\" + (height === null ? 'null' : typeof height) + \"\\\" was specified.\"));\n    }\n  }\n};\n\nvar FixedSizeGrid = /*#__PURE__*/createGridComponent({\n  getColumnOffset: function getColumnOffset(_ref, index) {\n    var columnWidth = _ref.columnWidth;\n    return index * columnWidth;\n  },\n  getColumnWidth: function getColumnWidth(_ref2, index) {\n    var columnWidth = _ref2.columnWidth;\n    return columnWidth;\n  },\n  getRowOffset: function getRowOffset(_ref3, index) {\n    var rowHeight = _ref3.rowHeight;\n    return index * rowHeight;\n  },\n  getRowHeight: function getRowHeight(_ref4, index) {\n    var rowHeight = _ref4.rowHeight;\n    return rowHeight;\n  },\n  getEstimatedTotalHeight: function getEstimatedTotalHeight(_ref5) {\n    var rowCount = _ref5.rowCount,\n        rowHeight = _ref5.rowHeight;\n    return rowHeight * rowCount;\n  },\n  getEstimatedTotalWidth: function getEstimatedTotalWidth(_ref6) {\n    var columnCount = _ref6.columnCount,\n        columnWidth = _ref6.columnWidth;\n    return columnWidth * columnCount;\n  },\n  getOffsetForColumnAndAlignment: function getOffsetForColumnAndAlignment(_ref7, columnIndex, align, scrollLeft, instanceProps, scrollbarSize) {\n    var columnCount = _ref7.columnCount,\n        columnWidth = _ref7.columnWidth,\n        width = _ref7.width;\n    var maxOffset = Math.max(0, Math.min(columnCount * columnWidth - width, columnIndex * columnWidth));\n    var minOffset = Math.max(0, columnIndex * columnWidth - width + scrollbarSize + columnWidth);\n\n    switch (align) {\n      case 'start':\n        return maxOffset;\n\n      case 'end':\n        return minOffset;\n\n      case 'center':\n        return Math.round(minOffset + (maxOffset - minOffset) / 2);\n\n      case 'auto':\n      default:\n        if (scrollLeft >= minOffset && scrollLeft <= maxOffset) {\n          return scrollLeft;\n        } else if (scrollLeft - minOffset < maxOffset - scrollLeft) {\n          return minOffset;\n        } else {\n          return maxOffset;\n        }\n\n    }\n  },\n  getOffsetForRowAndAlignment: function getOffsetForRowAndAlignment(_ref8, rowIndex, align, scrollTop, instanceProps, scrollbarSize) {\n    var rowHeight = _ref8.rowHeight,\n        height = _ref8.height,\n        rowCount = _ref8.rowCount;\n    var maxOffset = Math.max(0, Math.min(rowCount * rowHeight - height, rowIndex * rowHeight));\n    var minOffset = Math.max(0, rowIndex * rowHeight - height + scrollbarSize + rowHeight);\n\n    switch (align) {\n      case 'start':\n        return maxOffset;\n\n      case 'end':\n        return minOffset;\n\n      case 'center':\n        return Math.round(minOffset + (maxOffset - minOffset) / 2);\n\n      case 'auto':\n      default:\n        if (scrollTop >= minOffset && scrollTop <= maxOffset) {\n          return scrollTop;\n        } else if (scrollTop - minOffset < maxOffset - scrollTop) {\n          return minOffset;\n        } else {\n          return maxOffset;\n        }\n\n    }\n  },\n  getColumnStartIndexForOffset: function getColumnStartIndexForOffset(_ref9, scrollLeft) {\n    var columnWidth = _ref9.columnWidth,\n        columnCount = _ref9.columnCount;\n    return Math.max(0, Math.min(columnCount - 1, Math.floor(scrollLeft / columnWidth)));\n  },\n  getColumnStopIndexForStartIndex: function getColumnStopIndexForStartIndex(_ref10, startIndex, scrollLeft) {\n    var columnWidth = _ref10.columnWidth,\n        columnCount = _ref10.columnCount,\n        width = _ref10.width;\n    var left = startIndex * columnWidth;\n    return Math.max(0, Math.min(columnCount - 1, startIndex + Math.floor((width + (scrollLeft - left)) / columnWidth)));\n  },\n  getRowStartIndexForOffset: function getRowStartIndexForOffset(_ref11, scrollTop) {\n    var rowHeight = _ref11.rowHeight,\n        rowCount = _ref11.rowCount;\n    return Math.max(0, Math.min(rowCount - 1, Math.floor(scrollTop / rowHeight)));\n  },\n  getRowStopIndexForStartIndex: function getRowStopIndexForStartIndex(_ref12, startIndex, scrollTop) {\n    var rowHeight = _ref12.rowHeight,\n        rowCount = _ref12.rowCount,\n        height = _ref12.height;\n    var left = startIndex * rowHeight;\n    return Math.max(0, Math.min(rowCount - 1, startIndex + Math.floor((height + (scrollTop - left)) / rowHeight)));\n  },\n  initInstanceProps: function initInstanceProps(props) {// Noop\n  },\n  shouldResetStyleCacheOnItemSizeChange: true,\n  validateProps: function validateProps(_ref13) {\n    var columnWidth = _ref13.columnWidth,\n        rowHeight = _ref13.rowHeight;\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (typeof columnWidth !== 'number') {\n        throw Error('An invalid \"columnWidth\" prop has been specified. ' + 'Value should be a number. ' + (\"\\\"\" + (columnWidth === null ? 'null' : typeof columnWidth) + \"\\\" was specified.\"));\n      }\n\n      if (typeof rowHeight !== 'number') {\n        throw Error('An invalid \"rowHeight\" prop has been specified. ' + 'Value should be a number. ' + (\"\\\"\" + (rowHeight === null ? 'null' : typeof rowHeight) + \"\\\" was specified.\"));\n      }\n    }\n  }\n});\n\nvar FixedSizeList = /*#__PURE__*/createListComponent({\n  getItemOffset: function getItemOffset(_ref, index) {\n    var itemSize = _ref.itemSize,\n        size = _ref.size;\n    return index * itemSize;\n  },\n  getItemSize: function getItemSize(_ref2, index) {\n    var itemSize = _ref2.itemSize,\n        size = _ref2.size;\n    return itemSize;\n  },\n  getEstimatedTotalSize: function getEstimatedTotalSize(_ref3) {\n    var itemCount = _ref3.itemCount,\n        itemSize = _ref3.itemSize;\n    return itemSize * itemCount;\n  },\n  getOffsetForIndexAndAlignment: function getOffsetForIndexAndAlignment(_ref4, index, align, scrollOffset) {\n    var direction = _ref4.direction,\n        height = _ref4.height,\n        itemCount = _ref4.itemCount,\n        itemSize = _ref4.itemSize,\n        layout = _ref4.layout,\n        width = _ref4.width;\n    // TODO Deprecate direction \"horizontal\"\n    var isHorizontal = direction === 'horizontal' || layout === 'horizontal';\n    var size = isHorizontal ? width : height;\n    var maxOffset = Math.max(0, Math.min(itemCount * itemSize - size, index * itemSize));\n    var minOffset = Math.max(0, index * itemSize - size + itemSize);\n\n    switch (align) {\n      case 'start':\n        return maxOffset;\n\n      case 'end':\n        return minOffset;\n\n      case 'center':\n        return Math.round(minOffset + (maxOffset - minOffset) / 2);\n\n      case 'auto':\n      default:\n        if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {\n          return scrollOffset;\n        } else if (scrollOffset - minOffset < maxOffset - scrollOffset) {\n          return minOffset;\n        } else {\n          return maxOffset;\n        }\n\n    }\n  },\n  getStartIndexForOffset: function getStartIndexForOffset(_ref5, offset) {\n    var itemCount = _ref5.itemCount,\n        itemSize = _ref5.itemSize;\n    return Math.max(0, Math.min(itemCount - 1, Math.floor(offset / itemSize)));\n  },\n  getStopIndexForStartIndex: function getStopIndexForStartIndex(_ref6, startIndex, scrollOffset) {\n    var direction = _ref6.direction,\n        height = _ref6.height,\n        itemCount = _ref6.itemCount,\n        itemSize = _ref6.itemSize,\n        layout = _ref6.layout,\n        width = _ref6.width;\n    // TODO Deprecate direction \"horizontal\"\n    var isHorizontal = direction === 'horizontal' || layout === 'horizontal';\n    var offset = startIndex * itemSize;\n    var size = isHorizontal ? width : height;\n    return Math.max(0, Math.min(itemCount - 1, startIndex + Math.floor((size + (scrollOffset - offset)) / itemSize)));\n  },\n  initInstanceProps: function initInstanceProps(props) {// Noop\n  },\n  shouldResetStyleCacheOnItemSizeChange: true,\n  validateProps: function validateProps(_ref7) {\n    var itemSize = _ref7.itemSize;\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (typeof itemSize !== 'number') {\n        throw Error('An invalid \"itemSize\" prop has been specified. ' + 'Value should be a number. ' + (\"\\\"\" + (itemSize === null ? 'null' : typeof itemSize) + \"\\\" was specified.\"));\n      }\n    }\n  }\n});\n\nvar DEFAULT_ESTIMATED_ITEM_SIZE$1 = 50;\n\nvar getEstimatedTotalHeight = function getEstimatedTotalHeight(_ref, _ref2) {\n  var rowCount = _ref.rowCount;\n  var rowMetadataMap = _ref2.rowMetadataMap,\n      estimatedRowHeight = _ref2.estimatedRowHeight,\n      lastMeasuredRowIndex = _ref2.lastMeasuredRowIndex;\n  var totalSizeOfMeasuredRows = 0; // Edge case check for when the number of items decreases while a scroll is in progress.\n  // https://github.com/bvaughn/react-window/pull/138\n\n  if (lastMeasuredRowIndex >= rowCount) {\n    lastMeasuredRowIndex = rowCount - 1;\n  }\n\n  if (lastMeasuredRowIndex >= 0) {\n    var itemMetadata = rowMetadataMap[lastMeasuredRowIndex];\n    totalSizeOfMeasuredRows = itemMetadata.offset + itemMetadata.size;\n  }\n\n  var numUnmeasuredItems = rowCount - lastMeasuredRowIndex - 1;\n  var totalSizeOfUnmeasuredItems = numUnmeasuredItems * estimatedRowHeight;\n  return totalSizeOfMeasuredRows + totalSizeOfUnmeasuredItems;\n};\n\nvar getEstimatedTotalWidth = function getEstimatedTotalWidth(_ref3, _ref4) {\n  var columnCount = _ref3.columnCount;\n  var columnMetadataMap = _ref4.columnMetadataMap,\n      estimatedColumnWidth = _ref4.estimatedColumnWidth,\n      lastMeasuredColumnIndex = _ref4.lastMeasuredColumnIndex;\n  var totalSizeOfMeasuredRows = 0; // Edge case check for when the number of items decreases while a scroll is in progress.\n  // https://github.com/bvaughn/react-window/pull/138\n\n  if (lastMeasuredColumnIndex >= columnCount) {\n    lastMeasuredColumnIndex = columnCount - 1;\n  }\n\n  if (lastMeasuredColumnIndex >= 0) {\n    var itemMetadata = columnMetadataMap[lastMeasuredColumnIndex];\n    totalSizeOfMeasuredRows = itemMetadata.offset + itemMetadata.size;\n  }\n\n  var numUnmeasuredItems = columnCount - lastMeasuredColumnIndex - 1;\n  var totalSizeOfUnmeasuredItems = numUnmeasuredItems * estimatedColumnWidth;\n  return totalSizeOfMeasuredRows + totalSizeOfUnmeasuredItems;\n};\n\nvar getItemMetadata$1 = function getItemMetadata(itemType, props, index, instanceProps) {\n  var itemMetadataMap, itemSize, lastMeasuredIndex;\n\n  if (itemType === 'column') {\n    itemMetadataMap = instanceProps.columnMetadataMap;\n    itemSize = props.columnWidth;\n    lastMeasuredIndex = instanceProps.lastMeasuredColumnIndex;\n  } else {\n    itemMetadataMap = instanceProps.rowMetadataMap;\n    itemSize = props.rowHeight;\n    lastMeasuredIndex = instanceProps.lastMeasuredRowIndex;\n  }\n\n  if (index > lastMeasuredIndex) {\n    var offset = 0;\n\n    if (lastMeasuredIndex >= 0) {\n      var itemMetadata = itemMetadataMap[lastMeasuredIndex];\n      offset = itemMetadata.offset + itemMetadata.size;\n    }\n\n    for (var i = lastMeasuredIndex + 1; i <= index; i++) {\n      var size = itemSize(i);\n      itemMetadataMap[i] = {\n        offset: offset,\n        size: size\n      };\n      offset += size;\n    }\n\n    if (itemType === 'column') {\n      instanceProps.lastMeasuredColumnIndex = index;\n    } else {\n      instanceProps.lastMeasuredRowIndex = index;\n    }\n  }\n\n  return itemMetadataMap[index];\n};\n\nvar findNearestItem = function findNearestItem(itemType, props, instanceProps, offset) {\n  var itemMetadataMap, lastMeasuredIndex;\n\n  if (itemType === 'column') {\n    itemMetadataMap = instanceProps.columnMetadataMap;\n    lastMeasuredIndex = instanceProps.lastMeasuredColumnIndex;\n  } else {\n    itemMetadataMap = instanceProps.rowMetadataMap;\n    lastMeasuredIndex = instanceProps.lastMeasuredRowIndex;\n  }\n\n  var lastMeasuredItemOffset = lastMeasuredIndex > 0 ? itemMetadataMap[lastMeasuredIndex].offset : 0;\n\n  if (lastMeasuredItemOffset >= offset) {\n    // If we've already measured items within this range just use a binary search as it's faster.\n    return findNearestItemBinarySearch$1(itemType, props, instanceProps, lastMeasuredIndex, 0, offset);\n  } else {\n    // If we haven't yet measured this high, fallback to an exponential search with an inner binary search.\n    // The exponential search avoids pre-computing sizes for the full set of items as a binary search would.\n    // The overall complexity for this approach is O(log n).\n    return findNearestItemExponentialSearch(itemType, props, instanceProps, Math.max(0, lastMeasuredIndex), offset);\n  }\n};\n\nvar findNearestItemBinarySearch$1 = function findNearestItemBinarySearch(itemType, props, instanceProps, high, low, offset) {\n  while (low <= high) {\n    var middle = low + Math.floor((high - low) / 2);\n    var currentOffset = getItemMetadata$1(itemType, props, middle, instanceProps).offset;\n\n    if (currentOffset === offset) {\n      return middle;\n    } else if (currentOffset < offset) {\n      low = middle + 1;\n    } else if (currentOffset > offset) {\n      high = middle - 1;\n    }\n  }\n\n  if (low > 0) {\n    return low - 1;\n  } else {\n    return 0;\n  }\n};\n\nvar findNearestItemExponentialSearch = function findNearestItemExponentialSearch(itemType, props, instanceProps, index, offset) {\n  var itemCount = itemType === 'column' ? props.columnCount : props.rowCount;\n  var interval = 1;\n\n  while (index < itemCount && getItemMetadata$1(itemType, props, index, instanceProps).offset < offset) {\n    index += interval;\n    interval *= 2;\n  }\n\n  return findNearestItemBinarySearch$1(itemType, props, instanceProps, Math.min(index, itemCount - 1), Math.floor(index / 2), offset);\n};\n\nvar getOffsetForIndexAndAlignment = function getOffsetForIndexAndAlignment(itemType, props, index, align, scrollOffset, instanceProps, scrollbarSize) {\n  var size = itemType === 'column' ? props.width : props.height;\n  var itemMetadata = getItemMetadata$1(itemType, props, index, instanceProps); // Get estimated total size after ItemMetadata is computed,\n  // To ensure it reflects actual measurements instead of just estimates.\n\n  var estimatedTotalSize = itemType === 'column' ? getEstimatedTotalWidth(props, instanceProps) : getEstimatedTotalHeight(props, instanceProps);\n  var maxOffset = Math.max(0, Math.min(estimatedTotalSize - size, itemMetadata.offset));\n  var minOffset = Math.max(0, itemMetadata.offset - size + scrollbarSize + itemMetadata.size);\n\n  switch (align) {\n    case 'start':\n      return maxOffset;\n\n    case 'end':\n      return minOffset;\n\n    case 'center':\n      return Math.round(minOffset + (maxOffset - minOffset) / 2);\n\n    case 'auto':\n    default:\n      if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {\n        return scrollOffset;\n      } else if (scrollOffset - minOffset < maxOffset - scrollOffset) {\n        return minOffset;\n      } else {\n        return maxOffset;\n      }\n\n  }\n};\n\nvar VariableSizeGrid = /*#__PURE__*/createGridComponent({\n  getColumnOffset: function getColumnOffset(props, index, instanceProps) {\n    return getItemMetadata$1('column', props, index, instanceProps).offset;\n  },\n  getColumnStartIndexForOffset: function getColumnStartIndexForOffset(props, scrollLeft, instanceProps) {\n    return findNearestItem('column', props, instanceProps, scrollLeft);\n  },\n  getColumnStopIndexForStartIndex: function getColumnStopIndexForStartIndex(props, startIndex, scrollLeft, instanceProps) {\n    var columnCount = props.columnCount,\n        width = props.width;\n    var itemMetadata = getItemMetadata$1('column', props, startIndex, instanceProps);\n    var maxOffset = scrollLeft + width;\n    var offset = itemMetadata.offset + itemMetadata.size;\n    var stopIndex = startIndex;\n\n    while (stopIndex < columnCount - 1 && offset < maxOffset) {\n      stopIndex++;\n      offset += getItemMetadata$1('column', props, stopIndex, instanceProps).size;\n    }\n\n    return stopIndex;\n  },\n  getColumnWidth: function getColumnWidth(props, index, instanceProps) {\n    return instanceProps.columnMetadataMap[index].size;\n  },\n  getEstimatedTotalHeight: getEstimatedTotalHeight,\n  getEstimatedTotalWidth: getEstimatedTotalWidth,\n  getOffsetForColumnAndAlignment: function getOffsetForColumnAndAlignment(props, index, align, scrollOffset, instanceProps, scrollbarSize) {\n    return getOffsetForIndexAndAlignment('column', props, index, align, scrollOffset, instanceProps, scrollbarSize);\n  },\n  getOffsetForRowAndAlignment: function getOffsetForRowAndAlignment(props, index, align, scrollOffset, instanceProps, scrollbarSize) {\n    return getOffsetForIndexAndAlignment('row', props, index, align, scrollOffset, instanceProps, scrollbarSize);\n  },\n  getRowOffset: function getRowOffset(props, index, instanceProps) {\n    return getItemMetadata$1('row', props, index, instanceProps).offset;\n  },\n  getRowHeight: function getRowHeight(props, index, instanceProps) {\n    return instanceProps.rowMetadataMap[index].size;\n  },\n  getRowStartIndexForOffset: function getRowStartIndexForOffset(props, scrollTop, instanceProps) {\n    return findNearestItem('row', props, instanceProps, scrollTop);\n  },\n  getRowStopIndexForStartIndex: function getRowStopIndexForStartIndex(props, startIndex, scrollTop, instanceProps) {\n    var rowCount = props.rowCount,\n        height = props.height;\n    var itemMetadata = getItemMetadata$1('row', props, startIndex, instanceProps);\n    var maxOffset = scrollTop + height;\n    var offset = itemMetadata.offset + itemMetadata.size;\n    var stopIndex = startIndex;\n\n    while (stopIndex < rowCount - 1 && offset < maxOffset) {\n      stopIndex++;\n      offset += getItemMetadata$1('row', props, stopIndex, instanceProps).size;\n    }\n\n    return stopIndex;\n  },\n  initInstanceProps: function initInstanceProps(props, instance) {\n    var _ref5 = props,\n        estimatedColumnWidth = _ref5.estimatedColumnWidth,\n        estimatedRowHeight = _ref5.estimatedRowHeight;\n    var instanceProps = {\n      columnMetadataMap: {},\n      estimatedColumnWidth: estimatedColumnWidth || DEFAULT_ESTIMATED_ITEM_SIZE$1,\n      estimatedRowHeight: estimatedRowHeight || DEFAULT_ESTIMATED_ITEM_SIZE$1,\n      lastMeasuredColumnIndex: -1,\n      lastMeasuredRowIndex: -1,\n      rowMetadataMap: {}\n    };\n\n    instance.resetAfterColumnIndex = function (columnIndex, shouldForceUpdate) {\n      if (shouldForceUpdate === void 0) {\n        shouldForceUpdate = true;\n      }\n\n      instance.resetAfterIndices({\n        columnIndex: columnIndex,\n        shouldForceUpdate: shouldForceUpdate\n      });\n    };\n\n    instance.resetAfterRowIndex = function (rowIndex, shouldForceUpdate) {\n      if (shouldForceUpdate === void 0) {\n        shouldForceUpdate = true;\n      }\n\n      instance.resetAfterIndices({\n        rowIndex: rowIndex,\n        shouldForceUpdate: shouldForceUpdate\n      });\n    };\n\n    instance.resetAfterIndices = function (_ref6) {\n      var columnIndex = _ref6.columnIndex,\n          rowIndex = _ref6.rowIndex,\n          _ref6$shouldForceUpda = _ref6.shouldForceUpdate,\n          shouldForceUpdate = _ref6$shouldForceUpda === void 0 ? true : _ref6$shouldForceUpda;\n\n      if (typeof columnIndex === 'number') {\n        instanceProps.lastMeasuredColumnIndex = Math.min(instanceProps.lastMeasuredColumnIndex, columnIndex - 1);\n      }\n\n      if (typeof rowIndex === 'number') {\n        instanceProps.lastMeasuredRowIndex = Math.min(instanceProps.lastMeasuredRowIndex, rowIndex - 1);\n      } // We could potentially optimize further by only evicting styles after this index,\n      // But since styles are only cached while scrolling is in progress-\n      // It seems an unnecessary optimization.\n      // It's unlikely that resetAfterIndex() will be called while a user is scrolling.\n\n\n      instance._getItemStyleCache(-1);\n\n      if (shouldForceUpdate) {\n        instance.forceUpdate();\n      }\n    };\n\n    return instanceProps;\n  },\n  shouldResetStyleCacheOnItemSizeChange: false,\n  validateProps: function validateProps(_ref7) {\n    var columnWidth = _ref7.columnWidth,\n        rowHeight = _ref7.rowHeight;\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (typeof columnWidth !== 'function') {\n        throw Error('An invalid \"columnWidth\" prop has been specified. ' + 'Value should be a function. ' + (\"\\\"\" + (columnWidth === null ? 'null' : typeof columnWidth) + \"\\\" was specified.\"));\n      } else if (typeof rowHeight !== 'function') {\n        throw Error('An invalid \"rowHeight\" prop has been specified. ' + 'Value should be a function. ' + (\"\\\"\" + (rowHeight === null ? 'null' : typeof rowHeight) + \"\\\" was specified.\"));\n      }\n    }\n  }\n});\n\nvar DEFAULT_ESTIMATED_ITEM_SIZE$2 = 50;\n\nvar getItemMetadata$2 = function getItemMetadata(props, index, instanceProps) {\n  var _ref = props,\n      itemSize = _ref.itemSize;\n  var itemMetadataMap = instanceProps.itemMetadataMap,\n      lastMeasuredIndex = instanceProps.lastMeasuredIndex;\n\n  if (index > lastMeasuredIndex) {\n    var offset = 0;\n\n    if (lastMeasuredIndex >= 0) {\n      var itemMetadata = itemMetadataMap[lastMeasuredIndex];\n      offset = itemMetadata.offset + itemMetadata.size;\n    }\n\n    for (var i = lastMeasuredIndex + 1; i <= index; i++) {\n      var size = itemSize(i);\n      itemMetadataMap[i] = {\n        offset: offset,\n        size: size\n      };\n      offset += size;\n    }\n\n    instanceProps.lastMeasuredIndex = index;\n  }\n\n  return itemMetadataMap[index];\n};\n\nvar findNearestItem$1 = function findNearestItem(props, instanceProps, offset) {\n  var itemMetadataMap = instanceProps.itemMetadataMap,\n      lastMeasuredIndex = instanceProps.lastMeasuredIndex;\n  var lastMeasuredItemOffset = lastMeasuredIndex > 0 ? itemMetadataMap[lastMeasuredIndex].offset : 0;\n\n  if (lastMeasuredItemOffset >= offset) {\n    // If we've already measured items within this range just use a binary search as it's faster.\n    return findNearestItemBinarySearch$2(props, instanceProps, lastMeasuredIndex, 0, offset);\n  } else {\n    // If we haven't yet measured this high, fallback to an exponential search with an inner binary search.\n    // The exponential search avoids pre-computing sizes for the full set of items as a binary search would.\n    // The overall complexity for this approach is O(log n).\n    return findNearestItemExponentialSearch$1(props, instanceProps, Math.max(0, lastMeasuredIndex), offset);\n  }\n};\n\nvar findNearestItemBinarySearch$2 = function findNearestItemBinarySearch(props, instanceProps, high, low, offset) {\n  while (low <= high) {\n    var middle = low + Math.floor((high - low) / 2);\n    var currentOffset = getItemMetadata$2(props, middle, instanceProps).offset;\n\n    if (currentOffset === offset) {\n      return middle;\n    } else if (currentOffset < offset) {\n      low = middle + 1;\n    } else if (currentOffset > offset) {\n      high = middle - 1;\n    }\n  }\n\n  if (low > 0) {\n    return low - 1;\n  } else {\n    return 0;\n  }\n};\n\nvar findNearestItemExponentialSearch$1 = function findNearestItemExponentialSearch(props, instanceProps, index, offset) {\n  var itemCount = props.itemCount;\n  var interval = 1;\n\n  while (index < itemCount && getItemMetadata$2(props, index, instanceProps).offset < offset) {\n    index += interval;\n    interval *= 2;\n  }\n\n  return findNearestItemBinarySearch$2(props, instanceProps, Math.min(index, itemCount - 1), Math.floor(index / 2), offset);\n};\n\nvar getEstimatedTotalSize$1 = function getEstimatedTotalSize(_ref2, _ref3) {\n  var itemCount = _ref2.itemCount;\n  var itemMetadataMap = _ref3.itemMetadataMap,\n      estimatedItemSize = _ref3.estimatedItemSize,\n      lastMeasuredIndex = _ref3.lastMeasuredIndex;\n  var totalSizeOfMeasuredItems = 0; // Edge case check for when the number of items decreases while a scroll is in progress.\n  // https://github.com/bvaughn/react-window/pull/138\n\n  if (lastMeasuredIndex >= itemCount) {\n    lastMeasuredIndex = itemCount - 1;\n  }\n\n  if (lastMeasuredIndex >= 0) {\n    var itemMetadata = itemMetadataMap[lastMeasuredIndex];\n    totalSizeOfMeasuredItems = itemMetadata.offset + itemMetadata.size;\n  }\n\n  var numUnmeasuredItems = itemCount - lastMeasuredIndex - 1;\n  var totalSizeOfUnmeasuredItems = numUnmeasuredItems * estimatedItemSize;\n  return totalSizeOfMeasuredItems + totalSizeOfUnmeasuredItems;\n};\n\nvar VariableSizeList = /*#__PURE__*/createListComponent({\n  getItemOffset: function getItemOffset(props, index, instanceProps) {\n    return getItemMetadata$2(props, index, instanceProps).offset;\n  },\n  getItemSize: function getItemSize(props, index, instanceProps) {\n    return instanceProps.itemMetadataMap[index].size;\n  },\n  getEstimatedTotalSize: getEstimatedTotalSize$1,\n  getOffsetForIndexAndAlignment: function getOffsetForIndexAndAlignment(props, index, align, scrollOffset, instanceProps) {\n    var direction = props.direction,\n        height = props.height,\n        layout = props.layout,\n        width = props.width; // TODO Deprecate direction \"horizontal\"\n\n    var isHorizontal = direction === 'horizontal' || layout === 'horizontal';\n    var size = isHorizontal ? width : height;\n    var itemMetadata = getItemMetadata$2(props, index, instanceProps); // Get estimated total size after ItemMetadata is computed,\n    // To ensure it reflects actual measurements instead of just estimates.\n\n    var estimatedTotalSize = getEstimatedTotalSize$1(props, instanceProps);\n    var maxOffset = Math.max(0, Math.min(estimatedTotalSize - size, itemMetadata.offset));\n    var minOffset = Math.max(0, itemMetadata.offset - size + itemMetadata.size);\n\n    switch (align) {\n      case 'start':\n        return maxOffset;\n\n      case 'end':\n        return minOffset;\n\n      case 'center':\n        return Math.round(minOffset + (maxOffset - minOffset) / 2);\n\n      case 'auto':\n      default:\n        if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {\n          return scrollOffset;\n        } else if (scrollOffset - minOffset < maxOffset - scrollOffset) {\n          return minOffset;\n        } else {\n          return maxOffset;\n        }\n\n    }\n  },\n  getStartIndexForOffset: function getStartIndexForOffset(props, offset, instanceProps) {\n    return findNearestItem$1(props, instanceProps, offset);\n  },\n  getStopIndexForStartIndex: function getStopIndexForStartIndex(props, startIndex, scrollOffset, instanceProps) {\n    var direction = props.direction,\n        height = props.height,\n        itemCount = props.itemCount,\n        layout = props.layout,\n        width = props.width; // TODO Deprecate direction \"horizontal\"\n\n    var isHorizontal = direction === 'horizontal' || layout === 'horizontal';\n    var size = isHorizontal ? width : height;\n    var itemMetadata = getItemMetadata$2(props, startIndex, instanceProps);\n    var maxOffset = scrollOffset + size;\n    var offset = itemMetadata.offset + itemMetadata.size;\n    var stopIndex = startIndex;\n\n    while (stopIndex < itemCount - 1 && offset < maxOffset) {\n      stopIndex++;\n      offset += getItemMetadata$2(props, stopIndex, instanceProps).size;\n    }\n\n    return stopIndex;\n  },\n  initInstanceProps: function initInstanceProps(props, instance) {\n    var _ref4 = props,\n        estimatedItemSize = _ref4.estimatedItemSize;\n    var instanceProps = {\n      itemMetadataMap: {},\n      estimatedItemSize: estimatedItemSize || DEFAULT_ESTIMATED_ITEM_SIZE$2,\n      lastMeasuredIndex: -1\n    };\n\n    instance.resetAfterIndex = function (index, shouldForceUpdate) {\n      if (shouldForceUpdate === void 0) {\n        shouldForceUpdate = true;\n      }\n\n      instanceProps.lastMeasuredIndex = Math.min(instanceProps.lastMeasuredIndex, index - 1); // We could potentially optimize further by only evicting styles after this index,\n      // But since styles are only cached while scrolling is in progress-\n      // It seems an unnecessary optimization.\n      // It's unlikely that resetAfterIndex() will be called while a user is scrolling.\n\n      instance._getItemStyleCache(-1);\n\n      if (shouldForceUpdate) {\n        instance.forceUpdate();\n      }\n    };\n\n    return instanceProps;\n  },\n  shouldResetStyleCacheOnItemSizeChange: false,\n  validateProps: function validateProps(_ref5) {\n    var itemSize = _ref5.itemSize;\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (typeof itemSize !== 'function') {\n        throw Error('An invalid \"itemSize\" prop has been specified. ' + 'Value should be a function. ' + (\"\\\"\" + (itemSize === null ? 'null' : typeof itemSize) + \"\\\" was specified.\"));\n      }\n    }\n  }\n});\n\n// Pulled from react-compat\n// https://github.com/developit/preact-compat/blob/7c5de00e7c85e2ffd011bf3af02899b63f699d3a/src/index.js#L349\nfunction shallowDiffers(prev, next) {\n  for (var attribute in prev) {\n    if (!(attribute in next)) {\n      return true;\n    }\n  }\n\n  for (var _attribute in next) {\n    if (prev[_attribute] !== next[_attribute]) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\n// It knows to compare individual style props and ignore the wrapper object.\n// See https://reactjs.org/docs/react-api.html#reactmemo\n\nfunction areEqual(prevProps, nextProps) {\n  var prevStyle = prevProps.style,\n      prevRest = _objectWithoutPropertiesLoose(prevProps, [\"style\"]);\n\n  var nextStyle = nextProps.style,\n      nextRest = _objectWithoutPropertiesLoose(nextProps, [\"style\"]);\n\n  return !shallowDiffers(prevStyle, nextStyle) && !shallowDiffers(prevRest, nextRest);\n}\n\n// It knows to compare individual style props and ignore the wrapper object.\n// See https://reactjs.org/docs/react-component.html#shouldcomponentupdate\n\nfunction shouldComponentUpdate(nextProps, nextState) {\n  return !areEqual(this.props, nextProps) || shallowDiffers(this.state, nextState);\n}\n\nexport { DynamicSizeList, FixedSizeGrid, FixedSizeList, VariableSizeGrid, VariableSizeList, areEqual, shouldComponentUpdate };\n"]},"metadata":{},"sourceType":"module"}