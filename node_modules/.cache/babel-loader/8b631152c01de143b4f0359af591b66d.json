{"ast":null,"code":"import Dexie from \"dexie\";\nimport \"dexie-observable\";\nimport { promised } from \"q\";\nimport { promises } from \"fs\"; // Define your database\n\nexport const db = new Dexie(\"Song_Database\"); // create new databse\n// our schema is of storing a song\n\ndb.version(1).stores({\n  songs: \"&videoId, timestamp, playbackTimes, [rating+timestamp], [downloadState+timestamp]\"\n});\ndb.version(2).stores({}); // add or update song on play\n\nexport const updatePlayingSong = async data => {\n  const videoObj = {\n    videoId: data.id,\n    timestamp: Date.now(),\n    title: data.title,\n    channelTitle: data.channelTitle,\n    playbackTimes: 1\n  };\n  const song = await db.songs.get({\n    videoId: data.id\n  }); // if song exists we will just update the timestamp and the playback\n\n  if (song) {\n    db.songs.update(data.id, {\n      timestamp: Date.now(),\n      playbackTimes: song.playbackTimes + 1\n    });\n    console.log(\"song updated\");\n    return song.rating; // return the rating\n  } else {\n    // we will add a new song\n    console.log(\"song added\");\n    db.songs.add(videoObj);\n  }\n}; // like or dislike a song on database\n\nexport const rateSong = async (id, rating) => {\n  // if user likes the song then only download it\n  db.songs.update(id, {\n    rating: rating\n  });\n};\nexport const getHistory = async () => {\n  const songsByTimeStamp = await db.songs.orderBy(\"timestamp\").limit(500).reverse().toArray();\n  return songsByTimeStamp;\n};\nexport const getLikedSongs = async () => {\n  const likedSongs = await db.songs.where(\"[rating+timestamp]\") //this will filter song based on time and liked\n  .between([\"liked\", Dexie.minKey], [\"liked\", Dexie.maxKey]).reverse().toArray();\n  return likedSongs;\n};\nexport const getDownloadedSongs = async () => {\n  const downloadedSongs = await db.songs.where(\"[downloadState+timestamp]\") //this will filter song based on time and downloaded\n  .between([\"downloaded\", Dexie.minKey], [\"downloaded\", Dexie.maxKey]).reverse().toArray();\n  return downloadedSongs;\n};\nexport const removeDownloadingState = async () => {\n  // find all the downloadState which is downloading and remove that\n  const songs = await db.songs.where(\"[downloadState+timestamp]\").between([\"downloading\", Dexie.minKey], [\"downloading\", Dexie.maxKey]).modify(x => {\n    delete x.downloadState;\n  });\n  console.log(songs);\n};\nexport const downloadSong = async (id, url) => {\n  try {\n    db.songs.update(id, {\n      downloadState: \"downloading\"\n    });\n    const thumbURL = `https://i.ytimg.com/vi/${id}/hqdefault.jpg`;\n    const [thumbnailBlob, songBlob] = await Promise.all([fetchProxiedBlob(thumbURL), fetchProxiedBlob(url)]);\n    db.songs.update(id, {\n      downloadState: \"downloaded\",\n      thumbnail: thumbnailBlob,\n      audio: songBlob\n    });\n    return \"downloaded\";\n  } catch (error) {\n    return error;\n  }\n};\nexport const deleteSongAudio = async id => {\n  await db.songs.where({\n    videoId: id\n  }).modify(x => {\n    delete x.audio;\n    delete x.downloadState;\n  });\n  return \"song deleted\";\n};\n\nfunction fetchProxiedBlob(url) {\n  const URL = url;\n  return new Promise(function (resolve, reject) {\n    var xhr = new XMLHttpRequest();\n    xhr.open(\"GET\", \"http://localhost:9150/proxy/\" + URL);\n    xhr.responseType = \"blob\";\n\n    xhr.onload = function () {\n      var status = xhr.status;\n\n      if (status >= 200 && status < 300) {\n        resolve(xhr.response);\n      } else {\n        reject({\n          status: status,\n          statusText: xhr.statusText\n        });\n      }\n    };\n\n    xhr.send();\n    setTimeout(() => {\n      xhr.abort();\n      xhr.open(\"GET\", \"http://localhost:9150/proxy/\" + URL);\n      xhr.send();\n    }, 1000);\n  });\n}","map":{"version":3,"sources":["C:/myProJects/Server/weatherapp/src/external/saveSong.js"],"names":["Dexie","promised","promises","db","version","stores","songs","updatePlayingSong","data","videoObj","videoId","id","timestamp","Date","now","title","channelTitle","playbackTimes","song","get","update","console","log","rating","add","rateSong","getHistory","songsByTimeStamp","orderBy","limit","reverse","toArray","getLikedSongs","likedSongs","where","between","minKey","maxKey","getDownloadedSongs","downloadedSongs","removeDownloadingState","modify","x","downloadState","downloadSong","url","thumbURL","thumbnailBlob","songBlob","Promise","all","fetchProxiedBlob","thumbnail","audio","error","deleteSongAudio","URL","resolve","reject","xhr","XMLHttpRequest","open","responseType","onload","status","response","statusText","send","setTimeout","abort"],"mappings":"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","sourcesContent":["import Dexie from \"dexie\";\r\nimport \"dexie-observable\";\r\nimport { promised } from \"q\";\r\nimport { promises } from \"fs\";\r\n\r\n// Define your database\r\nexport const db = new Dexie(\"Song_Database\");\r\n\r\n// create new databse\r\n// our schema is of storing a song\r\ndb.version(1).stores({\r\n  songs:\r\n    \"&videoId, timestamp, playbackTimes, [rating+timestamp], [downloadState+timestamp]\"\r\n});\r\n\r\ndb.version(2).stores({});\r\n\r\n// add or update song on play\r\nexport const updatePlayingSong = async data => {\r\n  const videoObj = {\r\n    videoId: data.id,\r\n    timestamp: Date.now(),\r\n    title: data.title,\r\n    channelTitle: data.channelTitle,\r\n    playbackTimes: 1\r\n  };\r\n\r\n  const song = await db.songs.get({ videoId: data.id });\r\n  // if song exists we will just update the timestamp and the playback\r\n  if (song) {\r\n    db.songs.update(data.id, {\r\n      timestamp: Date.now(),\r\n      playbackTimes: song.playbackTimes + 1\r\n    });\r\n    console.log(\"song updated\");\r\n    return song.rating;\r\n    // return the rating\r\n  } else {\r\n    // we will add a new song\r\n    console.log(\"song added\");\r\n    db.songs.add(videoObj);\r\n  }\r\n};\r\n\r\n// like or dislike a song on database\r\nexport const rateSong = async (id, rating) => {\r\n  // if user likes the song then only download it\r\n\r\n  db.songs.update(id, {\r\n    rating: rating\r\n  });\r\n};\r\n\r\nexport const getHistory = async () => {\r\n  const songsByTimeStamp = await db.songs\r\n    .orderBy(\"timestamp\")\r\n    .limit(500)\r\n    .reverse()\r\n    .toArray();\r\n  return songsByTimeStamp;\r\n};\r\n\r\nexport const getLikedSongs = async () => {\r\n  const likedSongs = await db.songs\r\n    .where(\"[rating+timestamp]\") //this will filter song based on time and liked\r\n    .between([\"liked\", Dexie.minKey], [\"liked\", Dexie.maxKey])\r\n    .reverse()\r\n    .toArray();\r\n  return likedSongs;\r\n};\r\n\r\nexport const getDownloadedSongs = async () => {\r\n  const downloadedSongs = await db.songs\r\n    .where(\"[downloadState+timestamp]\") //this will filter song based on time and downloaded\r\n    .between([\"downloaded\", Dexie.minKey], [\"downloaded\", Dexie.maxKey])\r\n    .reverse()\r\n    .toArray();\r\n  return downloadedSongs;\r\n};\r\n\r\nexport const removeDownloadingState = async () => {\r\n  // find all the downloadState which is downloading and remove that\r\n  const songs = await db.songs\r\n    .where(\"[downloadState+timestamp]\")\r\n    .between([\"downloading\", Dexie.minKey], [\"downloading\", Dexie.maxKey])\r\n    .modify(x => {\r\n      delete x.downloadState;\r\n    });\r\n  console.log(songs);\r\n};\r\n\r\nexport const downloadSong = async (id, url) => {\r\n  try {\r\n    db.songs.update(id, {\r\n      downloadState: \"downloading\"\r\n    });\r\n    const thumbURL = `https://i.ytimg.com/vi/${id}/hqdefault.jpg`;\r\n    const [thumbnailBlob, songBlob] = await Promise.all([\r\n      fetchProxiedBlob(thumbURL),\r\n      fetchProxiedBlob(url)\r\n    ]);\r\n    db.songs.update(id, {\r\n      downloadState: \"downloaded\",\r\n      thumbnail: thumbnailBlob,\r\n      audio: songBlob\r\n    });\r\n    return \"downloaded\";\r\n  } catch (error) {\r\n    return error;\r\n  }\r\n};\r\n\r\nexport const deleteSongAudio = async id => {\r\n  await db.songs.where({ videoId: id }).modify(x => {\r\n    delete x.audio;\r\n    delete x.downloadState;\r\n  });\r\n  return \"song deleted\";\r\n};\r\n\r\nfunction fetchProxiedBlob(url) {\r\n  const URL = url;\r\n  return new Promise(function(resolve, reject) {\r\n    var xhr = new XMLHttpRequest();\r\n    xhr.open(\"GET\", \"http://localhost:9150/proxy/\" + URL);\r\n    xhr.responseType = \"blob\";\r\n    xhr.onload = function() {\r\n      var status = xhr.status;\r\n      if (status >= 200 && status < 300) {\r\n        resolve(xhr.response);\r\n      } else {\r\n        reject({\r\n          status: status,\r\n          statusText: xhr.statusText\r\n        });\r\n      }\r\n    };\r\n    xhr.send();\r\n    setTimeout(() => {\r\n      xhr.abort();\r\n      xhr.open(\"GET\", \"http://localhost:9150/proxy/\" + URL);\r\n\r\n      xhr.send();\r\n    }, 1000);\r\n  });\r\n}\r\n"]},"metadata":{},"sourceType":"module"}