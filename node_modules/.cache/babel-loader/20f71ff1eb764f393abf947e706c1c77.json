{"ast":null,"code":"import AudioContext from './AudioContext';\nlet analyser;\nlet audioCtx;\nlet mediaRecorder;\nlet chunks = [];\nlet startTime;\nlet stream;\nlet mediaOptions;\nlet onStartCallback;\nlet onStopCallback;\nlet onSaveCallback;\nlet onDataCallback;\nlet constraints;\nnavigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia;\nexport class MicrophoneRecorder {\n  constructor(onStart, onStop, onSave, onData, options, soundOptions) {\n    this.startRecording = () => {\n      startTime = Date.now();\n\n      if (mediaRecorder) {\n        if (audioCtx && audioCtx.state === 'suspended') {\n          audioCtx.resume();\n        }\n\n        if (mediaRecorder && mediaRecorder.state === 'paused') {\n          mediaRecorder.resume();\n          return;\n        }\n\n        if (audioCtx && mediaRecorder && mediaRecorder.state === 'inactive') {\n          mediaRecorder.start(10);\n          const source = audioCtx.createMediaStreamSource(stream);\n          source.connect(analyser);\n\n          if (onStartCallback) {\n            onStartCallback();\n          }\n        }\n      } else if (navigator.mediaDevices) {\n        console.log('getUserMedia supported.');\n        navigator.mediaDevices.getUserMedia(constraints).then(str => {\n          stream = str;\n\n          if (MediaRecorder.isTypeSupported(mediaOptions.mimeType)) {\n            mediaRecorder = new MediaRecorder(str, mediaOptions);\n          } else {\n            mediaRecorder = new MediaRecorder(str);\n          }\n\n          if (onStartCallback) {\n            onStartCallback();\n          }\n\n          mediaRecorder.onstop = this.onStop;\n\n          mediaRecorder.ondataavailable = event => {\n            chunks.push(event.data);\n\n            if (onDataCallback) {\n              onDataCallback(event.data);\n            }\n          };\n\n          audioCtx = AudioContext.getAudioContext();\n          audioCtx.resume().then(() => {\n            analyser = AudioContext.getAnalyser();\n            mediaRecorder.start(10);\n            const sourceNode = audioCtx.createMediaStreamSource(stream);\n            sourceNode.connect(analyser);\n          });\n        });\n      } else {\n        alert('Your browser does not support audio recording');\n      }\n    };\n\n    const {\n      echoCancellation,\n      autoGainControl,\n      noiseSuppression,\n      channelCount\n    } = soundOptions;\n    onStartCallback = onStart;\n    onStopCallback = onStop;\n    onSaveCallback = onSave;\n    onDataCallback = onData;\n    mediaOptions = options;\n    constraints = {\n      audio: {\n        echoCancellation,\n        autoGainControl,\n        noiseSuppression,\n        channelCount\n      },\n      video: false\n    };\n  }\n\n  stopRecording() {\n    if (mediaRecorder && mediaRecorder.state !== 'inactive') {\n      mediaRecorder.stop();\n      stream.getAudioTracks().forEach(track => {\n        track.stop();\n      });\n      mediaRecorder = null;\n      AudioContext.resetAnalyser();\n    }\n  }\n\n  onStop() {\n    const blob = new Blob(chunks, {\n      type: mediaOptions.mimeType\n    });\n    chunks = [];\n    const blobObject = {\n      blob,\n      startTime,\n      stopTime: Date.now(),\n      options: mediaOptions,\n      path: 'video-mp3aww'\n    };\n\n    if (onStopCallback) {\n      onStopCallback(blobObject);\n    }\n\n    if (onSaveCallback) {\n      onSaveCallback(blobObject);\n    }\n  }\n\n}","map":{"version":3,"sources":["C:/myProJects/Server/weatherapp/src/components/library/MicrophoneRecorder.js"],"names":["AudioContext","analyser","audioCtx","mediaRecorder","chunks","startTime","stream","mediaOptions","onStartCallback","onStopCallback","onSaveCallback","onDataCallback","constraints","navigator","getUserMedia","webkitGetUserMedia","mozGetUserMedia","msGetUserMedia","MicrophoneRecorder","constructor","onStart","onStop","onSave","onData","options","soundOptions","startRecording","Date","now","state","resume","start","source","createMediaStreamSource","connect","mediaDevices","console","log","then","str","MediaRecorder","isTypeSupported","mimeType","onstop","ondataavailable","event","push","data","getAudioContext","getAnalyser","sourceNode","alert","echoCancellation","autoGainControl","noiseSuppression","channelCount","audio","video","stopRecording","stop","getAudioTracks","forEach","track","resetAnalyser","blob","Blob","type","blobObject","stopTime","path"],"mappings":"AAAA,OAAOA,YAAP,MAAyB,gBAAzB;AAEA,IAAIC,QAAJ;AACA,IAAIC,QAAJ;AACA,IAAIC,aAAJ;AACA,IAAIC,MAAM,GAAG,EAAb;AACA,IAAIC,SAAJ;AACA,IAAIC,MAAJ;AACA,IAAIC,YAAJ;AACA,IAAIC,eAAJ;AACA,IAAIC,cAAJ;AACA,IAAIC,cAAJ;AACA,IAAIC,cAAJ;AACA,IAAIC,WAAJ;AAEAC,SAAS,CAACC,YAAV,GAA0BD,SAAS,CAACC,YAAV,IACGD,SAAS,CAACE,kBADb,IAEGF,SAAS,CAACG,eAFb,IAGGH,SAAS,CAACI,cAHvC;AAKA,OAAO,MAAMC,kBAAN,CAAyB;AAC9BC,EAAAA,WAAW,CAACC,OAAD,EAAUC,MAAV,EAAkBC,MAAlB,EAA0BC,MAA1B,EAAkCC,OAAlC,EAA2CC,YAA3C,EAAyD;AAAA,SAyBpEC,cAzBoE,GAyBrD,MAAM;AACnBrB,MAAAA,SAAS,GAAGsB,IAAI,CAACC,GAAL,EAAZ;;AAEA,UAAIzB,aAAJ,EAAmB;AACjB,YAAID,QAAQ,IAAIA,QAAQ,CAAC2B,KAAT,KAAmB,WAAnC,EAAgD;AAC9C3B,UAAAA,QAAQ,CAAC4B,MAAT;AACD;;AAED,YAAI3B,aAAa,IAAIA,aAAa,CAAC0B,KAAd,KAAwB,QAA7C,EAAuD;AACrD1B,UAAAA,aAAa,CAAC2B,MAAd;AACA;AACD;;AAED,YAAI5B,QAAQ,IAAIC,aAAZ,IAA6BA,aAAa,CAAC0B,KAAd,KAAwB,UAAzD,EAAqE;AACnE1B,UAAAA,aAAa,CAAC4B,KAAd,CAAoB,EAApB;AACA,gBAAMC,MAAM,GAAG9B,QAAQ,CAAC+B,uBAAT,CAAiC3B,MAAjC,CAAf;AACA0B,UAAAA,MAAM,CAACE,OAAP,CAAejC,QAAf;;AACA,cAAIO,eAAJ,EAAqB;AAAEA,YAAAA,eAAe;AAAI;AAC3C;AACF,OAhBD,MAgBO,IAAIK,SAAS,CAACsB,YAAd,EAA4B;AACjCC,QAAAA,OAAO,CAACC,GAAR,CAAY,yBAAZ;AAEAxB,QAAAA,SAAS,CAACsB,YAAV,CAAuBrB,YAAvB,CAAoCF,WAApC,EACG0B,IADH,CACSC,GAAD,IAAS;AACbjC,UAAAA,MAAM,GAAGiC,GAAT;;AAEA,cAAIC,aAAa,CAACC,eAAd,CAA8BlC,YAAY,CAACmC,QAA3C,CAAJ,EAA0D;AACxDvC,YAAAA,aAAa,GAAG,IAAIqC,aAAJ,CAAkBD,GAAlB,EAAuBhC,YAAvB,CAAhB;AACD,WAFD,MAEO;AACLJ,YAAAA,aAAa,GAAG,IAAIqC,aAAJ,CAAkBD,GAAlB,CAAhB;AACD;;AAED,cAAI/B,eAAJ,EAAqB;AAAEA,YAAAA,eAAe;AAAI;;AAE1CL,UAAAA,aAAa,CAACwC,MAAd,GAAuB,KAAKtB,MAA5B;;AACAlB,UAAAA,aAAa,CAACyC,eAAd,GAAiCC,KAAD,IAAW;AACzCzC,YAAAA,MAAM,CAAC0C,IAAP,CAAYD,KAAK,CAACE,IAAlB;;AACA,gBAAIpC,cAAJ,EAAoB;AAClBA,cAAAA,cAAc,CAACkC,KAAK,CAACE,IAAP,CAAd;AACD;AACF,WALD;;AAOA7C,UAAAA,QAAQ,GAAGF,YAAY,CAACgD,eAAb,EAAX;AACA9C,UAAAA,QAAQ,CAAC4B,MAAT,GAAkBQ,IAAlB,CAAuB,MAAM;AAC3BrC,YAAAA,QAAQ,GAAGD,YAAY,CAACiD,WAAb,EAAX;AACA9C,YAAAA,aAAa,CAAC4B,KAAd,CAAoB,EAApB;AACA,kBAAMmB,UAAU,GAAGhD,QAAQ,CAAC+B,uBAAT,CAAiC3B,MAAjC,CAAnB;AACA4C,YAAAA,UAAU,CAAChB,OAAX,CAAmBjC,QAAnB;AACD,WALD;AAMD,SA3BH;AA4BD,OA/BM,MA+BA;AACLkD,QAAAA,KAAK,CAAC,+CAAD,CAAL;AACD;AACF,KA9EmE;;AAClE,UAAM;AACJC,MAAAA,gBADI;AAEJC,MAAAA,eAFI;AAGJC,MAAAA,gBAHI;AAIJC,MAAAA;AAJI,QAKF9B,YALJ;AAOAjB,IAAAA,eAAe,GAAGY,OAAlB;AACAX,IAAAA,cAAc,GAAGY,MAAjB;AACAX,IAAAA,cAAc,GAAGY,MAAjB;AACAX,IAAAA,cAAc,GAAGY,MAAjB;AACAhB,IAAAA,YAAY,GAAGiB,OAAf;AAEAZ,IAAAA,WAAW,GAAG;AACZ4C,MAAAA,KAAK,EAAE;AACLJ,QAAAA,gBADK;AAELC,QAAAA,eAFK;AAGLC,QAAAA,gBAHK;AAILC,QAAAA;AAJK,OADK;AAOZE,MAAAA,KAAK,EAAE;AAPK,KAAd;AASD;;AAyDDC,EAAAA,aAAa,GAAG;AACd,QAAIvD,aAAa,IAAIA,aAAa,CAAC0B,KAAd,KAAwB,UAA7C,EAAyD;AACvD1B,MAAAA,aAAa,CAACwD,IAAd;AAEArD,MAAAA,MAAM,CAACsD,cAAP,GAAwBC,OAAxB,CAAiCC,KAAD,IAAW;AACzCA,QAAAA,KAAK,CAACH,IAAN;AACD,OAFD;AAGAxD,MAAAA,aAAa,GAAG,IAAhB;AACAH,MAAAA,YAAY,CAAC+D,aAAb;AACD;AACF;;AAED1C,EAAAA,MAAM,GAAG;AACP,UAAM2C,IAAI,GAAG,IAAIC,IAAJ,CAAS7D,MAAT,EAAiB;AAAE8D,MAAAA,IAAI,EAAE3D,YAAY,CAACmC;AAArB,KAAjB,CAAb;AACAtC,IAAAA,MAAM,GAAG,EAAT;AAEA,UAAM+D,UAAU,GAAG;AACjBH,MAAAA,IADiB;AAEjB3D,MAAAA,SAFiB;AAGjB+D,MAAAA,QAAQ,EAAEzC,IAAI,CAACC,GAAL,EAHO;AAIjBJ,MAAAA,OAAO,EAAEjB,YAJQ;AAKjB8D,MAAAA,IAAI,EAAE;AALW,KAAnB;;AAQA,QAAI5D,cAAJ,EAAoB;AAAEA,MAAAA,cAAc,CAAC0D,UAAD,CAAd;AAA4B;;AAClD,QAAIzD,cAAJ,EAAoB;AAAEA,MAAAA,cAAc,CAACyD,UAAD,CAAd;AAA4B;AACnD;;AA3G6B","sourcesContent":["import AudioContext from './AudioContext'\r\n\r\nlet analyser\r\nlet audioCtx\r\nlet mediaRecorder\r\nlet chunks = []\r\nlet startTime\r\nlet stream\r\nlet mediaOptions\r\nlet onStartCallback\r\nlet onStopCallback\r\nlet onSaveCallback\r\nlet onDataCallback\r\nlet constraints\r\n\r\nnavigator.getUserMedia = (navigator.getUserMedia\r\n                          || navigator.webkitGetUserMedia\r\n                          || navigator.mozGetUserMedia\r\n                          || navigator.msGetUserMedia)\r\n\r\nexport class MicrophoneRecorder {\r\n  constructor(onStart, onStop, onSave, onData, options, soundOptions) {\r\n    const {\r\n      echoCancellation,\r\n      autoGainControl,\r\n      noiseSuppression,\r\n      channelCount\r\n    } = soundOptions\r\n\r\n    onStartCallback = onStart\r\n    onStopCallback = onStop\r\n    onSaveCallback = onSave\r\n    onDataCallback = onData\r\n    mediaOptions = options\r\n\r\n    constraints = {\r\n      audio: {\r\n        echoCancellation,\r\n        autoGainControl,\r\n        noiseSuppression,\r\n        channelCount\r\n      },\r\n      video: false\r\n    }\r\n  }\r\n\r\n  startRecording=() => {\r\n    startTime = Date.now()\r\n\r\n    if (mediaRecorder) {\r\n      if (audioCtx && audioCtx.state === 'suspended') {\r\n        audioCtx.resume()\r\n      }\r\n\r\n      if (mediaRecorder && mediaRecorder.state === 'paused') {\r\n        mediaRecorder.resume()\r\n        return\r\n      }\r\n\r\n      if (audioCtx && mediaRecorder && mediaRecorder.state === 'inactive') {\r\n        mediaRecorder.start(10)\r\n        const source = audioCtx.createMediaStreamSource(stream)\r\n        source.connect(analyser)\r\n        if (onStartCallback) { onStartCallback() }\r\n      }\r\n    } else if (navigator.mediaDevices) {\r\n      console.log('getUserMedia supported.')\r\n\r\n      navigator.mediaDevices.getUserMedia(constraints)\r\n        .then((str) => {\r\n          stream = str\r\n\r\n          if (MediaRecorder.isTypeSupported(mediaOptions.mimeType)) {\r\n            mediaRecorder = new MediaRecorder(str, mediaOptions)\r\n          } else {\r\n            mediaRecorder = new MediaRecorder(str)\r\n          }\r\n\r\n          if (onStartCallback) { onStartCallback() }\r\n\r\n          mediaRecorder.onstop = this.onStop\r\n          mediaRecorder.ondataavailable = (event) => {\r\n            chunks.push(event.data)\r\n            if (onDataCallback) {\r\n              onDataCallback(event.data)\r\n            }\r\n          }\r\n\r\n          audioCtx = AudioContext.getAudioContext()\r\n          audioCtx.resume().then(() => {\r\n            analyser = AudioContext.getAnalyser()\r\n            mediaRecorder.start(10)\r\n            const sourceNode = audioCtx.createMediaStreamSource(stream)\r\n            sourceNode.connect(analyser)\r\n          })\r\n        })\r\n    } else {\r\n      alert('Your browser does not support audio recording')\r\n    }\r\n  }\r\n\r\n  stopRecording() {\r\n    if (mediaRecorder && mediaRecorder.state !== 'inactive') {\r\n      mediaRecorder.stop()\r\n\r\n      stream.getAudioTracks().forEach((track) => {\r\n        track.stop()\r\n      })\r\n      mediaRecorder = null\r\n      AudioContext.resetAnalyser()\r\n    }\r\n  }\r\n\r\n  onStop() {\r\n    const blob = new Blob(chunks, { type: mediaOptions.mimeType })\r\n    chunks = []\r\n\r\n    const blobObject = {\r\n      blob,\r\n      startTime,\r\n      stopTime: Date.now(),\r\n      options: mediaOptions,\r\n      path: 'video-mp3aww'\r\n    }\r\n\r\n    if (onStopCallback) { onStopCallback(blobObject) }\r\n    if (onSaveCallback) { onSaveCallback(blobObject) }\r\n  }\r\n}"]},"metadata":{},"sourceType":"module"}